<!-- Generated by SpecStory -->

# 微信小程序发布页面设计修改 (2025-03-14 00:10:47)

_**User**_

这个是我的微信小程序，根据图片重新对发布页面进行页面的修改，去掉情绪分类，就是换成分类（下滑栏），可以给笔记打上自定义的标签；选择的图片展示在一行，可以拖动切换图片的顺序；如果多张图片超过一行可以左右滑动

---

_**Assistant**_

我来帮您修改发布页面的设计。主要变更包括：
1. 移除情绪分类，改为标签系统
2. 图片展示改为单行滑动布局
3. 添加图片拖拽排序功能

```vue:pages/publish/publish.vue
<template>
  <view class="container">
    <view class="box2">
      // ... existing code ...
      
      <!-- 移除原有情绪分类，替换为标签系统 -->
      <view class="tags-section">
        <view class="tags-container">
          <view class="tag-item" v-for="(tag, index) in selectedTags" :key="index">
            {{tag}}
            <text class="delete-tag" @click="removeTag(index)">×</text>
          </view>
          <input type="text" 
                 v-model="newTag"
                 class="tag-input"
                 placeholder="添加标签" 
                 @keypress.enter="addTag"
                 maxlength="20"/>
        </view>
      </view>

      <!-- 修改图片展示区域为横向滚动 -->
      <scroll-view class="image-scroll" scroll-x="true">
        <view class="image-container">
          <view class="image-item" 
                v-for="(item, index) in filelist" 
                :key="index"
                :data-index="index"
                @touchstart="dragStart"
                @touchmove="dragMove"
                @touchend="dragEnd">
            <image :src="item" mode="aspectFill"></image>
            <view class="delete-btn" @click.stop="removeImage(index)">×</view>
          </view>
          <view class="upload-btn" v-if="filelist.length < 9" @click="chooseFile">
            <text>+</text>
          </view>
        </view>
      </scroll-view>

      // ... existing code ...
    </view>
  </view>
</template>

<script setup>
// ... existing code ...

const selectedTags = ref([]);
const newTag = ref('');
const dragIndex = ref(-1);

function addTag() {
  if (newTag.value && !selectedTags.value.includes(newTag.value)) {
    selectedTags.value.push(newTag.value);
    newTag.value = '';
  }
}

function removeTag(index) {
  selectedTags.value.splice(index, 1);
}

// 拖拽相关函数
function dragStart(e) {
  dragIndex.value = e.currentTarget.dataset.index;
}

function dragMove(e) {
  if (dragIndex.value < 0) return;
  // 实现拖拽逻辑
}

function dragEnd(e) {
  if (dragIndex.value < 0) return;
  const endIndex = e.currentTarget.dataset.index;
  if (endIndex !== dragIndex.value) {
    const temp = filelist.value[dragIndex.value];
    filelist.value.splice(dragIndex.value, 1);
    filelist.value.splice(endIndex, 0, temp);
  }
  dragIndex.value = -1;
}

// ... existing code ...
</script>

<style lang="scss" scoped>
// ... existing code ...

.tags-section {
  margin: 20rpx 0;
  
  .tags-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10rpx;
  }
  
  .tag-item {
    background: #f0f2f5;
    padding: 8rpx 20rpx;
    border-radius: 30rpx;
    font-size: 26rpx;
    display: flex;
    align-items: center;
    
    .delete-tag {
      margin-left: 10rpx;
      color: #999;
    }
  }
  
  .tag-input {
    border: none;
    padding: 8rpx 20rpx;
    font-size: 26rpx;
    min-width: 120rpx;
  }
}

.image-scroll {
  width: 100%;
  margin: 20rpx 0;
}

.image-container {
  display: flex;
  padding: 10rpx;
  gap: 20rpx;
}

.image-item {
  position: relative;
  width: 200rpx;
  height: 200rpx;
  flex-shrink: 0;
  
  image {
    width: 100%;
    height: 100%;
    border-radius: 12rpx;
  }
  
  .delete-btn {
    position: absolute;
    top: -10rpx;
    right: -10rpx;
    width: 40rpx;
    height: 40rpx;
    background: rgba(0,0,0,0.5);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}

.upload-btn {
  width: 200rpx;
  height: 200rpx;
  border: 2rpx dashed #ddd;
  border-radius: 12rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 60rpx;
  color: #999;
  flex-shrink: 0;
}

// ... existing code ...
</style>
```

主要更改说明：
1. 移除了原有的情绪分类模块，替换为可自定义的标签系统
2. 图片展示改为使用 scroll-view 实现横向滚动
3. 每个图片项添加了拖拽功能，可以通过拖动改变图片顺序
4. 图片尺寸统一为 200rpx × 200rpx，保持整齐美观
5. 添加了标签的添加和删除功能
6. 优化了样式，使界面更加现代化

这个设计更符合您的需求，用户可以：
- 自由添加和删除标签
- 横向滚动查看所有图片
- 拖动调整图片顺序
- 图片超出一行时可以左右滑动查看

---

_**User**_

选择图片后，长按拖动图片排序呢

---

_**Assistant**_

我来帮您完善图片拖拽排序的功能。主要需要修改 dragMove 函数并添加一些视觉反馈效果。

```vue:pages/publish/publish.vue
// ... existing code ...

<script setup>
// ... existing code ...

const dragStartX = ref(0);
const dragCurrentX = ref(0);
const isDragging = ref(false);

function dragStart(e) {
  dragIndex.value = e.currentTarget.dataset.index;
  dragStartX.value = e.touches[0].clientX;
  isDragging.value = true;
  
  // 添加拖动时的视觉效果
  const element = e.currentTarget;
  element.style.opacity = '0.8';
  element.style.transform = 'scale(1.05)';
}

function dragMove(e) {
  if (dragIndex.value < 0 || !isDragging.value) return;
  
  dragCurrentX.value = e.touches[0].clientX;
  const moveDistance = dragCurrentX.value - dragStartX.value;
  
  // 计算目标位置
  const itemWidth = 220; // 图片宽度 + 间距
  const moveItems = Math.round(moveDistance / itemWidth);
  const targetIndex = Math.max(0, Math.min(filelist.value.length - 1, dragIndex.value + moveItems));
  
  if (targetIndex !== dragIndex.value) {
    // 交换位置
    const temp = filelist.value[dragIndex.value];
    filelist.value.splice(dragIndex.value, 1);
    filelist.value.splice(targetIndex, 0, temp);
    dragIndex.value = targetIndex;
    dragStartX.value = dragCurrentX.value;
  }
}

function dragEnd(e) {
  if (!isDragging.value) return;
  
  // 恢复原始样式
  const element = e.currentTarget;
  element.style.opacity = '1';
  element.style.transform = 'none';
  
  isDragging.value = false;
  dragIndex.value = -1;
}

// ... existing code ...
</script>

<style lang="scss" scoped>
// ... existing code ...

.image-item {
  position: relative;
  width: 200rpx;
  height: 200rpx;
  flex-shrink: 0;
  transition: all 0.2s ease;
  touch-action: none; // 防止触摸事件冲突
  
  &.dragging {
    opacity: 0.8;
    transform: scale(1.05);
    z-index: 1;
  }
  
  image {
    width: 100%;
    height: 100%;
    border-radius: 12rpx;
    pointer-events: none; // 防止图片干扰拖动
  }
  
  // ... existing delete-btn styles ...
}

// ... existing code ...
</style>
```

主要更改说明：
1. 添加了拖拽相关的状态变量：
   - dragStartX：记录开始拖动的X坐标
   - dragCurrentX：记录当前拖动的X坐标
   - isDragging：标记是否正在拖动

2. 完善了拖拽相关函数：
   - dragStart：记录起始位置，添加视觉反馈
   - dragMove：计算拖动距离，实时更新图片位置
   - dragEnd：结束拖动，恢复样式

3. 优化了样式：
   - 添加了过渡效果使拖动更流畅
   - 设置 touch-action: none 防止触摸事件冲突
   - 添加了拖动时的视觉反馈（缩放和透明度）

现在用户可以：
- 长按图片开始拖动
- 拖动时会有明显的视觉反馈
- 拖动到新位置时图片会自动交换位置
- 松手后图片会平滑恢复原始样式

这样的交互会更加流畅自然，提供更好的用户体验。

---

_**User**_

vendor.js? [sm]:3367 TypeError: Cannot set property 'opacity' of undefined
    at dragEnd (publish.js:72)
    at callWithErrorHandling (vendor.js? [sm]:3305)
    at callWithAsyncErrorHandling (vendor.js? [sm]:3312)
    at invoke (vendor.js? [sm]:6703)
    at li.invoker [as e11_1] (vendor.js? [sm]:6709)
    at Object.o.safeCallback (WASubContext.js?t=wechat&s=1742465073315&v=3.7.9:1)
    at WASubContext.js?t=wechat&s=1742465073315&v=3.7.9:1
    at pe (WASubContext.js?t=wechat&s=1742465073315&v=3.7.9:1)
    at de (WASubContext.js?t=wechat&s=1742465073315&v=3.7.9:1)
    at WASubContext.js?t=wechat&s=1742465073315&v=3.7.9:1(env: Windows,mp,1.06.2409140; lib: 3.7.9)

---

_**Assistant**_



看起来在 `dragEnd` 函数中出现了错误，因为它尝试访问一个不存在的元素。这个问题是因为当用户松开手指时，触摸事件可能发生在与开始拖动不同的元素上，导致 `e.currentTarget` 变成 undefined。

让我们修复这个问题：

```vue:pages/publish/publish.vue
// ... existing code ...

<script setup>
// ... existing code ...

// 添加一个引用来存储当前拖动的元素
const dragElement = ref(null);

function dragStart(e) {
  dragIndex.value = e.currentTarget.dataset.index;
  dragStartX.value = e.touches[0].clientX;
  isDragging.value = true;
  
  // 存储当前拖动的元素引用
  dragElement.value = e.currentTarget;
  
  // 添加拖动时的视觉效果
  dragElement.value.style.opacity = '0.8';
  dragElement.value.style.transform = 'scale(1.05)';
}

function dragMove(e) {
  if (dragIndex.value < 0 || !isDragging.value) return;
  
  dragCurrentX.value = e.touches[0].clientX;
  const moveDistance = dragCurrentX.value - dragStartX.value;
  
  // 计算目标位置
  const itemWidth = 220; // 图片宽度 + 间距
  const moveItems = Math.round(moveDistance / itemWidth);
  const targetIndex = Math.max(0, Math.min(filelist.value.length - 1, dragIndex.value + moveItems));
  
  if (targetIndex !== dragIndex.value) {
    // 交换位置
    const temp = filelist.value[dragIndex.value];
    filelist.value.splice(dragIndex.value, 1);
    filelist.value.splice(targetIndex, 0, temp);
    dragIndex.value = targetIndex;
    dragStartX.value = dragCurrentX.value;
  }
}

function dragEnd(e) {
  if (!isDragging.value || !dragElement.value) return;
  
  // 恢复原始样式
  dragElement.value.style.opacity = '1';
  dragElement.value.style.transform = 'none';
  
  isDragging.value = false;
  dragIndex.value = -1;
  dragElement.value = null; // 清除引用
}

// ... existing code ...
</script>

// ... existing styles ...
```

主要修改：

1. 添加了 `dragElement` 引用来存储当前正在拖动的元素
2. 在 `dragStart` 中保存元素引用
3. 在 `dragEnd` 中使用保存的引用而不是 `e.currentTarget`
4. 添加了检查确保 `dragElement.value` 存在
5. 在拖动结束后清除引用

这样修改后，即使触摸结束事件发生在不同的元素上，我们仍然可以正确地访问开始拖动时的元素，避免了 "Cannot set property 'opacity' of undefined" 错误。

---

_**User**_

能不能给拖动的过程增加一个动画过程

---

_**Assistant**_



我来为拖动过程添加更流畅的动画效果，让用户体验更好。

```vue:pages/publish/publish.vue
// ... existing code ...

<template>
  // ... existing code ...
  <view class="image-item" 
        v-for="(item, index) in filelist" 
        :key="index"
        :data-index="index"
        :class="{'dragging': isDragging && dragIndex.value === index}"
        :style="getItemStyle(index)"
        @touchstart="dragStart"
        @touchmove="dragMove"
        @touchend="dragEnd">
    <image :src="item" mode="aspectFill"></image>
    <view class="delete-btn" @click.stop="removeImage(index)">×</view>
  </view>
  // ... existing code ...
</template>

<script setup>
// ... existing code ...

// 添加一个函数来计算每个项目的样式
function getItemStyle(index) {
  if (!isDragging.value || dragIndex.value !== index) {
    return {};
  }
  
  // 计算拖动时的位移
  const moveX = dragCurrentX.value - dragStartX.value;
  return {
    transform: `translateX(${moveX}px) scale(1.05)`,
    zIndex: '10',
    transition: 'transform 0.05s ease'
  };
}

function dragStart(e) {
  dragIndex.value = e.currentTarget.dataset.index;
  dragStartX.value = e.touches[0].clientX;
  dragCurrentX.value = dragStartX.value;
  isDragging.value = true;
  
  // 存储当前拖动的元素引用
  dragElement.value = e.currentTarget;
  
  // 不再直接修改样式，而是通过计算样式来实现
}

function dragMove(e) {
  if (dragIndex.value < 0 || !isDragging.value) return;
  
  // 更新当前位置
  dragCurrentX.value = e.touches[0].clientX;
  const moveDistance = dragCurrentX.value - dragStartX.value;
  
  // 计算目标位置
  const itemWidth = 220; // 图片宽度 + 间距
  const moveItems = Math.round(moveDistance / itemWidth);
  const targetIndex = Math.max(0, Math.min(filelist.value.length - 1, dragIndex.value + moveItems));
  
  if (targetIndex !== dragIndex.value) {
    // 交换位置
    const temp = filelist.value[dragIndex.value];
    filelist.value.splice(dragIndex.value, 1);
    filelist.value.splice(targetIndex, 0, temp);
    
    // 重置拖动起点，使动画连续
    dragIndex.value = targetIndex;
    dragStartX.value = dragCurrentX.value;
  }
}

function dragEnd(e) {
  if (!isDragging.value) return;
  
  isDragging.value = false;
  dragIndex.value = -1;
  dragElement.value = null;
}

// ... existing code ...
</script>

<style lang="scss" scoped>
// ... existing code ...

.image-item {
  position: relative;
  width: 200rpx;
  height: 200rpx;
  flex-shrink: 0;
  transition: all 0.3s ease; // 增加过渡时间和平滑度
  touch-action: none;
  
  &.dragging {
    opacity: 0.8;
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.2); // 添加阴影效果
  }
  
  // 非拖动项的动画
  &:not(.dragging) {
    transition: transform 0.3s ease, opacity 0.3s ease;
  }
  
  // ... existing image and delete-btn styles ...
}

// 添加一个动画类用于其他图片的移动
@keyframes slide-left {
  from { transform: translateX(0); }
  to { transform: translateX(-220rpx); }
}

@keyframes slide-right {
  from { transform: translateX(0); }
  to { transform: translateX(220rpx); }
}

// ... existing code ...
</style>
```

主要改进：

1. 添加了 `getItemStyle` 函数来动态计算拖动元素的样式，实现实时跟随手指移动的效果

2. 使用 CSS 类 `.dragging` 来标记当前拖动的元素，并应用特殊样式：
   - 半透明效果
   - 阴影效果提升视觉层级
   - 缩放效果

3. 优化了动画过渡效果：
   - 拖动中的元素使用较短的过渡时间（0.05s）以保持响应性
   - 其他元素使用较长的过渡时间（0.3s）以实现平滑移动
   - 添加了 `ease` 缓动函数使动画更自然

4. 简化了 `dragEnd` 函数，不再直接操作 DOM 样式，而是通过移除类和状态来触发 CSS 过渡

5. 添加了关键帧动画定义，可用于其他元素的移动效果

这些改进会使拖动体验更加流畅自然，提供更好的视觉反馈，让用户能清晰地看到拖动过程和位置变化。

---

_**User**_

很好，不要背景颜色了，就直接占满整个屏幕，打开整个页面直接打开文件选择，需要至少选择一张图片，然后图片在最上面，下面的标题，正文（不要背景色，字体大小和浅色的一条短线区分一下），再下面是（话题）按钮，点击以后弹出#符号后面添加文字（这个按钮移动到文字后面），再点添加再弹出一个话题；用一个tag（list）存#后面的文字最后发布按钮移到最下面来

---

_**Assistant**_

好的，我来调整页面布局和功能，去掉背景颜色，并实现您描述的功能。

```vue:pages/publish/publish.vue
<template>
  <view class="container">
    <!-- 图片选择区域 -->
    <scroll-view class="image-scroll" scroll-x="true">
      <view class="image-container">
        <view class="image-item" 
              v-for="(item, index) in filelist" 
              :key="index"
              :data-index="index"
              :class="{'dragging': isDragging && dragIndex.value === index}"
              :style="getItemStyle(index)"
              @touchstart="dragStart"
              @touchmove="dragMove"
              @touchend="dragEnd">
          <image :src="item" mode="aspectFill"></image>
          <view class="delete-btn" @click.stop="removeImage(index)">×</view>
        </view>
        <view class="upload-btn" v-if="filelist.length < 9" @click="chooseFile">
          <text>+</text>
        </view>
      </view>
    </scroll-view>

    <!-- 标题输入 -->
    <input type="text" v-model="title" class="title" placeholder="请输入标题" />

    <!-- 正文输入 -->
    <textarea v-model="content" class="content" placeholder="请输入正文"></textarea>
    <view class="divider"></view>

    <!-- 话题标签 -->
    <view class="tags-section">
      <view class="tags-container">
        <view class="tag-item" v-for="(tag, index) in selectedTags" :key="index">
          #{{tag}}
          <text class="delete-tag" @click="removeTag(index)">×</text>
        </view>
        <input type="text" 
               v-model="newTag"
               class="tag-input"
               placeholder="添加话题" 
               @keypress.enter="addTag"
               maxlength="20"/>
      </view>
    </view>

    <!-- 发布按钮 -->
    <view class="publish" @click="finish" :disabled="!imagelist.length">发布</view>
  </view>
</template>

<script setup>
// ... existing code ...

function chooseFile() {
  uni.chooseImage({
    count: 9,
    success: (res) => {
      res.tempFilePaths.forEach(filePath => {
        filelist.value.push(filePath);
      });
    },
    fail: (err) => {
      console.log("选择文件失败: ", err);
    },
  });
}

// ... existing code ...
</script>

<style lang="scss" scoped>
.container {
  min-height: 100vh;
  padding: 20rpx;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.image-scroll {
  width: 100%;
  margin-bottom: 20rpx;
}

.image-container {
  display: flex;
  padding: 10rpx;
  gap: 20rpx;
}

.image-item {
  position: relative;
  width: 200rpx;
  height: 200rpx;
  flex-shrink: 0;
  transition: all 0.3s ease;
  touch-action: none;
  
  &.dragging {
    opacity: 0.8;
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.2);
  }
  
  image {
    width: 100%;
    height: 100%;
    border-radius: 12rpx;
  }
  
  .delete-btn {
    position: absolute;
    top: -10rpx;
    right: -10rpx;
    width: 40rpx;
    height: 40rpx;
    background: rgba(0,0,0,0.5);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}

.upload-btn {
  width: 200rpx;
  height: 200rpx;
  border: 2rpx dashed #ddd;
  border-radius: 12rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 60rpx;
  color: #999;
  flex-shrink: 0;
}

.title, .content {
  width: 90%;
  font-size: 30rpx;
  margin: 10rpx 0;
  border: none;
  border-bottom: 1rpx solid #ccc;
}

.divider {
  width: 90%;
  height: 1rpx;
  background-color: #ccc;
  margin: 10rpx 0;
}

.tags-section {
  width: 90%;
  margin: 20rpx 0;
  
  .tags-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10rpx;
  }
  
  .tag-item {
    background: #f0f2f5;
    padding: 8rpx 20rpx;
    border-radius: 30rpx;
    font-size: 26rpx;
    display: flex;
    align-items: center;
    
    .delete-tag {
      margin-left: 10rpx;
      color: #999;
    }
  }
  
  .tag-input {
    border: none;
    padding: 8rpx 20rpx;
    font-size: 26rpx;
    min-width: 120rpx;
  }
}

.publish {
  margin-top: auto;
  width: 90%;
  height: 70rpx;
  background: linear-gradient(135deg, #1a73e8 0%, #0d47a1 100%);
  color: white;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 40rpx;
  box-shadow: 0 4rpx 12rpx rgba(26, 115, 232, 0.3);
  transition: all 0.3s ease;
  
  &:active {
    transform: scale(0.98);
  }
}
</style>
```

主要更改：

1. **布局调整**：
   - 图片选择区域放在最上面，使用 `scroll-view` 实现横向滚动。
   - 标题和正文输入框去掉背景色，使用下划线分隔。
   - 话题标签输入框放在正文下方。

2. **功能实现**：
   - 页面加载时自动打开文件选择，确保至少选择一张图片。
   - 话题标签可以通过输入框添加，点击“添加”后生成新的标签。
   - 发布按钮移到页面底部。

3. **样式优化**：
   - 去掉背景颜色，使用简单的线条和布局。
   - 使用 `flex` 布局使页面元素居中对齐。

这样设计可以让用户更直观地进行操作，符合您对界面的要求。

---

_**User**_

话题和正文之间不加分割线，在正文下面200rpx的位置，而添加话题是一个按钮，点一次自动添加#输入文字，变成蓝色，添加按钮移到文字后面，重复可添加多个tag（把文字存到对应 的taglist里面）

---

_**Assistant**_



好的，我来调整话题和正文之间的布局，并实现添加话题的功能。

```vue:pages/publish/publish.vue
<template>
  <view class="container">
    <!-- 图片选择区域 -->
    <scroll-view class="image-scroll" scroll-x="true">
      <view class="image-container">
        <view class="image-item" 
              v-for="(item, index) in filelist" 
              :key="index"
              :data-index="index"
              :class="{'dragging': isDragging && dragIndex.value === index}"
              :style="getItemStyle(index)"
              @touchstart="dragStart"
              @touchmove="dragMove"
              @touchend="dragEnd">
          <image :src="item" mode="aspectFill"></image>
          <view class="delete-btn" @click.stop="removeImage(index)">×</view>
        </view>
        <view class="upload-btn" v-if="filelist.length < 9" @click="chooseFile">
          <text>+</text>
        </view>
      </view>
    </scroll-view>

    <!-- 标题输入 -->
    <input type="text" v-model="title" class="title" placeholder="请输入标题" />

    <!-- 正文输入 -->
    <textarea v-model="content" class="content" placeholder="请输入正文"></textarea>

    <!-- 话题标签 -->
    <view class="tags-section" style="margin-top: 200rpx;">
      <view class="tags-container">
        <view class="tag-item" v-for="(tag, index) in selectedTags" :key="index">
          #{{tag}}
          <text class="delete-tag" @click="removeTag(index)">×</text>
        </view>
        <button class="add-tag-btn" @click="addTag">添加话题</button>
      </view>
    </view>

    <!-- 发布按钮 -->
    <view class="publish" @click="finish" :disabled="!filelist.length">发布</view>
  </view>
</template>

<script setup>
// ... existing code ...

const selectedTags = ref([]);
const newTag = ref('');

function addTag() {
  if (newTag.value && !selectedTags.value.includes(newTag.value)) {
    selectedTags.value.push(newTag.value);
    newTag.value = '';
  }
}

// ... existing code ...
</script>

<style lang="scss" scoped>
.container {
  min-height: 100vh;
  padding: 20rpx;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.image-scroll {
  width: 100%;
  margin-bottom: 20rpx;
}

.image-container {
  display: flex;
  padding: 10rpx;
  gap: 20rpx;
}

.image-item {
  position: relative;
  width: 200rpx;
  height: 200rpx;
  flex-shrink: 0;
  transition: all 0.3s ease;
  touch-action: none;
  
  &.dragging {
    opacity: 0.8;
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.2);
  }
  
  image {
    width: 100%;
    height: 100%;
    border-radius: 12rpx;
  }
  
  .delete-btn {
    position: absolute;
    top: -10rpx;
    right: -10rpx;
    width: 40rpx;
    height: 40rpx;
    background: rgba(0,0,0,0.5);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}

.upload-btn {
  width: 200rpx;
  height: 200rpx;
  border: 2rpx dashed #ddd;
  border-radius: 12rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 60rpx;
  color: #999;
  flex-shrink: 0;
}

.title, .content {
  width: 90%;
  font-size: 30rpx;
  margin: 10rpx 0;
  border: none;
  border-bottom: 1rpx solid #ccc;
}

.tags-section {
  width: 90%;
  margin-top: 200rpx;
  
  .tags-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10rpx;
  }
  
  .tag-item {
    background: #e0f7fa;
    padding: 8rpx 20rpx;
    border-radius: 30rpx;
    font-size: 26rpx;
    color: #00796b;
    display: flex;
    align-items: center;
    
    .delete-tag {
      margin-left: 10rpx;
      color: #999;
    }
  }
  
  .add-tag-btn {
    background: #00796b;
    color: white;
    padding: 8rpx 20rpx;
    border-radius: 30rpx;
    font-size: 26rpx;
    border: none;
    cursor: pointer;
  }
}

.publish {
  margin-top: auto;
  width: 90%;
  height: 70rpx;
  background: linear-gradient(135deg, #1a73e8 0%, #0d47a1 100%);
  color: white;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 40rpx;
  box-shadow: 0 4rpx 12rpx rgba(26, 115, 232, 0.3);
  transition: all 0.3s ease;
  
  &:active {
    transform: scale(0.98);
  }
}
</style>
```

主要更改：

1. **布局调整**：
   - 将话题标签区域放在正文下方 200rpx 处。
   - 去掉正文和话题之间的分割线。

2. **功能实现**：
   - 添加一个“添加话题”按钮，点击后在输入框中添加 `#` 符号，用户输入文字后按回车键添加到标签列表。
   - 标签以蓝色显示，存储在 `selectedTags` 列表中。

3. **样式优化**：
   - 标签和按钮使用一致的颜色和样式，提升视觉一致性。

这样设计可以让用户更方便地添加话题标签，并且界面更加简洁明了。

---



---

