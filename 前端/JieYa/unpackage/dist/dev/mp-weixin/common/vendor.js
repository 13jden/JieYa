"use strict";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
/**
* @vue/shared v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function makeMap(str, expectsLowerCase) {
  const set2 = new Set(str.split(","));
  return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$2 = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$4 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$4.call(val, key);
const isArray$8 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$4 = (val) => typeof val === "function";
const isString$6 = (val) => typeof val === "string";
const isSymbol$2 = (val) => typeof val === "symbol";
const isObject$5 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$5(val) || isFunction$4(val)) && isFunction$4(val.then) && isFunction$4(val.catch);
};
const objectToString$2 = Object.prototype.toString;
const toTypeString = (value) => objectToString$2.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$6(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s2 = str ? `on${capitalize(str)}` : ``;
  return s2;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns$1 = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$8(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$6(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$6(value) || isObject$5(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$6(value)) {
    res = value;
  } else if (isArray$8(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$5(value)) {
    for (const name2 in value) {
      if (value[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
const toDisplayString = (val) => {
  return isString$6(val) ? val : val == null ? "" : isArray$8(val) || isObject$5(val) && (val.toString === objectToString$2 || !isFunction$4(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol$2(val)) {
    return stringifySymbol(val);
  } else if (isObject$5(val) && !isArray$8(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v2, i = "") => {
  var _a2;
  return isSymbol$2(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i})` : v2;
};
const LINEFEED = "\n";
const SLOT_DEFAULT_NAME = "d";
const ON_SHOW = "onShow";
const ON_HIDE = "onHide";
const ON_LAUNCH = "onLaunch";
const ON_ERROR = "onError";
const ON_THEME_CHANGE = "onThemeChange";
const ON_PAGE_NOT_FOUND = "onPageNotFound";
const ON_UNHANDLE_REJECTION = "onUnhandledRejection";
const ON_EXIT = "onExit";
const ON_LOAD = "onLoad";
const ON_READY = "onReady";
const ON_UNLOAD = "onUnload";
const ON_INIT = "onInit";
const ON_SAVE_EXIT_STATE = "onSaveExitState";
const ON_RESIZE = "onResize";
const ON_BACK_PRESS = "onBackPress";
const ON_PAGE_SCROLL = "onPageScroll";
const ON_TAB_ITEM_TAP = "onTabItemTap";
const ON_REACH_BOTTOM = "onReachBottom";
const ON_PULL_DOWN_REFRESH = "onPullDownRefresh";
const ON_SHARE_TIMELINE = "onShareTimeline";
const ON_ADD_TO_FAVORITES = "onAddToFavorites";
const ON_SHARE_APP_MESSAGE = "onShareAppMessage";
const ON_NAVIGATION_BAR_BUTTON_TAP = "onNavigationBarButtonTap";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED = "onNavigationBarSearchInputClicked";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED = "onNavigationBarSearchInputChanged";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED = "onNavigationBarSearchInputConfirmed";
const ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED = "onNavigationBarSearchInputFocusChanged";
const customizeRE = /:/g;
function customizeEvent(str) {
  return camelize(str.replace(customizeRE, "-"));
}
function hasLeadingSlash(str) {
  return str.indexOf("/") === 0;
}
function addLeadingSlash(str) {
  return hasLeadingSlash(str) ? str : "/" + str;
}
const invokeArrayFns = (fns, arg) => {
  let ret;
  for (let i = 0; i < fns.length; i++) {
    ret = fns[i](arg);
  }
  return ret;
};
function once(fn, ctx = null) {
  let res;
  return (...args) => {
    if (fn) {
      res = fn.apply(ctx, args);
      fn = null;
    }
    return res;
  };
}
function getValueByDataPath(obj, path) {
  if (!isString$6(path)) {
    return;
  }
  path = path.replace(/\[(\d+)\]/g, ".$1");
  const parts = path.split(".");
  let key = parts[0];
  if (!obj) {
    obj = {};
  }
  if (parts.length === 1) {
    return obj[key];
  }
  return getValueByDataPath(obj[key], parts.slice(1).join("."));
}
function sortObject(obj) {
  let sortObj = {};
  if (isPlainObject$1(obj)) {
    Object.keys(obj).sort().forEach((key) => {
      const _key = key;
      sortObj[_key] = obj[_key];
    });
  }
  return !Object.keys(sortObj) ? obj : sortObj;
}
const encode$3 = encodeURIComponent;
function stringifyQuery(obj, encodeStr = encode$3) {
  const res = obj ? Object.keys(obj).map((key) => {
    let val = obj[key];
    if (typeof val === void 0 || val === null) {
      val = "";
    } else if (isPlainObject$1(val)) {
      val = JSON.stringify(val);
    }
    return encodeStr(key) + "=" + encodeStr(val);
  }).filter((x2) => x2.length > 0).join("&") : null;
  return res ? `?${res}` : "";
}
const PAGE_HOOKS = [
  ON_INIT,
  ON_LOAD,
  ON_SHOW,
  ON_HIDE,
  ON_UNLOAD,
  ON_BACK_PRESS,
  ON_PAGE_SCROLL,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_SHARE_TIMELINE,
  ON_SHARE_APP_MESSAGE,
  ON_ADD_TO_FAVORITES,
  ON_SAVE_EXIT_STATE,
  ON_NAVIGATION_BAR_BUTTON_TAP,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED
];
function isRootHook(name2) {
  return PAGE_HOOKS.indexOf(name2) > -1;
}
const UniLifecycleHooks = [
  ON_SHOW,
  ON_HIDE,
  ON_LAUNCH,
  ON_ERROR,
  ON_THEME_CHANGE,
  ON_PAGE_NOT_FOUND,
  ON_UNHANDLE_REJECTION,
  ON_EXIT,
  ON_INIT,
  ON_LOAD,
  ON_READY,
  ON_UNLOAD,
  ON_RESIZE,
  ON_BACK_PRESS,
  ON_PAGE_SCROLL,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_SHARE_TIMELINE,
  ON_ADD_TO_FAVORITES,
  ON_SHARE_APP_MESSAGE,
  ON_SAVE_EXIT_STATE,
  ON_NAVIGATION_BAR_BUTTON_TAP,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED
];
const MINI_PROGRAM_PAGE_RUNTIME_HOOKS = /* @__PURE__ */ (() => {
  return {
    onPageScroll: 1,
    onShareAppMessage: 1 << 1,
    onShareTimeline: 1 << 2
  };
})();
function isUniLifecycleHook(name2, value, checkType = true) {
  if (checkType && !isFunction$4(value)) {
    return false;
  }
  if (UniLifecycleHooks.indexOf(name2) > -1) {
    return true;
  } else if (name2.indexOf("on") === 0) {
    return true;
  }
  return false;
}
let vueApp;
const createVueAppHooks = [];
function onCreateVueApp(hook2) {
  if (vueApp) {
    return hook2(vueApp);
  }
  createVueAppHooks.push(hook2);
}
function invokeCreateVueAppHook(app) {
  vueApp = app;
  createVueAppHooks.forEach((hook2) => hook2(app));
}
const invokeCreateErrorHandler = once((app, createErrorHandler2) => {
  if (isFunction$4(app._component.onError)) {
    return createErrorHandler2(app);
  }
});
const E$1 = function() {
};
E$1.prototype = {
  on: function(name2, callback, ctx) {
    var e2 = this.e || (this.e = {});
    (e2[name2] || (e2[name2] = [])).push({
      fn: callback,
      ctx
    });
    return this;
  },
  once: function(name2, callback, ctx) {
    var self2 = this;
    function listener() {
      self2.off(name2, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name2, listener, ctx);
  },
  emit: function(name2) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name2] || []).slice();
    var i = 0;
    var len = evtArr.length;
    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }
    return this;
  },
  off: function(name2, callback) {
    var e2 = this.e || (this.e = {});
    var evts = e2[name2];
    var liveEvents = [];
    if (evts && callback) {
      for (var i = evts.length - 1; i >= 0; i--) {
        if (evts[i].fn === callback || evts[i].fn._ === callback) {
          evts.splice(i, 1);
          break;
        }
      }
      liveEvents = evts;
    }
    liveEvents.length ? e2[name2] = liveEvents : delete e2[name2];
    return this;
  }
};
var E$1$1 = E$1;
const LOCALE_ZH_HANS = "zh-Hans";
const LOCALE_ZH_HANT = "zh-Hant";
const LOCALE_EN = "en";
const LOCALE_FR = "fr";
const LOCALE_ES = "es";
function include(str, parts) {
  return !!parts.find((part) => str.indexOf(part) !== -1);
}
function startsWith(str, parts) {
  return parts.find((part) => str.indexOf(part) === 0);
}
function normalizeLocale(locale, messages) {
  if (!locale) {
    return;
  }
  locale = locale.trim().replace(/_/g, "-");
  if (messages && messages[locale]) {
    return locale;
  }
  locale = locale.toLowerCase();
  if (locale === "chinese") {
    return LOCALE_ZH_HANS;
  }
  if (locale.indexOf("zh") === 0) {
    if (locale.indexOf("-hans") > -1) {
      return LOCALE_ZH_HANS;
    }
    if (locale.indexOf("-hant") > -1) {
      return LOCALE_ZH_HANT;
    }
    if (include(locale, ["-tw", "-hk", "-mo", "-cht"])) {
      return LOCALE_ZH_HANT;
    }
    return LOCALE_ZH_HANS;
  }
  let locales = [LOCALE_EN, LOCALE_FR, LOCALE_ES];
  if (messages && Object.keys(messages).length > 0) {
    locales = Object.keys(messages);
  }
  const lang = startsWith(locale, locales);
  if (lang) {
    return lang;
  }
}
function getBaseSystemInfo() {
  return wx.getSystemInfoSync();
}
function validateProtocolFail(name2, msg) {
  console.warn(`${name2}: ${msg}`);
}
function validateProtocol(name2, data, protocol, onFail) {
  if (!onFail) {
    onFail = validateProtocolFail;
  }
  for (const key in protocol) {
    const errMsg = validateProp$1(key, data[key], protocol[key], !hasOwn(data, key));
    if (isString$6(errMsg)) {
      onFail(name2, errMsg);
    }
  }
}
function validateProtocols(name2, args, protocol, onFail) {
  if (!protocol) {
    return;
  }
  if (!isArray$8(protocol)) {
    return validateProtocol(name2, args[0] || /* @__PURE__ */ Object.create(null), protocol, onFail);
  }
  const len = protocol.length;
  const argsLen = args.length;
  for (let i = 0; i < len; i++) {
    const opts = protocol[i];
    const data = /* @__PURE__ */ Object.create(null);
    if (argsLen > i) {
      data[opts.name] = args[i];
    }
    validateProtocol(name2, data, { [opts.name]: opts }, onFail);
  }
}
function validateProp$1(name2, value, prop, isAbsent) {
  if (!isPlainObject$1(prop)) {
    prop = { type: prop };
  }
  const { type, required, validator: validator2 } = prop;
  if (required && isAbsent) {
    return 'Missing required args: "' + name2 + '"';
  }
  if (value == null && !required) {
    return;
  }
  if (type != null) {
    let isValid = false;
    const types = isArray$8(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType$1(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      return getInvalidTypeMessage$1(name2, value, expectedTypes);
    }
  }
  if (validator2) {
    return validator2(value);
  }
}
const isSimpleType$1 = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol");
function assertType$1(value, type) {
  let valid;
  const expectedType = getType$2(type);
  if (isSimpleType$1(expectedType)) {
    const t2 = typeof value;
    valid = t2 === expectedType.toLowerCase();
    if (!valid && t2 === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$5(value);
  } else if (expectedType === "Array") {
    valid = isArray$8(value);
  } else {
    {
      valid = value instanceof type;
    }
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage$1(name2, value, expectedTypes) {
  let message = `Invalid args: type check failed for args "${name2}". Expected ${expectedTypes.map(capitalize).join(", ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue$1(value, expectedType);
  const receivedValue = styleValue$1(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable$1(expectedType) && !isBoolean$2(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable$1(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function getType$2(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : "";
}
function styleValue$1(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable$1(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean$2(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
function tryCatch(fn) {
  return function() {
    try {
      return fn.apply(fn, arguments);
    } catch (e2) {
      console.error(e2);
    }
  };
}
let invokeCallbackId = 1;
const invokeCallbacks = {};
function addInvokeCallback(id, name2, callback, keepAlive = false) {
  invokeCallbacks[id] = {
    name: name2,
    keepAlive,
    callback
  };
  return id;
}
function invokeCallback(id, res, extras) {
  if (typeof id === "number") {
    const opts = invokeCallbacks[id];
    if (opts) {
      if (!opts.keepAlive) {
        delete invokeCallbacks[id];
      }
      return opts.callback(res, extras);
    }
  }
  return res;
}
const API_SUCCESS = "success";
const API_FAIL = "fail";
const API_COMPLETE = "complete";
function getApiCallbacks(args) {
  const apiCallbacks = {};
  for (const name2 in args) {
    const fn = args[name2];
    if (isFunction$4(fn)) {
      apiCallbacks[name2] = tryCatch(fn);
      delete args[name2];
    }
  }
  return apiCallbacks;
}
function normalizeErrMsg$1(errMsg, name2) {
  if (!errMsg || errMsg.indexOf(":fail") === -1) {
    return name2 + ":ok";
  }
  return name2 + errMsg.substring(errMsg.indexOf(":fail"));
}
function createAsyncApiCallback(name2, args = {}, { beforeAll, beforeSuccess } = {}) {
  if (!isPlainObject$1(args)) {
    args = {};
  }
  const { success, fail, complete } = getApiCallbacks(args);
  const hasSuccess = isFunction$4(success);
  const hasFail = isFunction$4(fail);
  const hasComplete = isFunction$4(complete);
  const callbackId = invokeCallbackId++;
  addInvokeCallback(callbackId, name2, (res) => {
    res = res || {};
    res.errMsg = normalizeErrMsg$1(res.errMsg, name2);
    isFunction$4(beforeAll) && beforeAll(res);
    if (res.errMsg === name2 + ":ok") {
      isFunction$4(beforeSuccess) && beforeSuccess(res, args);
      hasSuccess && success(res);
    } else {
      hasFail && fail(res);
    }
    hasComplete && complete(res);
  });
  return callbackId;
}
const HOOK_SUCCESS = "success";
const HOOK_FAIL = "fail";
const HOOK_COMPLETE = "complete";
const globalInterceptors = {};
const scopedInterceptors = {};
function wrapperHook(hook2, params) {
  return function(data) {
    return hook2(data, params) || data;
  };
}
function queue$2(hooks, data, params) {
  let promise = false;
  for (let i = 0; i < hooks.length; i++) {
    const hook2 = hooks[i];
    if (promise) {
      promise = Promise.resolve(wrapperHook(hook2, params));
    } else {
      const res = hook2(data, params);
      if (isPromise(res)) {
        promise = Promise.resolve(res);
      }
      if (res === false) {
        return {
          then() {
          },
          catch() {
          }
        };
      }
    }
  }
  return promise || {
    then(callback) {
      return callback(data);
    },
    catch() {
    }
  };
}
function wrapperOptions(interceptors2, options = {}) {
  [HOOK_SUCCESS, HOOK_FAIL, HOOK_COMPLETE].forEach((name2) => {
    const hooks = interceptors2[name2];
    if (!isArray$8(hooks)) {
      return;
    }
    const oldCallback = options[name2];
    options[name2] = function callbackInterceptor(res) {
      queue$2(hooks, res, options).then((res2) => {
        return isFunction$4(oldCallback) && oldCallback(res2) || res2;
      });
    };
  });
  return options;
}
function wrapperReturnValue(method, returnValue) {
  const returnValueHooks = [];
  if (isArray$8(globalInterceptors.returnValue)) {
    returnValueHooks.push(...globalInterceptors.returnValue);
  }
  const interceptor = scopedInterceptors[method];
  if (interceptor && isArray$8(interceptor.returnValue)) {
    returnValueHooks.push(...interceptor.returnValue);
  }
  returnValueHooks.forEach((hook2) => {
    returnValue = hook2(returnValue) || returnValue;
  });
  return returnValue;
}
function getApiInterceptorHooks(method) {
  const interceptor = /* @__PURE__ */ Object.create(null);
  Object.keys(globalInterceptors).forEach((hook2) => {
    if (hook2 !== "returnValue") {
      interceptor[hook2] = globalInterceptors[hook2].slice();
    }
  });
  const scopedInterceptor = scopedInterceptors[method];
  if (scopedInterceptor) {
    Object.keys(scopedInterceptor).forEach((hook2) => {
      if (hook2 !== "returnValue") {
        interceptor[hook2] = (interceptor[hook2] || []).concat(scopedInterceptor[hook2]);
      }
    });
  }
  return interceptor;
}
function invokeApi(method, api, options, params) {
  const interceptor = getApiInterceptorHooks(method);
  if (interceptor && Object.keys(interceptor).length) {
    if (isArray$8(interceptor.invoke)) {
      const res = queue$2(interceptor.invoke, options);
      return res.then((options2) => {
        return api(wrapperOptions(getApiInterceptorHooks(method), options2), ...params);
      });
    } else {
      return api(wrapperOptions(interceptor, options), ...params);
    }
  }
  return api(options, ...params);
}
function hasCallback(args) {
  if (isPlainObject$1(args) && [API_SUCCESS, API_FAIL, API_COMPLETE].find((cb) => isFunction$4(args[cb]))) {
    return true;
  }
  return false;
}
function handlePromise(promise) {
  return promise;
}
function promisify$1(name2, fn) {
  return (args = {}, ...rest) => {
    if (hasCallback(args)) {
      return wrapperReturnValue(name2, invokeApi(name2, fn, args, rest));
    }
    return wrapperReturnValue(name2, handlePromise(new Promise((resolve2, reject) => {
      invokeApi(name2, fn, extend$2(args, { success: resolve2, fail: reject }), rest);
    })));
  };
}
function formatApiArgs(args, options) {
  const params = args[0];
  if (!options || !isPlainObject$1(options.formatArgs) && isPlainObject$1(params)) {
    return;
  }
  const formatArgs = options.formatArgs;
  const keys = Object.keys(formatArgs);
  for (let i = 0; i < keys.length; i++) {
    const name2 = keys[i];
    const formatterOrDefaultValue = formatArgs[name2];
    if (isFunction$4(formatterOrDefaultValue)) {
      const errMsg = formatterOrDefaultValue(args[0][name2], params);
      if (isString$6(errMsg)) {
        return errMsg;
      }
    } else {
      if (!hasOwn(params, name2)) {
        params[name2] = formatterOrDefaultValue;
      }
    }
  }
}
function invokeSuccess(id, name2, res) {
  const result = {
    errMsg: name2 + ":ok"
  };
  return invokeCallback(id, extend$2(res || {}, result));
}
function invokeFail(id, name2, errMsg, errRes = {}) {
  const apiErrMsg = name2 + ":fail" + (errMsg ? " " + errMsg : "");
  delete errRes.errCode;
  let res = extend$2({ errMsg: apiErrMsg }, errRes);
  return invokeCallback(id, res);
}
function beforeInvokeApi(name2, args, protocol, options) {
  {
    validateProtocols(name2, args, protocol);
  }
  if (options && options.beforeInvoke) {
    const errMsg2 = options.beforeInvoke(args);
    if (isString$6(errMsg2)) {
      return errMsg2;
    }
  }
  const errMsg = formatApiArgs(args, options);
  if (errMsg) {
    return errMsg;
  }
}
function normalizeErrMsg(errMsg) {
  if (!errMsg || isString$6(errMsg)) {
    return errMsg;
  }
  if (errMsg.stack) {
    console.error(errMsg.message + LINEFEED + errMsg.stack);
    return errMsg.message;
  }
  return errMsg;
}
function wrapperTaskApi(name2, fn, protocol, options) {
  return (args) => {
    const id = createAsyncApiCallback(name2, args, options);
    const errMsg = beforeInvokeApi(name2, [args], protocol, options);
    if (errMsg) {
      return invokeFail(id, name2, errMsg);
    }
    return fn(args, {
      resolve: (res) => invokeSuccess(id, name2, res),
      reject: (errMsg2, errRes) => invokeFail(id, name2, normalizeErrMsg(errMsg2), errRes)
    });
  };
}
function wrapperSyncApi(name2, fn, protocol, options) {
  return (...args) => {
    const errMsg = beforeInvokeApi(name2, args, protocol, options);
    if (errMsg) {
      throw new Error(errMsg);
    }
    return fn.apply(null, args);
  };
}
function wrapperAsyncApi(name2, fn, protocol, options) {
  return wrapperTaskApi(name2, fn, protocol, options);
}
function defineSyncApi(name2, fn, protocol, options) {
  return wrapperSyncApi(name2, fn, protocol, options);
}
function defineAsyncApi(name2, fn, protocol, options) {
  return promisify$1(name2, wrapperAsyncApi(name2, fn, protocol, options));
}
const API_UPX2PX = "upx2px";
const Upx2pxProtocol = [
  {
    name: "upx",
    type: [Number, String],
    required: true
  }
];
const EPS = 1e-4;
const BASE_DEVICE_WIDTH = 750;
let isIOS = false;
let deviceWidth = 0;
let deviceDPR = 0;
function checkDeviceWidth() {
  const { platform: platform2, pixelRatio, windowWidth } = getBaseSystemInfo();
  deviceWidth = windowWidth;
  deviceDPR = pixelRatio;
  isIOS = platform2 === "ios";
}
const upx2px = defineSyncApi(API_UPX2PX, (number, newDeviceWidth) => {
  if (deviceWidth === 0) {
    checkDeviceWidth();
  }
  number = Number(number);
  if (number === 0) {
    return 0;
  }
  let width = newDeviceWidth || deviceWidth;
  let result = number / BASE_DEVICE_WIDTH * width;
  if (result < 0) {
    result = -result;
  }
  result = Math.floor(result + EPS);
  if (result === 0) {
    if (deviceDPR === 1 || !isIOS) {
      result = 1;
    } else {
      result = 0.5;
    }
  }
  return number < 0 ? -result : result;
}, Upx2pxProtocol);
const API_ADD_INTERCEPTOR = "addInterceptor";
const API_REMOVE_INTERCEPTOR = "removeInterceptor";
const AddInterceptorProtocol = [
  {
    name: "method",
    type: [String, Object],
    required: true
  }
];
const RemoveInterceptorProtocol = AddInterceptorProtocol;
function mergeInterceptorHook(interceptors2, interceptor) {
  Object.keys(interceptor).forEach((hook2) => {
    if (isFunction$4(interceptor[hook2])) {
      interceptors2[hook2] = mergeHook(interceptors2[hook2], interceptor[hook2]);
    }
  });
}
function removeInterceptorHook(interceptors2, interceptor) {
  if (!interceptors2 || !interceptor) {
    return;
  }
  Object.keys(interceptor).forEach((name2) => {
    const hooks = interceptors2[name2];
    const hook2 = interceptor[name2];
    if (isArray$8(hooks) && isFunction$4(hook2)) {
      remove(hooks, hook2);
    }
  });
}
function mergeHook(parentVal, childVal) {
  const res = childVal ? parentVal ? parentVal.concat(childVal) : isArray$8(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks) {
  const res = [];
  for (let i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res;
}
const addInterceptor = defineSyncApi(API_ADD_INTERCEPTOR, (method, interceptor) => {
  if (isString$6(method) && isPlainObject$1(interceptor)) {
    mergeInterceptorHook(scopedInterceptors[method] || (scopedInterceptors[method] = {}), interceptor);
  } else if (isPlainObject$1(method)) {
    mergeInterceptorHook(globalInterceptors, method);
  }
}, AddInterceptorProtocol);
const removeInterceptor = defineSyncApi(API_REMOVE_INTERCEPTOR, (method, interceptor) => {
  if (isString$6(method)) {
    if (isPlainObject$1(interceptor)) {
      removeInterceptorHook(scopedInterceptors[method], interceptor);
    } else {
      delete scopedInterceptors[method];
    }
  } else if (isPlainObject$1(method)) {
    removeInterceptorHook(globalInterceptors, method);
  }
}, RemoveInterceptorProtocol);
const interceptors = {};
const API_ON = "$on";
const OnProtocol = [
  {
    name: "event",
    type: String,
    required: true
  },
  {
    name: "callback",
    type: Function,
    required: true
  }
];
const API_ONCE = "$once";
const OnceProtocol = OnProtocol;
const API_OFF = "$off";
const OffProtocol = [
  {
    name: "event",
    type: [String, Array]
  },
  {
    name: "callback",
    type: Function
  }
];
const API_EMIT = "$emit";
const EmitProtocol = [
  {
    name: "event",
    type: String,
    required: true
  }
];
const emitter = new E$1$1();
const $on = defineSyncApi(API_ON, (name2, callback) => {
  emitter.on(name2, callback);
  return () => emitter.off(name2, callback);
}, OnProtocol);
const $once = defineSyncApi(API_ONCE, (name2, callback) => {
  emitter.once(name2, callback);
  return () => emitter.off(name2, callback);
}, OnceProtocol);
const $off = defineSyncApi(API_OFF, (name2, callback) => {
  if (!name2) {
    emitter.e = {};
    return;
  }
  if (!isArray$8(name2))
    name2 = [name2];
  name2.forEach((n2) => emitter.off(n2, callback));
}, OffProtocol);
const $emit = defineSyncApi(API_EMIT, (name2, ...args) => {
  emitter.emit(name2, ...args);
}, EmitProtocol);
let cid;
let cidErrMsg;
let enabled;
function normalizePushMessage(message) {
  try {
    return JSON.parse(message);
  } catch (e2) {
  }
  return message;
}
function invokePushCallback(args) {
  if (args.type === "enabled") {
    enabled = true;
  } else if (args.type === "clientId") {
    cid = args.cid;
    cidErrMsg = args.errMsg;
    invokeGetPushCidCallbacks(cid, args.errMsg);
  } else if (args.type === "pushMsg") {
    const message = {
      type: "receive",
      data: normalizePushMessage(args.message)
    };
    for (let i = 0; i < onPushMessageCallbacks.length; i++) {
      const callback = onPushMessageCallbacks[i];
      callback(message);
      if (message.stopped) {
        break;
      }
    }
  } else if (args.type === "click") {
    onPushMessageCallbacks.forEach((callback) => {
      callback({
        type: "click",
        data: normalizePushMessage(args.message)
      });
    });
  }
}
const getPushCidCallbacks = [];
function invokeGetPushCidCallbacks(cid2, errMsg) {
  getPushCidCallbacks.forEach((callback) => {
    callback(cid2, errMsg);
  });
  getPushCidCallbacks.length = 0;
}
const API_GET_PUSH_CLIENT_ID = "getPushClientId";
const getPushClientId = defineAsyncApi(API_GET_PUSH_CLIENT_ID, (_2, { resolve: resolve2, reject }) => {
  Promise.resolve().then(() => {
    if (typeof enabled === "undefined") {
      enabled = false;
      cid = "";
      cidErrMsg = "uniPush is not enabled";
    }
    getPushCidCallbacks.push((cid2, errMsg) => {
      if (cid2) {
        resolve2({ cid: cid2 });
      } else {
        reject(errMsg);
      }
    });
    if (typeof cid !== "undefined") {
      invokeGetPushCidCallbacks(cid, cidErrMsg);
    }
  });
});
const onPushMessageCallbacks = [];
const onPushMessage = (fn) => {
  if (onPushMessageCallbacks.indexOf(fn) === -1) {
    onPushMessageCallbacks.push(fn);
  }
};
const offPushMessage = (fn) => {
  if (!fn) {
    onPushMessageCallbacks.length = 0;
  } else {
    const index2 = onPushMessageCallbacks.indexOf(fn);
    if (index2 > -1) {
      onPushMessageCallbacks.splice(index2, 1);
    }
  }
};
const SYNC_API_RE = /^\$|getLocale|setLocale|sendNativeEvent|restoreGlobal|requireGlobal|getCurrentSubNVue|getMenuButtonBoundingClientRect|^report|interceptors|Interceptor$|getSubNVueById|requireNativePlugin|upx2px|hideKeyboard|canIUse|^create|Sync$|Manager$|base64ToArrayBuffer|arrayBufferToBase64|getDeviceInfo|getAppBaseInfo|getWindowInfo|getSystemSetting|getAppAuthorizeSetting/;
const CONTEXT_API_RE = /^create|Manager$/;
const CONTEXT_API_RE_EXC = ["createBLEConnection"];
const ASYNC_API = ["createBLEConnection"];
const CALLBACK_API_RE = /^on|^off/;
function isContextApi(name2) {
  return CONTEXT_API_RE.test(name2) && CONTEXT_API_RE_EXC.indexOf(name2) === -1;
}
function isSyncApi(name2) {
  return SYNC_API_RE.test(name2) && ASYNC_API.indexOf(name2) === -1;
}
function isCallbackApi(name2) {
  return CALLBACK_API_RE.test(name2) && name2 !== "onPush";
}
function shouldPromise(name2) {
  if (isContextApi(name2) || isSyncApi(name2) || isCallbackApi(name2)) {
    return false;
  }
  return true;
}
if (!Promise.prototype.finally) {
  Promise.prototype.finally = function(onfinally) {
    const promise = this.constructor;
    return this.then((value) => promise.resolve(onfinally && onfinally()).then(() => value), (reason) => promise.resolve(onfinally && onfinally()).then(() => {
      throw reason;
    }));
  };
}
function promisify(name2, api) {
  if (!shouldPromise(name2)) {
    return api;
  }
  if (!isFunction$4(api)) {
    return api;
  }
  return function promiseApi(options = {}, ...rest) {
    if (isFunction$4(options.success) || isFunction$4(options.fail) || isFunction$4(options.complete)) {
      return wrapperReturnValue(name2, invokeApi(name2, api, options, rest));
    }
    return wrapperReturnValue(name2, handlePromise(new Promise((resolve2, reject) => {
      invokeApi(name2, api, extend$2({}, options, {
        success: resolve2,
        fail: reject
      }), rest);
    })));
  };
}
const CALLBACKS = ["success", "fail", "cancel", "complete"];
function initWrapper(protocols2) {
  function processCallback(methodName, method, returnValue) {
    return function(res) {
      return method(processReturnValue(methodName, res, returnValue));
    };
  }
  function processArgs(methodName, fromArgs, argsOption = {}, returnValue = {}, keepFromArgs = false) {
    if (isPlainObject$1(fromArgs)) {
      const toArgs = keepFromArgs === true ? fromArgs : {};
      if (isFunction$4(argsOption)) {
        argsOption = argsOption(fromArgs, toArgs) || {};
      }
      for (const key in fromArgs) {
        if (hasOwn(argsOption, key)) {
          let keyOption = argsOption[key];
          if (isFunction$4(keyOption)) {
            keyOption = keyOption(fromArgs[key], fromArgs, toArgs);
          }
          if (!keyOption) {
            console.warn(`微信小程序 ${methodName} 暂不支持 ${key}`);
          } else if (isString$6(keyOption)) {
            toArgs[keyOption] = fromArgs[key];
          } else if (isPlainObject$1(keyOption)) {
            toArgs[keyOption.name ? keyOption.name : key] = keyOption.value;
          }
        } else if (CALLBACKS.indexOf(key) !== -1) {
          const callback = fromArgs[key];
          if (isFunction$4(callback)) {
            toArgs[key] = processCallback(methodName, callback, returnValue);
          }
        } else {
          if (!keepFromArgs && !hasOwn(toArgs, key)) {
            toArgs[key] = fromArgs[key];
          }
        }
      }
      return toArgs;
    } else if (isFunction$4(fromArgs)) {
      fromArgs = processCallback(methodName, fromArgs, returnValue);
    }
    return fromArgs;
  }
  function processReturnValue(methodName, res, returnValue, keepReturnValue = false) {
    if (isFunction$4(protocols2.returnValue)) {
      res = protocols2.returnValue(methodName, res);
    }
    return processArgs(methodName, res, returnValue, {}, keepReturnValue);
  }
  return function wrapper(methodName, method) {
    if (!hasOwn(protocols2, methodName)) {
      return method;
    }
    const protocol = protocols2[methodName];
    if (!protocol) {
      return function() {
        console.error(`微信小程序 暂不支持${methodName}`);
      };
    }
    return function(arg1, arg2) {
      let options = protocol;
      if (isFunction$4(protocol)) {
        options = protocol(arg1);
      }
      arg1 = processArgs(methodName, arg1, options.args, options.returnValue);
      const args = [arg1];
      if (typeof arg2 !== "undefined") {
        args.push(arg2);
      }
      const returnValue = wx[options.name || methodName].apply(wx, args);
      if (isSyncApi(methodName)) {
        return processReturnValue(methodName, returnValue, options.returnValue, isContextApi(methodName));
      }
      return returnValue;
    };
  };
}
const getLocale = () => {
  const app = isFunction$4(getApp) && getApp({ allowDefault: true });
  if (app && app.$vm) {
    return app.$vm.$locale;
  }
  return normalizeLocale(wx.getSystemInfoSync().language) || LOCALE_EN;
};
const setLocale = (locale) => {
  const app = isFunction$4(getApp) && getApp();
  if (!app) {
    return false;
  }
  const oldLocale = app.$vm.$locale;
  if (oldLocale !== locale) {
    app.$vm.$locale = locale;
    onLocaleChangeCallbacks.forEach((fn) => fn({ locale }));
    return true;
  }
  return false;
};
const onLocaleChangeCallbacks = [];
const onLocaleChange = (fn) => {
  if (onLocaleChangeCallbacks.indexOf(fn) === -1) {
    onLocaleChangeCallbacks.push(fn);
  }
};
if (typeof global !== "undefined") {
  global.getLocale = getLocale;
}
const UUID_KEY = "__DC_STAT_UUID";
let deviceId;
function useDeviceId(global2 = wx) {
  return function addDeviceId(_2, toRes) {
    deviceId = deviceId || global2.getStorageSync(UUID_KEY);
    if (!deviceId) {
      deviceId = Date.now() + "" + Math.floor(Math.random() * 1e7);
      wx.setStorage({
        key: UUID_KEY,
        data: deviceId
      });
    }
    toRes.deviceId = deviceId;
  };
}
function addSafeAreaInsets(fromRes, toRes) {
  if (fromRes.safeArea) {
    const safeArea = fromRes.safeArea;
    toRes.safeAreaInsets = {
      top: safeArea.top,
      left: safeArea.left,
      right: fromRes.windowWidth - safeArea.right,
      bottom: fromRes.screenHeight - safeArea.bottom
    };
  }
}
function populateParameters(fromRes, toRes) {
  const { brand = "", model = "", system = "", language = "", theme, version: version2, platform: platform2, fontSizeSetting, SDKVersion, pixelRatio, deviceOrientation } = fromRes;
  let osName = "";
  let osVersion = "";
  {
    osName = system.split(" ")[0] || "";
    osVersion = system.split(" ")[1] || "";
  }
  let hostVersion = version2;
  let deviceType = getGetDeviceType(fromRes, model);
  let deviceBrand = getDeviceBrand(brand);
  let _hostName = getHostName(fromRes);
  let _deviceOrientation = deviceOrientation;
  let _devicePixelRatio = pixelRatio;
  let _SDKVersion = SDKVersion;
  const hostLanguage = language.replace(/_/g, "-");
  const parameters = {
    appId: "__UNI__4FAADD8",
    appName: "JieYa",
    appVersion: "1.0.0",
    appVersionCode: "100",
    appLanguage: getAppLanguage(hostLanguage),
    uniCompileVersion: "4.15",
    uniRuntimeVersion: "4.15",
    uniPlatform: "mp-weixin",
    deviceBrand,
    deviceModel: model,
    deviceType,
    devicePixelRatio: _devicePixelRatio,
    deviceOrientation: _deviceOrientation,
    osName: osName.toLocaleLowerCase(),
    osVersion,
    hostTheme: theme,
    hostVersion,
    hostLanguage,
    hostName: _hostName,
    hostSDKVersion: _SDKVersion,
    hostFontSizeSetting: fontSizeSetting,
    windowTop: 0,
    windowBottom: 0,
    // TODO
    osLanguage: void 0,
    osTheme: void 0,
    ua: void 0,
    hostPackageName: void 0,
    browserName: void 0,
    browserVersion: void 0
  };
  extend$2(toRes, parameters);
}
function getGetDeviceType(fromRes, model) {
  let deviceType = fromRes.deviceType || "phone";
  {
    const deviceTypeMaps = {
      ipad: "pad",
      windows: "pc",
      mac: "pc"
    };
    const deviceTypeMapsKeys = Object.keys(deviceTypeMaps);
    const _model = model.toLocaleLowerCase();
    for (let index2 = 0; index2 < deviceTypeMapsKeys.length; index2++) {
      const _m = deviceTypeMapsKeys[index2];
      if (_model.indexOf(_m) !== -1) {
        deviceType = deviceTypeMaps[_m];
        break;
      }
    }
  }
  return deviceType;
}
function getDeviceBrand(brand) {
  let deviceBrand = brand;
  if (deviceBrand) {
    deviceBrand = deviceBrand.toLocaleLowerCase();
  }
  return deviceBrand;
}
function getAppLanguage(defaultLanguage) {
  return getLocale ? getLocale() : defaultLanguage;
}
function getHostName(fromRes) {
  const _platform = "WeChat";
  let _hostName = fromRes.hostName || _platform;
  {
    if (fromRes.environment) {
      _hostName = fromRes.environment;
    } else if (fromRes.host && fromRes.host.env) {
      _hostName = fromRes.host.env;
    }
  }
  return _hostName;
}
const getSystemInfo = {
  returnValue: (fromRes, toRes) => {
    addSafeAreaInsets(fromRes, toRes);
    useDeviceId()(fromRes, toRes);
    populateParameters(fromRes, toRes);
  }
};
const getSystemInfoSync = getSystemInfo;
const redirectTo = {};
const previewImage = {
  args(fromArgs, toArgs) {
    let currentIndex = parseInt(fromArgs.current);
    if (isNaN(currentIndex)) {
      return;
    }
    const urls = fromArgs.urls;
    if (!isArray$8(urls)) {
      return;
    }
    const len = urls.length;
    if (!len) {
      return;
    }
    if (currentIndex < 0) {
      currentIndex = 0;
    } else if (currentIndex >= len) {
      currentIndex = len - 1;
    }
    if (currentIndex > 0) {
      toArgs.current = urls[currentIndex];
      toArgs.urls = urls.filter((item, index2) => index2 < currentIndex ? item !== urls[currentIndex] : true);
    } else {
      toArgs.current = urls[0];
    }
    return {
      indicator: false,
      loop: false
    };
  }
};
const showActionSheet = {
  args(fromArgs, toArgs) {
    toArgs.alertText = fromArgs.title;
  }
};
const getDeviceInfo = {
  returnValue: (fromRes, toRes) => {
    const { brand, model } = fromRes;
    let deviceType = getGetDeviceType(fromRes, model);
    let deviceBrand = getDeviceBrand(brand);
    useDeviceId()(fromRes, toRes);
    toRes = sortObject(extend$2(toRes, {
      deviceType,
      deviceBrand,
      deviceModel: model
    }));
  }
};
const getAppBaseInfo = {
  returnValue: (fromRes, toRes) => {
    const { version: version2, language, SDKVersion, theme } = fromRes;
    let _hostName = getHostName(fromRes);
    let hostLanguage = language.replace(/_/g, "-");
    toRes = sortObject(extend$2(toRes, {
      hostVersion: version2,
      hostLanguage,
      hostName: _hostName,
      hostSDKVersion: SDKVersion,
      hostTheme: theme,
      appId: "__UNI__4FAADD8",
      appName: "JieYa",
      appVersion: "1.0.0",
      appVersionCode: "100",
      appLanguage: getAppLanguage(hostLanguage)
    }));
  }
};
const getWindowInfo = {
  returnValue: (fromRes, toRes) => {
    addSafeAreaInsets(fromRes, toRes);
    toRes = sortObject(extend$2(toRes, {
      windowTop: 0,
      windowBottom: 0
    }));
  }
};
const getAppAuthorizeSetting = {
  returnValue: function(fromRes, toRes) {
    const { locationReducedAccuracy } = fromRes;
    toRes.locationAccuracy = "unsupported";
    if (locationReducedAccuracy === true) {
      toRes.locationAccuracy = "reduced";
    } else if (locationReducedAccuracy === false) {
      toRes.locationAccuracy = "full";
    }
  }
};
const baseApis = {
  $on,
  $off,
  $once,
  $emit,
  upx2px,
  interceptors,
  addInterceptor,
  removeInterceptor,
  onCreateVueApp,
  invokeCreateVueAppHook,
  getLocale,
  setLocale,
  onLocaleChange,
  getPushClientId,
  onPushMessage,
  offPushMessage,
  invokePushCallback
};
function initUni(api, protocols2, platform2 = wx) {
  const wrapper = initWrapper(protocols2);
  const UniProxyHandlers = {
    get(target, key) {
      if (hasOwn(target, key)) {
        return target[key];
      }
      if (hasOwn(api, key)) {
        return promisify(key, api[key]);
      }
      if (hasOwn(baseApis, key)) {
        return promisify(key, baseApis[key]);
      }
      return promisify(key, wrapper(key, platform2[key]));
    }
  };
  return new Proxy({}, UniProxyHandlers);
}
function initGetProvider(providers) {
  return function getProvider2({ service, success, fail, complete }) {
    let res;
    if (providers[service]) {
      res = {
        errMsg: "getProvider:ok",
        service,
        provider: providers[service]
      };
      isFunction$4(success) && success(res);
    } else {
      res = {
        errMsg: "getProvider:fail:服务[" + service + "]不存在"
      };
      isFunction$4(fail) && fail(res);
    }
    isFunction$4(complete) && complete(res);
  };
}
const objectKeys = [
  "qy",
  "env",
  "error",
  "version",
  "lanDebug",
  "cloud",
  "serviceMarket",
  "router",
  "worklet",
  "__webpack_require_UNI_MP_PLUGIN__"
];
const singlePageDisableKey = ["lanDebug", "router", "worklet"];
const launchOption = wx.getLaunchOptionsSync ? wx.getLaunchOptionsSync() : null;
function isWxKey(key) {
  if (launchOption && launchOption.scene === 1154 && singlePageDisableKey.includes(key)) {
    return false;
  }
  return objectKeys.indexOf(key) > -1 || typeof wx[key] === "function";
}
function initWx() {
  const newWx = {};
  for (const key in wx) {
    if (isWxKey(key)) {
      newWx[key] = wx[key];
    }
  }
  if (typeof globalThis !== "undefined" && typeof requireMiniProgram === "undefined") {
    globalThis.wx = newWx;
  }
  return newWx;
}
const mocks$1 = ["__route__", "__wxExparserNodeId__", "__wxWebviewId__"];
const getProvider = initGetProvider({
  oauth: ["weixin"],
  share: ["weixin"],
  payment: ["wxpay"],
  push: ["weixin"]
});
function initComponentMocks(component2) {
  const res = /* @__PURE__ */ Object.create(null);
  mocks$1.forEach((name2) => {
    res[name2] = component2[name2];
  });
  return res;
}
function createSelectorQuery() {
  const query = wx$2.createSelectorQuery();
  const oldIn = query.in;
  query.in = function newIn(component2) {
    return oldIn.call(this, initComponentMocks(component2));
  };
  return query;
}
const wx$2 = initWx();
let baseInfo = wx$2.getAppBaseInfo && wx$2.getAppBaseInfo();
if (!baseInfo) {
  baseInfo = wx$2.getSystemInfoSync();
}
const host = baseInfo ? baseInfo.host : null;
const shareVideoMessage = host && host.env === "SAAASDK" ? wx$2.miniapp.shareVideoMessage : wx$2.shareVideoMessage;
var shims = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createSelectorQuery,
  getProvider,
  shareVideoMessage
});
const compressImage = {
  args(fromArgs, toArgs) {
    if (fromArgs.compressedHeight && !toArgs.compressHeight) {
      toArgs.compressHeight = fromArgs.compressedHeight;
    }
    if (fromArgs.compressedWidth && !toArgs.compressWidth) {
      toArgs.compressWidth = fromArgs.compressedWidth;
    }
  }
};
var protocols = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  compressImage,
  getAppAuthorizeSetting,
  getAppBaseInfo,
  getDeviceInfo,
  getSystemInfo,
  getSystemInfoSync,
  getWindowInfo,
  previewImage,
  redirectTo,
  showActionSheet
});
const wx$1 = initWx();
var index = initUni(shims, protocols, wx$1);
new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$2)
);
function toRaw$1(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw$1(raw) : observed;
}
function isRef$1(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
/**
* @vue/runtime-core v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack$1 = [];
function pushWarningContext$1(vnode) {
  stack$1.push(vnode);
}
function popWarningContext$1() {
  stack$1.pop();
}
function warn$1$1(msg, ...args) {
  const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace$1();
  if (appWarnHandler) {
    callWithErrorHandling$1(
      appWarnHandler,
      instance,
      11,
      [
        msg + args.map((a2) => {
          var _a2, _b;
          return (_b = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b : JSON.stringify(a2);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName$1(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace$1(trace));
    }
    console.warn(...warnArgs);
  }
}
function getComponentTrace$1() {
  let currentVNode = stack$1[stack$1.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last2 = normalizedStack[0];
    if (last2 && last2.vnode === currentVNode) {
      last2.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace$1(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry$1(entry));
  });
  return logs;
}
function formatTraceEntry$1({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName$1(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps$1(vnode.props), close] : [open + close];
}
function formatProps$1(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp$1(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp$1(key, value, raw) {
  if (isString$6(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef$1(value)) {
    value = formatProp$1(key, toRaw$1(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$4(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw$1(value);
    return raw ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
};
function callWithErrorHandling$1(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError$1(err, instance, type);
  }
}
function handleError$1(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = ErrorTypeStrings$1[type];
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling$1(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError$1(err, type, contextVNode, throwInDev);
}
function logError$1(err, type, contextVNode, throwInDev = true) {
  {
    const info = ErrorTypeStrings$1[type];
    if (contextVNode) {
      pushWarningContext$1(contextVNode);
    }
    warn$1$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext$1();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  }
}
let isFlushing$1 = false;
let isFlushPending$1 = false;
const queue$1 = [];
let flushIndex$1 = 0;
const pendingPostFlushCbs$1 = [];
let activePostFlushCbs$1 = null;
let postFlushIndex$1 = 0;
const resolvedPromise$1 = /* @__PURE__ */ Promise.resolve();
const RECURSION_LIMIT$1 = 100;
function findInsertionIndex$1(id) {
  let start = flushIndex$1 + 1;
  let end = queue$1.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue$1[middle];
    const middleJobId = getId$1(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.pre) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob$1(job) {
  if (!queue$1.length || !queue$1.includes(
    job,
    isFlushing$1 && job.allowRecurse ? flushIndex$1 + 1 : flushIndex$1
  )) {
    if (job.id == null) {
      queue$1.push(job);
    } else {
      queue$1.splice(findInsertionIndex$1(job.id), 0, job);
    }
    queueFlush$1();
  }
}
function queueFlush$1() {
  if (!isFlushing$1 && !isFlushPending$1) {
    isFlushPending$1 = true;
    resolvedPromise$1.then(flushJobs$1);
  }
}
function queuePostFlushCb$1(cb) {
  if (!isArray$8(cb)) {
    if (!activePostFlushCbs$1 || !activePostFlushCbs$1.includes(
      cb,
      cb.allowRecurse ? postFlushIndex$1 + 1 : postFlushIndex$1
    )) {
      pendingPostFlushCbs$1.push(cb);
    }
  } else {
    pendingPostFlushCbs$1.push(...cb);
  }
  queueFlush$1();
}
function flushPostFlushCbs$1(seen) {
  if (pendingPostFlushCbs$1.length) {
    const deduped = [...new Set(pendingPostFlushCbs$1)].sort(
      (a2, b2) => getId$1(a2) - getId$1(b2)
    );
    pendingPostFlushCbs$1.length = 0;
    if (activePostFlushCbs$1) {
      activePostFlushCbs$1.push(...deduped);
      return;
    }
    activePostFlushCbs$1 = deduped;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (postFlushIndex$1 = 0; postFlushIndex$1 < activePostFlushCbs$1.length; postFlushIndex$1++) {
      if (checkRecursiveUpdates$1(seen, activePostFlushCbs$1[postFlushIndex$1])) {
        continue;
      }
      activePostFlushCbs$1[postFlushIndex$1]();
    }
    activePostFlushCbs$1 = null;
    postFlushIndex$1 = 0;
  }
}
const getId$1 = (job) => job.id == null ? Infinity : job.id;
const comparator$1 = (a2, b2) => {
  const diff2 = getId$1(a2) - getId$1(b2);
  if (diff2 === 0) {
    if (a2.pre && !b2.pre)
      return -1;
    if (b2.pre && !a2.pre)
      return 1;
  }
  return diff2;
};
function flushJobs$1(seen) {
  isFlushPending$1 = false;
  isFlushing$1 = true;
  {
    seen = seen || /* @__PURE__ */ new Map();
  }
  queue$1.sort(comparator$1);
  const check = (job) => checkRecursiveUpdates$1(seen, job);
  try {
    for (flushIndex$1 = 0; flushIndex$1 < queue$1.length; flushIndex$1++) {
      const job = queue$1[flushIndex$1];
      if (job && job.active !== false) {
        if (check(job)) {
          continue;
        }
        callWithErrorHandling$1(job, null, 14);
      }
    }
  } finally {
    flushIndex$1 = 0;
    queue$1.length = 0;
    flushPostFlushCbs$1(seen);
    isFlushing$1 = false;
    if (queue$1.length || pendingPostFlushCbs$1.length) {
      flushJobs$1(seen);
    }
  }
}
function checkRecursiveUpdates$1(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT$1) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName$1(instance.type);
      handleError$1(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
const hmrDirtyComponents = /* @__PURE__ */ new Set();
{
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map = /* @__PURE__ */ new Map();
function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }
  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component2) {
  return isClassComponent$1(component2) ? component2.__vccOpts : component2;
}
function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    instance.effect.dirty = true;
    instance.update();
  });
}
function reload(id, newComp) {
  const record = map.get(id);
  if (!record)
    return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      instance.parent.effect.dirty = true;
      queueJob$1(instance.parent.update);
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      );
    }
  }
  queuePostFlushCb$1(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(
        normalizeClassComponent(instance.type)
      );
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  extend$2(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e2) {
      console.error(e2);
      console.warn(
        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
      );
    }
  };
}
{
  const g2 = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g2[key]))
      setters = g2[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1)
        setters.forEach((set2) => set2(v2));
      else
        setters[0](v2);
    };
  };
  registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => v2
  );
  registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => v2
  );
}
const classifyRE$1 = /(?:^|[-_])(\w)/g;
const classify$1 = (str) => str.replace(classifyRE$1, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName$1(Component2, includeInferred = true) {
  return isFunction$4(Component2) ? Component2.displayName || Component2.name : Component2.name || includeInferred && Component2.__name;
}
function formatComponentName$1(instance, Component2, isRoot = false) {
  let name2 = getComponentName$1(Component2);
  if (!name2 && Component2.__file) {
    const match = Component2.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name2 = match[1];
    }
  }
  if (!name2 && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component2) {
          return key;
        }
      }
    };
    name2 = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name2 ? classify$1(name2) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent$1(value) {
  return isFunction$4(value) && "__vccOpts" in value;
}
/**
* @dcloudio/uni-mp-vue v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function warn$2(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else {
      warn$2(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l2;
      for (i = 0, l2 = this.effects.length; i < l2; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l2 = this.scopes.length; i < l2; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last2 = this.parent.scopes.pop();
        if (last2 && last2 !== this) {
          this.parent.scopes[this.index] = last2;
          last2.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
let activeEffect;
class ReactiveEffect2 {
  constructor(fn, trigger2, scheduler, scope) {
    this.fn = fn;
    this.trigger = trigger2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this._dirtyLevel = 4;
    this._trackId = 0;
    this._runnings = 0;
    this._shouldSchedule = false;
    this._depsLength = 0;
    recordEffectScope(this, scope);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i = 0; i < this._depsLength; i++) {
        const dep = this.deps[i];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(v2) {
    this._dirtyLevel = v2 ? 4 : 0;
  }
  run() {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }
  stop() {
    var _a2;
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      (_a2 = this.onStop) == null ? void 0 : _a2.call(this);
      this.active = false;
    }
  }
}
function triggerComputed(computed2) {
  return computed2.value;
}
function preCleanupEffect(effect2) {
  effect2._trackId++;
  effect2._depsLength = 0;
}
function postCleanupEffect(effect2) {
  if (effect2.deps.length > effect2._depsLength) {
    for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
      cleanupDepEffect(effect2.deps[i], effect2);
    }
    effect2.deps.length = effect2._depsLength;
  }
}
function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function pauseScheduling() {
  pauseScheduleStack++;
}
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  var _a2;
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
    {
      (_a2 = effect2.onTrack) == null ? void 0 : _a2.call(effect2, extend$2({ effect: effect2 }, debuggerEventExtraInfo));
    }
  }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  var _a2;
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    let tracking;
    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
      effect2._dirtyLevel = dirtyLevel;
    }
    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      {
        (_a2 = effect2.onTrigger) == null ? void 0 : _a2.call(effect2, extend$2({ effect: effect2 }, debuggerEventExtraInfo));
      }
      effect2.trigger();
      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
        effect2._shouldSchedule = false;
        if (effect2.scheduler) {
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
  }
  resetScheduling();
}
const createDep = (cleanup, computed2) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed2;
  return dep;
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
      activeEffect,
      dep,
      {
        target,
        type,
        key
      }
    );
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$8(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol$2(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$8(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$8(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        4,
        {
          target,
          type,
          key,
          newValue,
          oldValue,
          oldTarget
        }
      );
    }
  }
  resetScheduling();
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$2)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l2 = this.length; i < l2; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$3(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler2 {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$8(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$3;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$2(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$5(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler2 extends BaseReactiveHandler2 {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$8(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray$8(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol$2(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$8(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler2 extends BaseReactiveHandler2 {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    {
      warn$2(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    {
      warn$2(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler2();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler2();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler2(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler2(true);
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = isMap(target) ? new Map(target) : new Set(target);
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach2(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn$2(
        `${capitalize(type)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    warn$2(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$5(target)) {
    {
      warn$2(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$5(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$5(value) ? readonly(value) : value;
const COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this.getter = getter;
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect2(
      () => getter(this._value),
      () => triggerRefValue(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
      triggerRefValue(self2, 4);
    }
    trackRefValue(self2);
    if (self2.effect._dirtyLevel >= 2) {
      if (this._warnRecursive) {
        warn$2(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
      }
      triggerRefValue(self2, 2);
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(v2) {
    this.effect.dirty = v2;
  }
  // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$4(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = () => {
      warn$2("Write operation failed: computed value is readonly");
    };
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
function trackRefValue(ref2) {
  var _a2;
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    trackEffect(
      activeEffect,
      (_a2 = ref2.dep) != null ? _a2 : ref2.dep = createDep(
        () => ref2.dep = void 0,
        ref2 instanceof ComputedRefImpl ? ref2 : void 0
      ),
      {
        target: ref2,
        type: "get",
        key: "value"
      }
    );
  }
}
function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
      dep,
      dirtyLevel,
      {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      }
    );
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, 4, newVal);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        msg + args.map((a2) => {
          var _a2, _b;
          return (_b = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b : JSON.stringify(a2);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last2 = normalizedStack[0];
    if (last2 && last2.vnode === currentVNode) {
      last2.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$6(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$4(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$4(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = ErrorTypeStrings[type] || type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    const info = ErrorTypeStrings[type] || type;
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      console.error(err);
    } else {
      console.error(err);
    }
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick$1(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.pre) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function hasQueueJob(job) {
  return queue.indexOf(job) > -1;
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$8(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
  {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      if (checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a2, b2) => getId(a2) - getId(b2)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a2, b2) => {
  const diff2 = getId(a2) - getId(b2);
  if (diff2 === 0) {
    if (a2.pre && !b2.pre)
      return -1;
    if (b2.pre && !a2.pre)
      return 1;
  }
  return diff2;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  {
    seen = seen || /* @__PURE__ */ new Map();
  }
  queue.sort(comparator);
  const check = (job) => checkRecursiveUpdates(seen, job);
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (check(job)) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools) {
    devtools.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook(hook2, target) {
  var _a2, _b;
  devtools = hook2;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a2 = window.navigator) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version2) {
  emit$1("app:init", app, version2, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:added"
  /* COMPONENT_ADDED */
);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:updated"
  /* COMPONENT_UPDATED */
);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed"
  /* COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = (component2) => {
  if (devtools && typeof devtools.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools.cleanupBuffer(component2)) {
    _devtoolsComponentRemoved(component2);
  }
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook2) {
  return (component2) => {
    emit$1(
      hook2,
      component2.appContext.app,
      component2.uid,
      // fixed by xxxxxx
      // 为 0 是 App，无 parent 是 Page 指向 App
      component2.uid === 0 ? void 0 : component2.parent ? component2.parent.uid : 0,
      component2
    );
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:start"
  /* PERFORMANCE_START */
);
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:end"
  /* PERFORMANCE_END */
);
function createDevtoolsPerformanceHook(hook2) {
  return (component2, type, time) => {
    emit$1(hook2, component2.appContext.app, component2.uid, component2, type, time);
  };
}
function devtoolsComponentEmit(component2, event, params) {
  emit$1(
    "component:emit",
    component2.appContext.app,
    component2,
    event,
    params
  );
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn$1(
            `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`
          );
        }
      } else {
        const validator2 = emitsOptions[event];
        if (isFunction$4(validator2)) {
          const isValid = validator2(...rawArgs);
          if (!isValid) {
            warn$1(
              `Invalid event arguments: event validation failed for event "${event}".`
            );
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a2) => isString$6(a2) ? a2.trim() : a2);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  {
    devtoolsComponentEmit(instance, event, args);
  }
  {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
      warn$1(
        `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
          instance,
          instance.type
        )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
          event
        )}" instead of "${event}".`
      );
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$4(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$2(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$5(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$8(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$2(normalized, raw);
  }
  if (isObject$5(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  instance && instance.type.__scopeId || null;
  return prev;
}
const COMPONENTS = "components";
function resolveComponent(name2, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
}
function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component2 = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component2,
        false
      );
      if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize(camelize(name2)))) {
        return Component2;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component2[type], name2) || // global registration
      resolve(instance.appContext[type], name2)
    );
    if (!res && maybeSelfReference) {
      return Component2;
    }
    if (warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name2}${extra}`);
    }
    return res;
  } else {
    warn$1(
      `resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`
    );
  }
}
function resolve(registry, name2) {
  return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize(camelize(name2))]);
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (!isFunction$4(cb)) {
    warn$1(
      `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
    );
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  once: once2,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  if (cb && once2) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      unwatch();
    };
  }
  if (deep !== void 0 && typeof deep === "number") {
    warn$1(
      `watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`
    );
  }
  if (!cb) {
    if (immediate !== void 0) {
      warn$1(
        `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (deep !== void 0) {
      warn$1(
        `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (once2 !== void 0) {
      warn$1(
        `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
  }
  const warnInvalidSource = (s2) => {
    warn$1(
      `Invalid watch source: `,
      s2,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  };
  const instance = currentInstance;
  const reactiveGetter = (source2) => deep === true ? source2 : (
    // for deep: false, only traverse root-level properties
    traverse(source2, deep === false ? 1 : void 0)
  );
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$8(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return reactiveGetter(s2);
      } else if (isFunction$4(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else {
        warnInvalidSource(s2);
      }
    });
  } else if (isFunction$4(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
    warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
      cleanup = effect2.onStop = void 0;
    };
  };
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active || !effect2.dirty) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect$1(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect2(getter, NOOP, scheduler);
  const scope = getCurrentScope();
  const unwatch = () => {
    effect2.stop();
    if (scope) {
      remove(scope.effects, effect2);
    }
  };
  {
    effect2.onTrack = onTrack;
    effect2.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect$1(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$6(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$4(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, depth, currentDepth = 0, seen) {
  if (!isObject$5(value) || value["__v_skip"]) {
    return value;
  }
  if (depth && depth > 0) {
    if (currentDepth >= depth) {
      return value;
    }
    currentDepth++;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, depth, currentDepth, seen);
  } else if (isArray$8(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, currentDepth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, depth, currentDepth, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], depth, currentDepth, seen);
    }
  }
  return value;
}
function validateDirectiveName(name2) {
  if (isBuiltInDirective(name2)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name2);
  }
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$4(rootComponent)) {
      rootComponent = extend$2({}, rootComponent);
    }
    if (rootProps != null && !isObject$5(rootProps)) {
      warn$1(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$2,
      get config() {
        return context.config;
      },
      set config(v2) {
        {
          warn$1(
            `app.config cannot be replaced. Modify individual options instead.`
          );
        }
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2)) {
          warn$1(`Plugin has already been applied to target app.`);
        } else if (plugin2 && isFunction$4(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app, ...options);
        } else if (isFunction$4(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app, ...options);
        } else {
          warn$1(
            `A plugin must either be a function or an object with an "install" function.`
          );
        }
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else {
            warn$1(
              "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
            );
          }
        }
        return app;
      },
      component(name2, component2) {
        {
          validateComponentName(name2, context.config);
        }
        if (!component2) {
          return context.components[name2];
        }
        if (context.components[name2]) {
          warn$1(`Component "${name2}" has already been registered in target app.`);
        }
        context.components[name2] = component2;
        return app;
      },
      directive(name2, directive) {
        {
          validateDirectiveName(name2);
        }
        if (!directive) {
          return context.directives[name2];
        }
        if (context.directives[name2]) {
          warn$1(`Directive "${name2}" has already been registered in target app.`);
        }
        context.directives[name2] = directive;
        return app;
      },
      // fixed by xxxxxx
      mount() {
      },
      // fixed by xxxxxx
      unmount() {
      },
      provide(key, value) {
        if (key in context.provides) {
          warn$1(
            `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
          );
        }
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) {
    {
      warn$1(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
    if (currentInstance.type.mpType === "app") {
      currentInstance.appContext.app.provide(key, value);
    }
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$4(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else {
      warn$1(`injection "${String(key)}" not found.`);
    }
  } else {
    warn$1(`inject() can only be used inside setup() or functional components.`);
  }
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook2, target) {
  registerKeepAliveHook(hook2, "a", target);
}
function onDeactivated(hook2, target) {
  registerKeepAliveHook(hook2, "da", target);
}
function registerKeepAliveHook(hook2, type, target = currentInstance) {
  const wrappedHook = hook2.__wdc || (hook2.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook2();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook2, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook2,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook2, target = currentInstance, prepend = false) {
  if (target) {
    if (isRootHook(type)) {
      target = target.root;
    }
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook2.__weh || (hook2.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook2, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else {
    const apiName = toHandlerKey(
      (ErrorTypeStrings[type] || type.replace(/^on/, "")).replace(/ hook$/, "")
    );
    warn$1(
      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().`
    );
  }
}
const createHook$1 = (lifecycle) => (hook2, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook2(...args), target)
);
const onBeforeMount = createHook$1("bm");
const onMounted = createHook$1("m");
const onBeforeUpdate = createHook$1("bu");
const onUpdated = createHook$1("u");
const onBeforeUnmount = createHook$1("bum");
const onUnmounted = createHook$1("um");
const onServerPrefetch = createHook$1("sp");
const onRenderTriggered = createHook$1(
  "rtg"
);
const onRenderTracked = createHook$1(
  "rtc"
);
function onErrorCaptured(hook2, target = currentInstance) {
  injectHook("ec", hook2, target);
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$2(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    // fixed by xxxxxx vue-i18n 在 dev 模式，访问了 $el，故模拟一个假的
    // $el: i => i.vnode.el,
    $el: (i) => i.__$el || (i.__$el = {}),
    $data: (i) => i.data,
    $props: (i) => shallowReadonly(i.props),
    $attrs: (i) => shallowReadonly(i.attrs),
    $slots: (i) => shallowReadonly(i.slots),
    $refs: (i) => shallowReadonly(i.refs),
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      i.effect.dirty = true;
      queueJob(i.update);
    }),
    // $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy!)),// fixed by xxxxxx
    $watch: (i) => instanceWatch.bind(i)
  })
);
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (key === "__isVue") {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      } else if (key === "$slots") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if (currentRenderingInstance && (!isString$6(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf("__v") !== 0)) {
      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
        warn$1(
          `Property ${JSON.stringify(
            key
          )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
        );
      } else if (instance === currentRenderingInstance) {
        warn$1(
          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
        );
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
      warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      warn$1(
        `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
      );
      return false;
    } else {
      if (key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
{
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1(
      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
    );
    return Reflect.ownKeys(target);
  };
}
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1(
          `setup() return property ${JSON.stringify(
            key
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
function normalizePropsOrEmits(props) {
  return isArray$8(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
function createDuplicateChecker() {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache2[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache2[key]}.`);
    } else {
      cache2[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions$1(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components: components2,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = createDuplicateChecker();
  {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$4(methodHandler)) {
        {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        }
        {
          checkDuplicateProperties("Methods", key);
        }
      } else {
        warn$1(
          `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
        );
      }
    }
  }
  if (dataOptions) {
    if (!isFunction$4(dataOptions)) {
      warn$1(
        `The data option must be a function. Plain object usage is no longer supported.`
      );
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (isPromise(data)) {
      warn$1(
        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
      );
    }
    if (!isObject$5(data)) {
      warn$1(`data() should return an object.`);
    } else {
      instance.data = reactive(data);
      {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$4(opt) ? opt.bind(publicThis, publicThis) : isFunction$4(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (get2 === NOOP) {
        warn$1(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction$4(opt) && isFunction$4(opt.set) ? opt.set.bind(publicThis) : () => {
        warn$1(
          `Write operation failed: computed property "${key}" is readonly.`
        );
      };
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
      {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  {
    if (provideOptions) {
      const provides = isFunction$4(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
  }
  {
    if (created) {
      callHook$1(created, instance, "c");
    }
  }
  function registerLifecycleHook(register, hook2) {
    if (isArray$8(hook2)) {
      hook2.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook2) {
      register(hook2.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$8(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components2)
    instance.components = components2;
  if (directives)
    instance.directives = directives;
  if (instance.ctx.$onApplyOptions) {
    instance.ctx.$onApplyOptions(options, instance, publicThis);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$8(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$5(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
    {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook$1(hook2, instance, type) {
  callWithAsyncErrorHandling(
    isArray$8(hook2) ? hook2.map((h2) => h2.bind(instance.proxy)) : hook2.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$6(raw)) {
    const handler = ctx[raw];
    if (isFunction$4(handler)) {
      watch(getter, handler);
    } else {
      warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction$4(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$5(raw)) {
    if (isArray$8(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction$4(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$4(handler)) {
        watch(getter, handler, raw);
      } else {
        warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else {
    warn$1(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$5(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to2, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions(to2, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
      warn$1(
        `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
      );
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from[key]) : from[key];
    }
  }
  return to2;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray$1,
  created: mergeAsArray$1,
  beforeMount: mergeAsArray$1,
  mounted: mergeAsArray$1,
  beforeUpdate: mergeAsArray$1,
  updated: mergeAsArray$1,
  beforeDestroy: mergeAsArray$1,
  beforeUnmount: mergeAsArray$1,
  destroyed: mergeAsArray$1,
  unmounted: mergeAsArray$1,
  activated: mergeAsArray$1,
  deactivated: mergeAsArray$1,
  errorCaptured: mergeAsArray$1,
  serverPrefetch: mergeAsArray$1,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from) {
  if (!from) {
    return to2;
  }
  if (!to2) {
    return from;
  }
  return function mergedDataFn() {
    return extend$2(
      isFunction$4(to2) ? to2.call(this, this) : to2,
      isFunction$4(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to2, from) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$8(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray$1(to2, from) {
  return to2 ? [...new Set([].concat(to2, from))] : from;
}
function mergeObjectOptions(to2, from) {
  return to2 ? extend$2(/* @__PURE__ */ Object.create(null), to2, from) : from;
}
function mergeEmitsOrPropsOptions(to2, from) {
  if (to2) {
    if (isArray$8(to2) && isArray$8(from)) {
      return [.../* @__PURE__ */ new Set([...to2, ...from])];
    }
    return extend$2(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to2),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to2, from) {
  if (!to2)
    return from;
  if (!from)
    return to2;
  const merged = extend$2(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from) {
    merged[key] = mergeAsArray$1(to2[key], from[key]);
  }
  return merged;
}
function initProps$1(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId)
      return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
  {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$4(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$4(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$2(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$5(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$8(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (!isString$6(raw[i])) {
        warn$1(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (!isObject$5(raw)) {
      warn$1(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$8(opt) || isFunction$4(opt) ? { type: opt } : extend$2({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$5(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  } else {
    warn$1(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType$1(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name2 = ctor.constructor && ctor.constructor.name;
    return name2 || "";
  }
  return "";
}
function isSameType(a2, b2) {
  return getType$1(a2) === getType$1(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$8(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$4(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp(
      key,
      resolvedValues[key],
      opt,
      shallowReadonly(resolvedValues),
      !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key))
    );
  }
}
function validateProp(name2, value, prop, props, isAbsent) {
  const { type, required, validator: validator2, skipCheck } = prop;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name2 + '"');
    return;
  }
  if (value == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid = false;
    const types = isArray$8(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn$1(getInvalidTypeMessage(name2, value, expectedTypes));
      return;
    }
  }
  if (validator2 && !validator2(value, props)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name2 + '".');
  }
}
const isSimpleType = /* @__PURE__ */ makeMap(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function assertType(value, type) {
  let valid;
  const expectedType = getType$1(type);
  if (isSimpleType(expectedType)) {
    const t2 = typeof value;
    valid = t2 === expectedType.toLowerCase();
    if (!valid && t2 === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$5(value);
  } else if (expectedType === "Array") {
    valid = isArray$8(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name2, value, expectedTypes) {
  if (expectedTypes.length === 0) {
    return `Prop type [] for prop "${name2}" won't match anything. Did you mean to use type Array instead?`;
  }
  let message = `Invalid prop: type check failed for prop "${name2}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean$1(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean$1(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  {
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(
      `<${formatComponentName(instance, instance.type)}> ${type}`,
      startTag,
      endTag
    );
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  {
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}
const queuePostRenderEffect$1 = queuePostFlushCb;
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
const InternalObjectKey = `__vInternal`;
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$2({}, props) : props;
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent2, suspense) {
  const type = vnode.type;
  const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent: parent2,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent2 ? parent2.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = createDevRenderContext(instance);
  }
  instance.root = parent2 ? parent2.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  internalSetCurrentInstance = (i) => {
    currentInstance = i;
  };
  setInSSRSetupState = (v2) => {
    isInSSRComponentSetup = v2;
  };
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name2, { isNativeTag }) {
  if (isBuiltInTag(name2) || isNativeTag(name2)) {
    warn$1(
      "Do not use built-in or reserved HTML elements as component id: " + name2
    );
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isSSR && setInSSRSetupState(isSSR);
  const {
    props
    /*, children*/
  } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps$1(instance, props, isStateful, isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component2 = instance.type;
  {
    if (Component2.name) {
      validateComponentName(Component2.name, instance.appContext.config);
    }
    if (Component2.components) {
      const names = Object.keys(Component2.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component2.directives) {
      const names = Object.keys(Component2.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component2.compilerOptions && isRuntimeOnly()) {
      warn$1(
        `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
      );
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component2;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        shallowReadonly(instance.props),
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      {
        warn$1(
          `setup() returned a Promise, but the version of Vue you are using does not support it yet.`
        );
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$4(setupResult)) {
    {
      instance.render = setupResult;
    }
  } else if (isObject$5(setupResult)) {
    if (isVNode(setupResult)) {
      warn$1(
        `setup() should not return VNodes directly - return a render function instead.`
      );
    }
    {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (setupResult !== void 0) {
    warn$1(
      `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
    );
  }
  finishComponentSetup(instance, isSSR);
}
let compile;
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component2 = instance.type;
  if (!instance.render) {
    instance.render = Component2.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions$1(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
  if (!Component2.render && instance.render === NOOP && !isSSR) {
    if (Component2.template) {
      warn$1(
        `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
      );
    } else {
      warn$1(`Component is missing template or render function.`);
    }
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      },
      set() {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
      }
    }
  ));
}
function getSlotsProxy(instance) {
  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
    get(target, key) {
      track(instance, "get", "$slots");
      return target[key];
    }
  }));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    {
      if (instance.exposed) {
        warn$1(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray$8(exposed)) {
            exposedType = "array";
          } else if (isRef(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn$1(
            `expose() should be passed a plain object, received ${exposedType}.`
          );
        }
      }
    }
    instance.exposed = exposed || {};
  };
  {
    return Object.freeze({
      get attrs() {
        return getAttrsProxy(instance);
      },
      get slots() {
        return getSlotsProxy(instance);
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        }
        return instance.proxy[key];
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component2, includeInferred = true) {
  return isFunction$4(Component2) ? Component2.displayName || Component2.name : Component2.name || includeInferred && Component2.__name;
}
function formatComponentName(instance, Component2, isRoot = false) {
  let name2 = getComponentName(Component2);
  if (!name2 && Component2.__file) {
    const match = Component2.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name2 = match[1];
    }
  }
  if (!name2 && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component2) {
          return key;
        }
      }
    };
    name2 = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
}
const computed = (getterOrOptions, debugOptions) => {
  const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  {
    const i = getCurrentInstance();
    if (i && i.appContext.config.warnRecursiveComputed) {
      c2._warnRecursive = true;
    }
  }
  return c2;
};
const version$2 = "3.4.21";
const warn = warn$1;
function unwrapper(target) {
  return unref(target);
}
const ARRAYTYPE = "[object Array]";
const OBJECTTYPE = "[object Object]";
function diff(current, pre) {
  const result = {};
  syncKeys(current, pre);
  _diff(current, pre, "", result);
  return result;
}
function syncKeys(current, pre) {
  current = unwrapper(current);
  if (current === pre)
    return;
  const rootCurrentType = toTypeString(current);
  const rootPreType = toTypeString(pre);
  if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {
    for (let key in pre) {
      const currentValue = current[key];
      if (currentValue === void 0) {
        current[key] = null;
      } else {
        syncKeys(currentValue, pre[key]);
      }
    }
  } else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {
    if (current.length >= pre.length) {
      pre.forEach((item, index2) => {
        syncKeys(current[index2], item);
      });
    }
  }
}
function _diff(current, pre, path, result) {
  current = unwrapper(current);
  if (current === pre)
    return;
  const rootCurrentType = toTypeString(current);
  const rootPreType = toTypeString(pre);
  if (rootCurrentType == OBJECTTYPE) {
    if (rootPreType != OBJECTTYPE || Object.keys(current).length < Object.keys(pre).length) {
      setResult(result, path, current);
    } else {
      for (let key in current) {
        const currentValue = unwrapper(current[key]);
        const preValue = pre[key];
        const currentType = toTypeString(currentValue);
        const preType = toTypeString(preValue);
        if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {
          if (currentValue != preValue) {
            setResult(
              result,
              (path == "" ? "" : path + ".") + key,
              currentValue
            );
          }
        } else if (currentType == ARRAYTYPE) {
          if (preType != ARRAYTYPE) {
            setResult(
              result,
              (path == "" ? "" : path + ".") + key,
              currentValue
            );
          } else {
            if (currentValue.length < preValue.length) {
              setResult(
                result,
                (path == "" ? "" : path + ".") + key,
                currentValue
              );
            } else {
              currentValue.forEach((item, index2) => {
                _diff(
                  item,
                  preValue[index2],
                  (path == "" ? "" : path + ".") + key + "[" + index2 + "]",
                  result
                );
              });
            }
          }
        } else if (currentType == OBJECTTYPE) {
          if (preType != OBJECTTYPE || Object.keys(currentValue).length < Object.keys(preValue).length) {
            setResult(
              result,
              (path == "" ? "" : path + ".") + key,
              currentValue
            );
          } else {
            for (let subKey in currentValue) {
              _diff(
                currentValue[subKey],
                preValue[subKey],
                (path == "" ? "" : path + ".") + key + "." + subKey,
                result
              );
            }
          }
        }
      }
    }
  } else if (rootCurrentType == ARRAYTYPE) {
    if (rootPreType != ARRAYTYPE) {
      setResult(result, path, current);
    } else {
      if (current.length < pre.length) {
        setResult(result, path, current);
      } else {
        current.forEach((item, index2) => {
          _diff(item, pre[index2], path + "[" + index2 + "]", result);
        });
      }
    }
  } else {
    setResult(result, path, current);
  }
}
function setResult(result, k2, v2) {
  result[k2] = v2;
}
function hasComponentEffect(instance) {
  return queue.includes(instance.update);
}
function flushCallbacks(instance) {
  const ctx = instance.ctx;
  const callbacks = ctx.__next_tick_callbacks;
  if (callbacks && callbacks.length) {
    const copies = callbacks.slice(0);
    callbacks.length = 0;
    for (let i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }
}
function nextTick(instance, fn) {
  const ctx = instance.ctx;
  if (!ctx.__next_tick_pending && !hasComponentEffect(instance)) {
    return nextTick$1(fn && fn.bind(instance.proxy));
  }
  let _resolve;
  if (!ctx.__next_tick_callbacks) {
    ctx.__next_tick_callbacks = [];
  }
  ctx.__next_tick_callbacks.push(() => {
    if (fn) {
      callWithErrorHandling(
        fn.bind(instance.proxy),
        instance,
        14
      );
    } else if (_resolve) {
      _resolve(instance.proxy);
    }
  });
  return new Promise((resolve2) => {
    _resolve = resolve2;
  });
}
function clone(src, seen) {
  src = unwrapper(src);
  const type = typeof src;
  if (type === "object" && src !== null) {
    let copy = seen.get(src);
    if (typeof copy !== "undefined") {
      return copy;
    }
    if (isArray$8(src)) {
      const len = src.length;
      copy = new Array(len);
      seen.set(src, copy);
      for (let i = 0; i < len; i++) {
        copy[i] = clone(src[i], seen);
      }
    } else {
      copy = {};
      seen.set(src, copy);
      for (const name2 in src) {
        if (hasOwn(src, name2)) {
          copy[name2] = clone(src[name2], seen);
        }
      }
    }
    return copy;
  }
  if (type !== "symbol") {
    return src;
  }
}
function deepCopy(src) {
  return clone(src, typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map());
}
function getMPInstanceData(instance, keys) {
  const data = instance.data;
  const ret = /* @__PURE__ */ Object.create(null);
  keys.forEach((key) => {
    ret[key] = data[key];
  });
  return ret;
}
function patch(instance, data, oldData) {
  if (!data) {
    return;
  }
  data = deepCopy(data);
  const ctx = instance.ctx;
  const mpType = ctx.mpType;
  if (mpType === "page" || mpType === "component") {
    data.r0 = 1;
    const mpInstance = ctx.$scope;
    const keys = Object.keys(data);
    const diffData = diff(data, oldData || getMPInstanceData(mpInstance, keys));
    if (Object.keys(diffData).length) {
      ctx.__next_tick_pending = true;
      mpInstance.setData(diffData, () => {
        ctx.__next_tick_pending = false;
        flushCallbacks(instance);
      });
      flushPreFlushCbs();
    } else {
      flushCallbacks(instance);
    }
  }
}
function initAppConfig(appConfig) {
  appConfig.globalProperties.$nextTick = function $nextTick(fn) {
    return nextTick(this.$, fn);
  };
}
function onApplyOptions(options, instance, publicThis) {
  instance.appContext.config.globalProperties.$applyOptions(
    options,
    instance,
    publicThis
  );
  const computedOptions = options.computed;
  if (computedOptions) {
    const keys = Object.keys(computedOptions);
    if (keys.length) {
      const ctx = instance.ctx;
      if (!ctx.$computedKeys) {
        ctx.$computedKeys = [];
      }
      ctx.$computedKeys.push(...keys);
    }
  }
  delete instance.ctx.$onApplyOptions;
}
function setRef$1(instance, isUnmount = false) {
  const {
    setupState,
    $templateRefs,
    ctx: { $scope, $mpPlatform }
  } = instance;
  if ($mpPlatform === "mp-alipay") {
    return;
  }
  if (!$templateRefs || !$scope) {
    return;
  }
  if (isUnmount) {
    return $templateRefs.forEach(
      (templateRef) => setTemplateRef(templateRef, null, setupState)
    );
  }
  const check = $mpPlatform === "mp-baidu" || $mpPlatform === "mp-toutiao";
  const doSetByRefs = (refs) => {
    const mpComponents = (
      // 字节小程序 selectAllComponents 可能返回 null
      // https://github.com/dcloudio/uni-app/issues/3954
      ($scope.selectAllComponents(".r") || []).concat(
        $scope.selectAllComponents(".r-i-f") || []
      )
    );
    return refs.filter((templateRef) => {
      const refValue = findComponentPublicInstance(mpComponents, templateRef.i);
      if (check && refValue === null) {
        return true;
      }
      setTemplateRef(templateRef, refValue, setupState);
      return false;
    });
  };
  const doSet = () => {
    const refs = doSetByRefs($templateRefs);
    if (refs.length && instance.proxy && instance.proxy.$scope) {
      instance.proxy.$scope.setData({ r1: 1 }, () => {
        doSetByRefs(refs);
      });
    }
  };
  if ($scope._$setRef) {
    $scope._$setRef(doSet);
  } else {
    nextTick(instance, doSet);
  }
}
function toSkip(value) {
  if (isObject$5(value)) {
    markRaw(value);
  }
  return value;
}
function findComponentPublicInstance(mpComponents, id) {
  const mpInstance = mpComponents.find(
    (com) => com && (com.properties || com.props).uI === id
  );
  if (mpInstance) {
    const vm = mpInstance.$vm;
    if (vm) {
      return getExposeProxy(vm.$) || vm;
    }
    return toSkip(mpInstance);
  }
  return null;
}
function setTemplateRef({ r: r2, f: f2 }, refValue, setupState) {
  if (isFunction$4(r2)) {
    r2(refValue, {});
  } else {
    const _isString = isString$6(r2);
    const _isRef = isRef(r2);
    if (_isString || _isRef) {
      if (f2) {
        if (!_isRef) {
          return;
        }
        if (!isArray$8(r2.value)) {
          r2.value = [];
        }
        const existing = r2.value;
        if (existing.indexOf(refValue) === -1) {
          existing.push(refValue);
          if (!refValue) {
            return;
          }
          onBeforeUnmount(() => remove(existing, refValue), refValue.$);
        }
      } else if (_isString) {
        if (hasOwn(setupState, r2)) {
          setupState[r2] = refValue;
        }
      } else if (isRef(r2)) {
        r2.value = refValue;
      } else {
        warnRef(r2);
      }
    } else {
      warnRef(r2);
    }
  }
}
function warnRef(ref2) {
  warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
}
const queuePostRenderEffect = queuePostFlushCb;
function mountComponent(initialVNode, options) {
  const instance = initialVNode.component = createComponentInstance(initialVNode, options.parentComponent, null);
  {
    instance.ctx.$onApplyOptions = onApplyOptions;
    instance.ctx.$children = [];
  }
  if (options.mpType === "app") {
    instance.render = NOOP;
  }
  if (options.onBeforeSetup) {
    options.onBeforeSetup(instance, options);
  }
  {
    pushWarningContext(initialVNode);
    startMeasure(instance, `mount`);
  }
  {
    startMeasure(instance, `init`);
  }
  setupComponent(instance);
  {
    endMeasure(instance, `init`);
  }
  {
    if (options.parentComponent && instance.proxy) {
      options.parentComponent.ctx.$children.push(getExposeProxy(instance) || instance.proxy);
    }
  }
  setupRenderEffect(instance);
  {
    popWarningContext();
    endMeasure(instance, `mount`);
  }
  return instance.proxy;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
function renderComponentRoot(instance) {
  const {
    type: Component2,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    data,
    setupState,
    ctx,
    uid: uid2,
    appContext: {
      app: {
        config: {
          globalProperties: { pruneComponentPropsCache: pruneComponentPropsCache2 }
        }
      }
    },
    inheritAttrs
  } = instance;
  instance.$templateRefs = [];
  instance.$ei = 0;
  pruneComponentPropsCache2(uid2);
  instance.__counter = instance.__counter === 0 ? 1 : 0;
  let result;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      fallthroughAttrs(inheritAttrs, props, propsOptions, attrs);
      const proxyToUse = withProxy || proxy;
      result = render.call(
        proxyToUse,
        proxyToUse,
        renderCache,
        props,
        setupState,
        data,
        ctx
      );
    } else {
      fallthroughAttrs(
        inheritAttrs,
        props,
        propsOptions,
        Component2.props ? attrs : getFunctionalFallthrough(attrs)
      );
      const render2 = Component2;
      result = render2.length > 1 ? render2(props, { attrs, slots, emit: emit2 }) : render2(
        props,
        null
        /* we know it doesn't need it */
      );
    }
  } catch (err) {
    handleError(err, instance, 1);
    result = false;
  }
  setRef$1(instance);
  setCurrentRenderingInstance(prev);
  return result;
}
function fallthroughAttrs(inheritAttrs, props, propsOptions, fallthroughAttrs2) {
  if (props && fallthroughAttrs2 && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs2).filter(
      (key) => key !== "class" && key !== "style"
    );
    if (!keys.length) {
      return;
    }
    if (propsOptions && keys.some(isModelListener)) {
      keys.forEach((key) => {
        if (!isModelListener(key) || !(key.slice(9) in propsOptions)) {
          props[key] = fallthroughAttrs2[key];
        }
      });
    } else {
      keys.forEach((key) => props[key] = fallthroughAttrs2[key]);
    }
  }
}
const updateComponentPreRender = (instance) => {
  pauseTracking();
  flushPreFlushCbs();
  resetTracking();
};
function componentUpdateScopedSlotsFn() {
  const scopedSlotsData = this.$scopedSlotsData;
  if (!scopedSlotsData || scopedSlotsData.length === 0) {
    return;
  }
  const mpInstance = this.ctx.$scope;
  const oldData = mpInstance.data;
  const diffData = /* @__PURE__ */ Object.create(null);
  scopedSlotsData.forEach(({ path, index: index2, data }) => {
    const oldScopedSlotData = getValueByDataPath(oldData, path);
    const diffPath = isString$6(index2) ? `${path}.${index2}` : `${path}[${index2}]`;
    if (typeof oldScopedSlotData === "undefined" || typeof oldScopedSlotData[index2] === "undefined") {
      diffData[diffPath] = data;
    } else {
      const diffScopedSlotData = diff(
        data,
        oldScopedSlotData[index2]
      );
      Object.keys(diffScopedSlotData).forEach((name2) => {
        diffData[diffPath + "." + name2] = diffScopedSlotData[name2];
      });
    }
  });
  scopedSlotsData.length = 0;
  if (Object.keys(diffData).length) {
    mpInstance.setData(diffData);
  }
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function setupRenderEffect(instance) {
  const updateScopedSlots = componentUpdateScopedSlotsFn.bind(
    instance
  );
  instance.$updateScopedSlots = () => nextTick$1(() => queueJob(updateScopedSlots));
  const componentUpdateFn = () => {
    if (!instance.isMounted) {
      onBeforeUnmount(() => {
        setRef$1(instance, true);
      }, instance);
      {
        startMeasure(instance, `patch`);
      }
      patch(instance, renderComponentRoot(instance));
      {
        endMeasure(instance, `patch`);
      }
      {
        devtoolsComponentAdded(instance);
      }
    } else {
      const { next, bu, u: u2 } = instance;
      {
        pushWarningContext(next || instance.vnode);
      }
      toggleRecurse(instance, false);
      updateComponentPreRender();
      if (bu) {
        invokeArrayFns$1(bu);
      }
      toggleRecurse(instance, true);
      {
        startMeasure(instance, `patch`);
      }
      patch(instance, renderComponentRoot(instance));
      {
        endMeasure(instance, `patch`);
      }
      if (u2) {
        queuePostRenderEffect(u2);
      }
      {
        devtoolsComponentUpdated(instance);
      }
      {
        popWarningContext();
      }
    }
  };
  const effect2 = instance.effect = new ReactiveEffect2(
    componentUpdateFn,
    NOOP,
    () => queueJob(update),
    instance.scope
    // track it in component's effect scope
  );
  const update = instance.update = () => {
    if (effect2.dirty) {
      effect2.run();
    }
  };
  update.id = instance.uid;
  toggleRecurse(instance, true);
  {
    effect2.onTrack = instance.rtc ? (e2) => invokeArrayFns$1(instance.rtc, e2) : void 0;
    effect2.onTrigger = instance.rtg ? (e2) => invokeArrayFns$1(instance.rtg, e2) : void 0;
    update.ownerInstance = instance;
  }
  update();
}
function unmountComponent(instance) {
  const { bum, scope, update, um } = instance;
  if (bum) {
    invokeArrayFns$1(bum);
  }
  scope.stop();
  if (update) {
    update.active = false;
  }
  if (um) {
    queuePostRenderEffect(um);
  }
  queuePostRenderEffect(() => {
    instance.isUnmounted = true;
  });
  {
    devtoolsComponentRemoved(instance);
  }
}
const oldCreateApp = createAppAPI();
function getTarget() {
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof my !== "undefined") {
    return my;
  }
}
function createVueApp(rootComponent, rootProps = null) {
  const target = getTarget();
  target.__VUE__ = true;
  {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const app = oldCreateApp(rootComponent, rootProps);
  const appContext = app._context;
  initAppConfig(appContext.config);
  const createVNode2 = (initialVNode) => {
    initialVNode.appContext = appContext;
    initialVNode.shapeFlag = 6;
    return initialVNode;
  };
  const createComponent2 = function createComponent22(initialVNode, options) {
    return mountComponent(createVNode2(initialVNode), options);
  };
  const destroyComponent = function destroyComponent2(component2) {
    return component2 && unmountComponent(component2.$);
  };
  app.mount = function mount() {
    rootComponent.render = NOOP;
    const instance = mountComponent(
      createVNode2({ type: rootComponent }),
      {
        mpType: "app",
        mpInstance: null,
        parentComponent: null,
        slots: [],
        props: null
      }
    );
    app._instance = instance.$;
    {
      devtoolsInitApp(app, version$2);
    }
    instance.$app = app;
    instance.$createComponent = createComponent2;
    instance.$destroyComponent = destroyComponent;
    appContext.$appInstance = instance;
    return instance;
  };
  app.unmount = function unmount() {
    warn(`Cannot unmount an app.`);
  };
  return app;
}
function injectLifecycleHook(name2, hook2, publicThis, instance) {
  if (isFunction$4(hook2)) {
    injectHook(name2, hook2.bind(publicThis), instance);
  }
}
function initHooks$1(options, instance, publicThis) {
  const mpType = options.mpType || publicThis.$mpType;
  if (!mpType || mpType === "component") {
    return;
  }
  Object.keys(options).forEach((name2) => {
    if (isUniLifecycleHook(name2, options[name2], false)) {
      const hooks = options[name2];
      if (isArray$8(hooks)) {
        hooks.forEach((hook2) => injectLifecycleHook(name2, hook2, publicThis, instance));
      } else {
        injectLifecycleHook(name2, hooks, publicThis, instance);
      }
    }
  });
}
function applyOptions$2(options, instance, publicThis) {
  initHooks$1(options, instance, publicThis);
}
function set$2(target, key, val) {
  return target[key] = val;
}
function $callMethod(method, ...args) {
  const fn = this[method];
  if (fn) {
    return fn(...args);
  }
  console.error(`method ${method} not found`);
  return null;
}
function createErrorHandler(app) {
  return function errorHandler(err, instance, _info) {
    if (!instance) {
      throw err;
    }
    const appInstance = app._instance;
    if (!appInstance || !appInstance.proxy) {
      throw err;
    }
    {
      appInstance.proxy.$callHook(ON_ERROR, err);
    }
  };
}
function mergeAsArray(to2, from) {
  return to2 ? [...new Set([].concat(to2, from))] : from;
}
function initOptionMergeStrategies(optionMergeStrategies) {
  UniLifecycleHooks.forEach((name2) => {
    optionMergeStrategies[name2] = mergeAsArray;
  });
}
let realAtob;
const b64$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64re = /^(?:[A-Za-z\d+/]{4})*?(?:[A-Za-z\d+/]{2}(?:==)?|[A-Za-z\d+/]{3}=?)?$/;
if (typeof atob !== "function") {
  realAtob = function(str) {
    str = String(str).replace(/[\t\n\f\r ]+/g, "");
    if (!b64re.test(str)) {
      throw new Error("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");
    }
    str += "==".slice(2 - (str.length & 3));
    var bitmap;
    var result = "";
    var r1;
    var r2;
    var i = 0;
    for (; i < str.length; ) {
      bitmap = b64$1.indexOf(str.charAt(i++)) << 18 | b64$1.indexOf(str.charAt(i++)) << 12 | (r1 = b64$1.indexOf(str.charAt(i++))) << 6 | (r2 = b64$1.indexOf(str.charAt(i++)));
      result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
    }
    return result;
  };
} else {
  realAtob = atob;
}
function b64DecodeUnicode(str) {
  return decodeURIComponent(realAtob(str).split("").map(function(c2) {
    return "%" + ("00" + c2.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
}
function getCurrentUserInfo() {
  const token = index.getStorageSync("uni_id_token") || "";
  const tokenArr = token.split(".");
  if (!token || tokenArr.length !== 3) {
    return {
      uid: null,
      role: [],
      permission: [],
      tokenExpired: 0
    };
  }
  let userInfo;
  try {
    userInfo = JSON.parse(b64DecodeUnicode(tokenArr[1]));
  } catch (error) {
    throw new Error("获取当前用户信息出错，详细错误信息为：" + error.message);
  }
  userInfo.tokenExpired = userInfo.exp * 1e3;
  delete userInfo.exp;
  delete userInfo.iat;
  return userInfo;
}
function uniIdMixin(globalProperties) {
  globalProperties.uniIDHasRole = function(roleId) {
    const { role } = getCurrentUserInfo();
    return role.indexOf(roleId) > -1;
  };
  globalProperties.uniIDHasPermission = function(permissionId) {
    const { permission } = getCurrentUserInfo();
    return this.uniIDHasRole("admin") || permission.indexOf(permissionId) > -1;
  };
  globalProperties.uniIDTokenValid = function() {
    const { tokenExpired } = getCurrentUserInfo();
    return tokenExpired > Date.now();
  };
}
function initApp(app) {
  const appConfig = app._context.config;
  appConfig.errorHandler = invokeCreateErrorHandler(app, createErrorHandler);
  initOptionMergeStrategies(appConfig.optionMergeStrategies);
  const globalProperties = appConfig.globalProperties;
  {
    uniIdMixin(globalProperties);
  }
  {
    globalProperties.$set = set$2;
    globalProperties.$applyOptions = applyOptions$2;
    globalProperties.$callMethod = $callMethod;
  }
  {
    index.invokeCreateVueAppHook(app);
  }
}
const propsCaches = /* @__PURE__ */ Object.create(null);
function renderProps(props) {
  const { uid: uid2, __counter } = getCurrentInstance();
  const propsId = (propsCaches[uid2] || (propsCaches[uid2] = [])).push(guardReactiveProps(props)) - 1;
  return uid2 + "," + propsId + "," + __counter;
}
function pruneComponentPropsCache(uid2) {
  delete propsCaches[uid2];
}
function findComponentPropsData(up) {
  if (!up) {
    return;
  }
  const [uid2, propsId] = up.split(",");
  if (!propsCaches[uid2]) {
    return;
  }
  return propsCaches[uid2][parseInt(propsId)];
}
var plugin = {
  install(app) {
    initApp(app);
    app.config.globalProperties.pruneComponentPropsCache = pruneComponentPropsCache;
    const oldMount = app.mount;
    app.mount = function mount(rootContainer) {
      const instance = oldMount.call(app, rootContainer);
      const createApp2 = getCreateApp();
      if (createApp2) {
        createApp2(instance);
      } else {
        if (typeof createMiniProgramApp !== "undefined") {
          createMiniProgramApp(instance);
        }
      }
      return instance;
    };
  }
};
function getCreateApp() {
  const method = "createApp";
  if (typeof global !== "undefined" && typeof global[method] !== "undefined") {
    return global[method];
  } else if (typeof my !== "undefined") {
    return my[method];
  }
}
function vOn(value, key) {
  const instance = getCurrentInstance();
  const ctx = instance.ctx;
  const extraKey = typeof key !== "undefined" && (ctx.$mpPlatform === "mp-weixin" || ctx.$mpPlatform === "mp-qq" || ctx.$mpPlatform === "mp-xhs") && (isString$6(key) || typeof key === "number") ? "_" + key : "";
  const name2 = "e" + instance.$ei++ + extraKey;
  const mpInstance = ctx.$scope;
  if (!value) {
    delete mpInstance[name2];
    return name2;
  }
  const existingInvoker = mpInstance[name2];
  if (existingInvoker) {
    existingInvoker.value = value;
  } else {
    mpInstance[name2] = createInvoker(value, instance);
  }
  return name2;
}
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    patchMPEvent(e2);
    let args = [e2];
    if (e2.detail && e2.detail.__args__) {
      args = e2.detail.__args__;
    }
    const eventValue = invoker.value;
    const invoke = () => callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, eventValue), instance, 5, args);
    const eventTarget = e2.target;
    const eventSync = eventTarget ? eventTarget.dataset ? String(eventTarget.dataset.eventsync) === "true" : false : false;
    if (bubbles.includes(e2.type) && !eventSync) {
      setTimeout(invoke);
    } else {
      const res = invoke();
      if (e2.type === "input" && (isArray$8(res) || isPromise(res))) {
        return;
      }
      return res;
    }
  };
  invoker.value = initialValue;
  return invoker;
}
const bubbles = [
  // touch事件暂不做延迟，否则在 Android 上会影响性能，比如一些拖拽跟手手势等
  // 'touchstart',
  // 'touchmove',
  // 'touchcancel',
  // 'touchend',
  "tap",
  "longpress",
  "longtap",
  "transitionend",
  "animationstart",
  "animationiteration",
  "animationend",
  "touchforcechange"
];
function patchMPEvent(event) {
  if (event.type && event.target) {
    event.preventDefault = NOOP;
    event.stopPropagation = NOOP;
    event.stopImmediatePropagation = NOOP;
    if (!hasOwn(event, "detail")) {
      event.detail = {};
    }
    if (hasOwn(event, "markerId")) {
      event.detail = typeof event.detail === "object" ? event.detail : {};
      event.detail.markerId = event.markerId;
    }
    if (isPlainObject$1(event.detail) && hasOwn(event.detail, "checked") && !hasOwn(event.detail, "value")) {
      event.detail.value = event.detail.checked;
    }
    if (isPlainObject$1(event.detail)) {
      event.target = extend$2({}, event.target, event.detail);
    }
  }
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$8(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop && originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map((fn) => (e3) => !e3._stopped && fn(e3));
  } else {
    return value;
  }
}
function vFor(source, renderItem) {
  let ret;
  if (isArray$8(source) || isString$6(source)) {
    ret = new Array(source.length);
    for (let i = 0, l2 = source.length; i < l2; i++) {
      ret[i] = renderItem(source[i], i, i);
    }
  } else if (typeof source === "number") {
    if (!Number.isInteger(source)) {
      warn(`The v-for range expect an integer value but got ${source}.`);
      return [];
    }
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, i);
    }
  } else if (isObject$5(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, i));
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l2 = keys.length; i < l2; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function stringifyStyle(value) {
  if (isString$6(value)) {
    return value;
  }
  return stringify(normalizeStyle(value));
}
function stringify(styles) {
  let ret = "";
  if (!styles || isString$6(styles)) {
    return ret;
  }
  for (const key in styles) {
    ret += `${key.startsWith(`--`) ? key : hyphenate(key)}:${styles[key]};`;
  }
  return ret;
}
const o$1 = (value, key) => vOn(value, key);
const f$1 = (source, renderItem) => vFor(source, renderItem);
const s$1 = (value) => stringifyStyle(value);
const e$2 = (target, ...sources) => extend$2(target, ...sources);
const n$2 = (value) => normalizeClass(value);
const t$1 = (val) => toDisplayString(val);
const p$1 = (props) => renderProps(props);
function createApp$1(rootComponent, rootProps = null) {
  rootComponent && (rootComponent.mpType = "app");
  return createVueApp(rootComponent, rootProps).use(plugin);
}
const createSSRApp = createApp$1;
const MP_METHODS = [
  "createSelectorQuery",
  "createIntersectionObserver",
  "selectAllComponents",
  "selectComponent"
];
function createEmitFn(oldEmit, ctx) {
  return function emit2(event, ...args) {
    const scope = ctx.$scope;
    if (scope && event) {
      const detail = { __args__: args };
      {
        scope.triggerEvent(event, detail);
      }
    }
    return oldEmit.apply(this, [event, ...args]);
  };
}
function initBaseInstance(instance, options) {
  const ctx = instance.ctx;
  ctx.mpType = options.mpType;
  ctx.$mpType = options.mpType;
  ctx.$mpPlatform = "mp-weixin";
  ctx.$scope = options.mpInstance;
  ctx.$mp = {};
  {
    ctx._self = {};
  }
  instance.slots = {};
  if (isArray$8(options.slots) && options.slots.length) {
    options.slots.forEach((name2) => {
      instance.slots[name2] = true;
    });
    if (instance.slots[SLOT_DEFAULT_NAME]) {
      instance.slots.default = true;
    }
  }
  ctx.getOpenerEventChannel = function() {
    {
      return options.mpInstance.getOpenerEventChannel();
    }
  };
  ctx.$hasHook = hasHook;
  ctx.$callHook = callHook;
  instance.emit = createEmitFn(instance.emit, ctx);
}
function initComponentInstance(instance, options) {
  initBaseInstance(instance, options);
  const ctx = instance.ctx;
  MP_METHODS.forEach((method) => {
    ctx[method] = function(...args) {
      const mpInstance = ctx.$scope;
      if (mpInstance && mpInstance[method]) {
        return mpInstance[method].apply(mpInstance, args);
      }
    };
  });
}
function initMocks(instance, mpInstance, mocks2) {
  const ctx = instance.ctx;
  mocks2.forEach((mock) => {
    if (hasOwn(mpInstance, mock)) {
      instance[mock] = ctx[mock] = mpInstance[mock];
    }
  });
}
function hasHook(name2) {
  const hooks = this.$[name2];
  if (hooks && hooks.length) {
    return true;
  }
  return false;
}
function callHook(name2, args) {
  if (name2 === "mounted") {
    callHook.call(this, "bm");
    this.$.isMounted = true;
    name2 = "m";
  }
  const hooks = this.$[name2];
  return hooks && invokeArrayFns(hooks, args);
}
const PAGE_INIT_HOOKS = [
  ON_LOAD,
  ON_SHOW,
  ON_HIDE,
  ON_UNLOAD,
  ON_RESIZE,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_ADD_TO_FAVORITES
  // 'onReady', // lifetimes.ready
  // 'onPageScroll', // 影响性能，开发者手动注册
  // 'onShareTimeline', // 右上角菜单，开发者手动注册
  // 'onShareAppMessage' // 右上角菜单，开发者手动注册
];
function findHooks(vueOptions, hooks = /* @__PURE__ */ new Set()) {
  if (vueOptions) {
    Object.keys(vueOptions).forEach((name2) => {
      if (isUniLifecycleHook(name2, vueOptions[name2])) {
        hooks.add(name2);
      }
    });
    {
      const { extends: extendsOptions, mixins } = vueOptions;
      if (mixins) {
        mixins.forEach((mixin) => findHooks(mixin, hooks));
      }
      if (extendsOptions) {
        findHooks(extendsOptions, hooks);
      }
    }
  }
  return hooks;
}
function initHook(mpOptions, hook2, excludes) {
  if (excludes.indexOf(hook2) === -1 && !hasOwn(mpOptions, hook2)) {
    mpOptions[hook2] = function(args) {
      return this.$vm && this.$vm.$callHook(hook2, args);
    };
  }
}
const EXCLUDE_HOOKS = [ON_READY];
function initHooks(mpOptions, hooks, excludes = EXCLUDE_HOOKS) {
  hooks.forEach((hook2) => initHook(mpOptions, hook2, excludes));
}
function initUnknownHooks(mpOptions, vueOptions, excludes = EXCLUDE_HOOKS) {
  findHooks(vueOptions).forEach((hook2) => initHook(mpOptions, hook2, excludes));
}
function initRuntimeHooks(mpOptions, runtimeHooks) {
  if (!runtimeHooks) {
    return;
  }
  const hooks = Object.keys(MINI_PROGRAM_PAGE_RUNTIME_HOOKS);
  hooks.forEach((hook2) => {
    if (runtimeHooks & MINI_PROGRAM_PAGE_RUNTIME_HOOKS[hook2]) {
      initHook(mpOptions, hook2, []);
    }
  });
}
const findMixinRuntimeHooks = /* @__PURE__ */ once(() => {
  const runtimeHooks = [];
  const app = isFunction$4(getApp) && getApp({ allowDefault: true });
  if (app && app.$vm && app.$vm.$) {
    const mixins = app.$vm.$.appContext.mixins;
    if (isArray$8(mixins)) {
      const hooks = Object.keys(MINI_PROGRAM_PAGE_RUNTIME_HOOKS);
      mixins.forEach((mixin) => {
        hooks.forEach((hook2) => {
          if (hasOwn(mixin, hook2) && !runtimeHooks.includes(hook2)) {
            runtimeHooks.push(hook2);
          }
        });
      });
    }
  }
  return runtimeHooks;
});
function initMixinRuntimeHooks(mpOptions) {
  initHooks(mpOptions, findMixinRuntimeHooks());
}
const HOOKS = [
  ON_SHOW,
  ON_HIDE,
  ON_ERROR,
  ON_THEME_CHANGE,
  ON_PAGE_NOT_FOUND,
  ON_UNHANDLE_REJECTION
];
function parseApp(instance, parseAppOptions) {
  const internalInstance = instance.$;
  const appOptions = {
    globalData: instance.$options && instance.$options.globalData || {},
    $vm: instance,
    // mp-alipay 组件 data 初始化比 onLaunch 早，提前挂载
    onLaunch(options) {
      this.$vm = instance;
      const ctx = internalInstance.ctx;
      if (this.$vm && ctx.$scope) {
        return;
      }
      initBaseInstance(internalInstance, {
        mpType: "app",
        mpInstance: this,
        slots: []
      });
      ctx.globalData = this.globalData;
      instance.$callHook(ON_LAUNCH, options);
    }
  };
  const { onError } = internalInstance;
  if (onError) {
    internalInstance.appContext.config.errorHandler = (err) => {
      instance.$callHook(ON_ERROR, err);
    };
  }
  initLocale(instance);
  const vueOptions = instance.$.type;
  initHooks(appOptions, HOOKS);
  initUnknownHooks(appOptions, vueOptions);
  {
    const methods = vueOptions.methods;
    methods && extend$2(appOptions, methods);
  }
  if (parseAppOptions) {
    parseAppOptions.parse(appOptions);
  }
  return appOptions;
}
function initCreateApp(parseAppOptions) {
  return function createApp2(vm) {
    return App(parseApp(vm, parseAppOptions));
  };
}
function initCreateSubpackageApp(parseAppOptions) {
  return function createApp2(vm) {
    const appOptions = parseApp(vm, parseAppOptions);
    const app = isFunction$4(getApp) && getApp({
      allowDefault: true
    });
    if (!app)
      return;
    vm.$.ctx.$scope = app;
    const globalData = app.globalData;
    if (globalData) {
      Object.keys(appOptions.globalData).forEach((name2) => {
        if (!hasOwn(globalData, name2)) {
          globalData[name2] = appOptions.globalData[name2];
        }
      });
    }
    Object.keys(appOptions).forEach((name2) => {
      if (!hasOwn(app, name2)) {
        app[name2] = appOptions[name2];
      }
    });
    initAppLifecycle(appOptions, vm);
  };
}
function initAppLifecycle(appOptions, vm) {
  if (isFunction$4(appOptions.onLaunch)) {
    const args = wx.getLaunchOptionsSync && wx.getLaunchOptionsSync();
    appOptions.onLaunch(args);
  }
  if (isFunction$4(appOptions.onShow) && wx.onAppShow) {
    wx.onAppShow((args) => {
      vm.$callHook("onShow", args);
    });
  }
  if (isFunction$4(appOptions.onHide) && wx.onAppHide) {
    wx.onAppHide((args) => {
      vm.$callHook("onHide", args);
    });
  }
}
function initLocale(appVm) {
  const locale = ref(normalizeLocale(wx.getSystemInfoSync().language) || LOCALE_EN);
  Object.defineProperty(appVm, "$locale", {
    get() {
      return locale.value;
    },
    set(v2) {
      locale.value = v2;
    }
  });
}
function initVueIds(vueIds, mpInstance) {
  if (!vueIds) {
    return;
  }
  const ids = vueIds.split(",");
  const len = ids.length;
  if (len === 1) {
    mpInstance._$vueId = ids[0];
  } else if (len === 2) {
    mpInstance._$vueId = ids[0];
    mpInstance._$vuePid = ids[1];
  }
}
const EXTRAS = ["externalClasses"];
function initExtraOptions(miniProgramComponentOptions, vueOptions) {
  EXTRAS.forEach((name2) => {
    if (hasOwn(vueOptions, name2)) {
      miniProgramComponentOptions[name2] = vueOptions[name2];
    }
  });
}
const WORKLET_RE = /_(.*)_worklet_factory_/;
function initWorkletMethods(mpMethods, vueMethods) {
  if (vueMethods) {
    Object.keys(vueMethods).forEach((name2) => {
      const matches = name2.match(WORKLET_RE);
      if (matches) {
        const workletName = matches[1];
        mpMethods[name2] = vueMethods[name2];
        mpMethods[workletName] = vueMethods[workletName];
      }
    });
  }
}
function initWxsCallMethods(methods, wxsCallMethods) {
  if (!isArray$8(wxsCallMethods)) {
    return;
  }
  wxsCallMethods.forEach((callMethod) => {
    methods[callMethod] = function(args) {
      return this.$vm[callMethod](args);
    };
  });
}
function selectAllComponents(mpInstance, selector, $refs) {
  const components2 = mpInstance.selectAllComponents(selector);
  components2.forEach((component2) => {
    const ref2 = component2.properties.uR;
    $refs[ref2] = component2.$vm || component2;
  });
}
function initRefs(instance, mpInstance) {
  Object.defineProperty(instance, "refs", {
    get() {
      const $refs = {};
      selectAllComponents(mpInstance, ".r", $refs);
      const forComponents = mpInstance.selectAllComponents(".r-i-f");
      forComponents.forEach((component2) => {
        const ref2 = component2.properties.uR;
        if (!ref2) {
          return;
        }
        if (!$refs[ref2]) {
          $refs[ref2] = [];
        }
        $refs[ref2].push(component2.$vm || component2);
      });
      return $refs;
    }
  });
}
function findVmByVueId(instance, vuePid) {
  const $children = instance.$children;
  for (let i = $children.length - 1; i >= 0; i--) {
    const childVm = $children[i];
    if (childVm.$scope._$vueId === vuePid) {
      return childVm;
    }
  }
  let parentVm;
  for (let i = $children.length - 1; i >= 0; i--) {
    parentVm = findVmByVueId($children[i], vuePid);
    if (parentVm) {
      return parentVm;
    }
  }
}
const builtInProps = [
  // 百度小程序,快手小程序自定义组件不支持绑定动态事件，动态dataset，故通过props传递事件信息
  // event-opts
  "eO",
  // 组件 ref
  "uR",
  // 组件 ref-in-for
  "uRIF",
  // 组件 id
  "uI",
  // 组件类型 m: 小程序组件
  "uT",
  // 组件 props
  "uP",
  // 小程序不能直接定义 $slots 的 props，所以通过 vueSlots 转换到 $slots
  "uS"
];
function initDefaultProps(options, isBehavior = false) {
  const properties = {};
  if (!isBehavior) {
    builtInProps.forEach((name2) => {
      properties[name2] = {
        type: null,
        value: ""
      };
    });
    properties.uS = {
      type: null,
      value: [],
      observer: function(newVal) {
        const $slots = /* @__PURE__ */ Object.create(null);
        newVal && newVal.forEach((slotName) => {
          $slots[slotName] = true;
        });
        this.setData({
          $slots
        });
      }
    };
  }
  if (options.behaviors) {
    if (options.behaviors.includes("__GLOBAL__://form-field")) {
      if (!options.properties || !options.properties.name) {
        properties.name = {
          type: null,
          value: ""
        };
      }
      if (!options.properties || !options.properties.value) {
        properties.value = {
          type: null,
          value: ""
        };
      }
    }
  }
  return properties;
}
function initVirtualHostProps(options) {
  const properties = {};
  {
    if (options && options.virtualHost) {
      properties.virtualHostStyle = {
        type: null,
        value: ""
      };
      properties.virtualHostClass = {
        type: null,
        value: ""
      };
    }
  }
  return properties;
}
function initProps(mpComponentOptions) {
  if (!mpComponentOptions.properties) {
    mpComponentOptions.properties = {};
  }
  extend$2(mpComponentOptions.properties, initDefaultProps(mpComponentOptions), initVirtualHostProps(mpComponentOptions.options));
}
const PROP_TYPES = [String, Number, Boolean, Object, Array, null];
function parsePropType(type, defaultValue) {
  if (isArray$8(type) && type.length === 1) {
    return type[0];
  }
  return type;
}
function normalizePropType(type, defaultValue) {
  const res = parsePropType(type);
  return PROP_TYPES.indexOf(res) !== -1 ? res : null;
}
function initPageProps({ properties }, rawProps) {
  if (isArray$8(rawProps)) {
    rawProps.forEach((key) => {
      properties[key] = {
        type: String,
        value: ""
      };
    });
  } else if (isPlainObject$1(rawProps)) {
    Object.keys(rawProps).forEach((key) => {
      const opts = rawProps[key];
      if (isPlainObject$1(opts)) {
        let value = opts.default;
        if (isFunction$4(value)) {
          value = value();
        }
        const type = opts.type;
        opts.type = normalizePropType(type);
        properties[key] = {
          type: opts.type,
          value
        };
      } else {
        properties[key] = {
          type: normalizePropType(opts)
        };
      }
    });
  }
}
function findPropsData(properties, isPage2) {
  return (isPage2 ? findPagePropsData(properties) : findComponentPropsData(properties.uP)) || {};
}
function findPagePropsData(properties) {
  const propsData = {};
  if (isPlainObject$1(properties)) {
    Object.keys(properties).forEach((name2) => {
      if (builtInProps.indexOf(name2) === -1) {
        propsData[name2] = properties[name2];
      }
    });
  }
  return propsData;
}
function initFormField(vm) {
  const vueOptions = vm.$options;
  if (isArray$8(vueOptions.behaviors) && vueOptions.behaviors.includes("uni://form-field")) {
    vm.$watch("modelValue", () => {
      vm.$scope && vm.$scope.setData({
        name: vm.name,
        value: vm.modelValue
      });
    }, {
      immediate: true
    });
  }
}
function initData(_2) {
  return {};
}
function initPropsObserver(componentOptions) {
  const observe = function observe2() {
    const up = this.properties.uP;
    if (!up) {
      return;
    }
    if (this.$vm) {
      updateComponentProps(up, this.$vm.$);
    } else if (this.properties.uT === "m") {
      updateMiniProgramComponentProperties(up, this);
    }
  };
  {
    if (!componentOptions.observers) {
      componentOptions.observers = {};
    }
    componentOptions.observers.uP = observe;
  }
}
function updateMiniProgramComponentProperties(up, mpInstance) {
  const prevProps = mpInstance.properties;
  const nextProps = findComponentPropsData(up) || {};
  if (hasPropsChanged(prevProps, nextProps, false)) {
    mpInstance.setData(nextProps);
  }
}
function updateComponentProps(up, instance) {
  const prevProps = toRaw(instance.props);
  const nextProps = findComponentPropsData(up) || {};
  if (hasPropsChanged(prevProps, nextProps)) {
    updateProps(instance, nextProps, prevProps, false);
    if (hasQueueJob(instance.update)) {
      invalidateJob(instance.update);
    }
    {
      instance.update();
    }
  }
}
function hasPropsChanged(prevProps, nextProps, checkLen = true) {
  const nextKeys = Object.keys(nextProps);
  if (checkLen && nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key]) {
      return true;
    }
  }
  return false;
}
function initBehaviors(vueOptions) {
  const vueBehaviors = vueOptions.behaviors;
  let vueProps = vueOptions.props;
  if (!vueProps) {
    vueOptions.props = vueProps = [];
  }
  const behaviors = [];
  if (isArray$8(vueBehaviors)) {
    vueBehaviors.forEach((behavior) => {
      behaviors.push(behavior.replace("uni://", "__GLOBAL__://"));
      if (behavior === "uni://form-field") {
        if (isArray$8(vueProps)) {
          vueProps.push("name");
          vueProps.push("modelValue");
        } else {
          vueProps.name = {
            type: String,
            default: ""
          };
          vueProps.modelValue = {
            type: [String, Number, Boolean, Array, Object, Date],
            default: ""
          };
        }
      }
    });
  }
  return behaviors;
}
function applyOptions(componentOptions, vueOptions) {
  componentOptions.data = initData();
  componentOptions.behaviors = initBehaviors(vueOptions);
}
function parseComponent(vueOptions, { parse, mocks: mocks2, isPage: isPage2, initRelation: initRelation2, handleLink: handleLink2, initLifetimes: initLifetimes2 }) {
  vueOptions = vueOptions.default || vueOptions;
  const options = {
    multipleSlots: true,
    // styleIsolation: 'apply-shared',
    addGlobalClass: true,
    pureDataPattern: /^uP$/
  };
  if (isArray$8(vueOptions.mixins)) {
    vueOptions.mixins.forEach((item) => {
      if (isObject$5(item.options)) {
        extend$2(options, item.options);
      }
    });
  }
  if (vueOptions.options) {
    extend$2(options, vueOptions.options);
  }
  const mpComponentOptions = {
    options,
    lifetimes: initLifetimes2({ mocks: mocks2, isPage: isPage2, initRelation: initRelation2, vueOptions }),
    pageLifetimes: {
      show() {
        this.$vm && this.$vm.$callHook("onPageShow");
      },
      hide() {
        this.$vm && this.$vm.$callHook("onPageHide");
      },
      resize(size2) {
        this.$vm && this.$vm.$callHook("onPageResize", size2);
      }
    },
    methods: {
      __l: handleLink2
    }
  };
  {
    applyOptions(mpComponentOptions, vueOptions);
  }
  initProps(mpComponentOptions);
  initPropsObserver(mpComponentOptions);
  initExtraOptions(mpComponentOptions, vueOptions);
  initWxsCallMethods(mpComponentOptions.methods, vueOptions.wxsCallMethods);
  {
    initWorkletMethods(mpComponentOptions.methods, vueOptions.methods);
  }
  if (parse) {
    parse(mpComponentOptions, { handleLink: handleLink2 });
  }
  return mpComponentOptions;
}
function initCreateComponent(parseOptions2) {
  return function createComponent2(vueComponentOptions) {
    return Component(parseComponent(vueComponentOptions, parseOptions2));
  };
}
let $createComponentFn;
let $destroyComponentFn;
function getAppVm() {
  return getApp().$vm;
}
function $createComponent(initialVNode, options) {
  if (!$createComponentFn) {
    $createComponentFn = getAppVm().$createComponent;
  }
  const proxy = $createComponentFn(initialVNode, options);
  return getExposeProxy(proxy.$) || proxy;
}
function $destroyComponent(instance) {
  if (!$destroyComponentFn) {
    $destroyComponentFn = getAppVm().$destroyComponent;
  }
  return $destroyComponentFn(instance);
}
function parsePage(vueOptions, parseOptions2) {
  const { parse, mocks: mocks2, isPage: isPage2, initRelation: initRelation2, handleLink: handleLink2, initLifetimes: initLifetimes2 } = parseOptions2;
  const miniProgramPageOptions = parseComponent(vueOptions, {
    mocks: mocks2,
    isPage: isPage2,
    initRelation: initRelation2,
    handleLink: handleLink2,
    initLifetimes: initLifetimes2
  });
  initPageProps(miniProgramPageOptions, (vueOptions.default || vueOptions).props);
  const methods = miniProgramPageOptions.methods;
  methods.onLoad = function(query) {
    this.options = query;
    this.$page = {
      fullPath: addLeadingSlash(this.route + stringifyQuery(query))
    };
    return this.$vm && this.$vm.$callHook(ON_LOAD, query);
  };
  initHooks(methods, PAGE_INIT_HOOKS);
  {
    initUnknownHooks(methods, vueOptions);
  }
  initRuntimeHooks(methods, vueOptions.__runtimeHooks);
  initMixinRuntimeHooks(methods);
  parse && parse(miniProgramPageOptions, { handleLink: handleLink2 });
  return miniProgramPageOptions;
}
function initCreatePage(parseOptions2) {
  return function createPage2(vuePageOptions) {
    return Component(parsePage(vuePageOptions, parseOptions2));
  };
}
function initCreatePluginApp(parseAppOptions) {
  return function createApp2(vm) {
    initAppLifecycle(parseApp(vm, parseAppOptions), vm);
  };
}
const MPPage = Page;
const MPComponent = Component;
function initTriggerEvent(mpInstance) {
  const oldTriggerEvent = mpInstance.triggerEvent;
  const newTriggerEvent = function(event, ...args) {
    return oldTriggerEvent.apply(mpInstance, [customizeEvent(event), ...args]);
  };
  try {
    mpInstance.triggerEvent = newTriggerEvent;
  } catch (error) {
    mpInstance._triggerEvent = newTriggerEvent;
  }
}
function initMiniProgramHook(name2, options, isComponent) {
  const oldHook = options[name2];
  if (!oldHook) {
    options[name2] = function() {
      initTriggerEvent(this);
    };
  } else {
    options[name2] = function(...args) {
      initTriggerEvent(this);
      return oldHook.apply(this, args);
    };
  }
}
Page = function(options) {
  initMiniProgramHook(ON_LOAD, options);
  return MPPage(options);
};
Component = function(options) {
  initMiniProgramHook("created", options);
  const isVueComponent = options.properties && options.properties.uP;
  if (!isVueComponent) {
    initProps(options);
    initPropsObserver(options);
  }
  return MPComponent(options);
};
function initLifetimes({ mocks: mocks2, isPage: isPage2, initRelation: initRelation2, vueOptions }) {
  return {
    attached() {
      let properties = this.properties;
      initVueIds(properties.uI, this);
      const relationOptions = {
        vuePid: this._$vuePid
      };
      initRelation2(this, relationOptions);
      const mpInstance = this;
      const isMiniProgramPage = isPage2(mpInstance);
      let propsData = properties;
      this.$vm = $createComponent({
        type: vueOptions,
        props: findPropsData(propsData, isMiniProgramPage)
      }, {
        mpType: isMiniProgramPage ? "page" : "component",
        mpInstance,
        slots: properties.uS || {},
        // vueSlots
        parentComponent: relationOptions.parent && relationOptions.parent.$,
        onBeforeSetup(instance, options) {
          initRefs(instance, mpInstance);
          initMocks(instance, mpInstance, mocks2);
          initComponentInstance(instance, options);
        }
      });
      if (!isMiniProgramPage) {
        initFormField(this.$vm);
      }
    },
    ready() {
      if (this.$vm) {
        {
          this.$vm.$callHook("mounted");
          this.$vm.$callHook(ON_READY);
        }
      }
    },
    detached() {
      if (this.$vm) {
        pruneComponentPropsCache(this.$vm.$.uid);
        $destroyComponent(this.$vm);
      }
    }
  };
}
const mocks = ["__route__", "__wxExparserNodeId__", "__wxWebviewId__"];
function isPage(mpInstance) {
  return !!mpInstance.route;
}
function initRelation(mpInstance, detail) {
  mpInstance.triggerEvent("__l", detail);
}
function handleLink(event) {
  const detail = event.detail || event.value;
  const vuePid = detail.vuePid;
  let parentVm;
  if (vuePid) {
    parentVm = findVmByVueId(this.$vm, vuePid);
  }
  if (!parentVm) {
    parentVm = this.$vm;
  }
  detail.parent = parentVm;
}
var parseOptions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  handleLink,
  initLifetimes,
  initRelation,
  isPage,
  mocks
});
const createApp = initCreateApp();
const createPage = initCreatePage(parseOptions);
const createComponent = initCreateComponent(parseOptions);
const createPluginApp = initCreatePluginApp();
const createSubpackageApp = initCreateSubpackageApp();
{
  wx.createApp = global.createApp = createApp;
  wx.createPage = createPage;
  wx.createComponent = createComponent;
  wx.createPluginApp = global.createPluginApp = createPluginApp;
  wx.createSubpackageApp = global.createSubpackageApp = createSubpackageApp;
}
function bind$2(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$3 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str = toString$3.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray: isArray$7 } = Array;
const isUndefined$2 = typeOfTest("undefined");
function isBuffer$1(val) {
  return val !== null && !isUndefined$2(val) && val.constructor !== null && !isUndefined$2(val.constructor) && isFunction$3(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer$1 = kindOfTest("ArrayBuffer");
function isArrayBufferView$1(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer$1(val.buffer);
  }
  return result;
}
const isString$5 = typeOfTest("string");
const isFunction$3 = typeOfTest("function");
const isNumber$2 = typeOfTest("number");
const isObject$4 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate$3 = kindOfTest("Date");
const isFile$1 = kindOfTest("File");
const isBlob$1 = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream$1 = (val) => isObject$4(val) && isFunction$3(val.pipe);
const isFormData$4 = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$3(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$3(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams$1 = kindOfTest("URLSearchParams");
const [isReadableStream$1, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim$1 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach$1(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$7(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined$2(context) && context !== _global;
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue2 = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray$7(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach$1(arguments[i], assignValue2);
  }
  return result;
}
const extend$1 = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach$1(b2, (val, key) => {
    if (thisArg && isFunction$3(val)) {
      a2[key] = bind$2(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray$7(thing))
    return thing;
  let i = thing.length;
  if (!isNumber$2(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer2(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty$2 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp$2 = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach$1(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction$3(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction$3(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$7(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$1 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$3(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack2 = new Array(10);
  const visit = (source, i) => {
    if (isObject$4(source)) {
      if (stack2.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack2[i] = source;
        const target = isArray$7(source) ? [] : {};
        forEach$1(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined$2(reducedValue) && (target[key] = reducedValue);
        });
        stack2[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$4(thing) || isFunction$3(thing)) && isFunction$3(thing.then) && isFunction$3(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction$3(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$4 = {
  isArray: isArray$7,
  isArrayBuffer: isArrayBuffer$1,
  isBuffer: isBuffer$1,
  isFormData: isFormData$4,
  isArrayBufferView: isArrayBufferView$1,
  isString: isString$5,
  isNumber: isNumber$2,
  isBoolean,
  isObject: isObject$4,
  isPlainObject,
  isReadableStream: isReadableStream$1,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined: isUndefined$2,
  isDate: isDate$3,
  isFile: isFile$1,
  isBlob: isBlob$1,
  isRegExp: isRegExp$2,
  isFunction: isFunction$3,
  isStream: isStream$1,
  isURLSearchParams: isURLSearchParams$1,
  isTypedArray,
  isFileList,
  forEach: forEach$1,
  merge: merge$1,
  extend: extend$1,
  trim: trim$1,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$2,
  hasOwnProp: hasOwnProperty$2,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError(message, code2, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$4.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$4.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code2, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$4.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code2, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$4.isPlainObject(thing) || utils$4.isArray(thing);
}
function removeBrackets(key) {
  return utils$4.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$4.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$4.toFlatObject(utils$4, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$4.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$4.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$4.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$4.isSpecCompliantForm(formData);
  if (!utils$4.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$4.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$4.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$4.isArrayBuffer(value) || utils$4.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$4.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$4.isArray(value) && isFlatArray(value) || (utils$4.isFileList(value) || utils$4.endsWith(key, "[]")) && (arr = utils$4.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils$4.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack2 = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$4.isUndefined(value))
      return;
    if (stack2.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack2.push(value);
    utils$4.forEach(value, function each(el, key) {
      const result = !(utils$4.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$4.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack2.pop();
  }
  if (!utils$4.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$2(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString(encoder2) {
  const _encode = encoder2 ? function(value) {
    return encoder2.call(this, value, encode$2);
  } : encode$2;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL$2(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode$1;
  if (utils$4.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$4.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$4.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils$3,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers2) {
      if (platform.isNode && utils$4.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers2.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils$4.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name2 = path[index2++];
    if (name2 === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path.length;
    name2 = !name2 && utils$4.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils$4.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils$4.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index2);
    if (result && utils$4.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils$4.isFormData(formData) && utils$4.isFunction(formData.entries)) {
    const obj = {};
    utils$4.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder2) {
  if (utils$4.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$4.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$4.isObject(data);
    if (isObjectPayload && utils$4.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$4.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$4.isArrayBuffer(data) || utils$4.isBuffer(data) || utils$4.isStream(data) || utils$4.isFile(data) || utils$4.isBlob(data) || utils$4.isReadableStream(data)) {
      return data;
    }
    if (utils$4.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$4.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$4.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$4.isResponse(data) || utils$4.isReadableStream(data)) {
      return data;
    }
    if (data && utils$4.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$4.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils$4.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$4.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$4.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$4.isString(value))
    return;
  if (utils$4.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$4.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$4.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$4.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$4.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$4.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$4.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$4.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$4.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$4.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$4.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$4.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$4.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$4.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$4.forEach(this, (value, header) => {
      const key = utils$4.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$4.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$4.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target) => computed2.set(target));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$4.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$4.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$4.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$4.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$4.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle$2(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$4.asap(() => fn(...args));
const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value, expires, path, domain, secure) {
      const cookie = [name2 + "=" + encodeURIComponent(value)];
      utils$4.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$4.isString(path) && cookie.push("path=" + path);
      utils$4.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name2) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL$2(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs$2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath$2(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL$2(requestedURL);
  if (baseURL && isRelativeUrl || allowAbsoluteUrls == false) {
    return combineURLs$2(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$4.isPlainObject(target) && utils$4.isPlainObject(source)) {
      return utils$4.merge.call({ caseless }, target, source);
    } else if (utils$4.isPlainObject(source)) {
      return utils$4.merge({}, source);
    } else if (utils$4.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, prop, caseless) {
    if (!utils$4.isUndefined(b2)) {
      return getMergedValue(a2, b2, prop, caseless);
    } else if (!utils$4.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$4.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$4.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$4.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
  };
  utils$4.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$4.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL$2(buildFullPath$2(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$4.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$4.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle$2(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError2() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$4.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$4.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$4.asap(unsubscribe);
    return signal;
  }
};
const composeSignals$1 = composeSignals;
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder2) => (str) => encoder2.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e2) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$4.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$4.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$4.isBlob(body)) {
    return body.size;
  }
  if (utils$4.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$4.isArrayBufferView(body) || utils$4.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$4.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$4.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$4.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$4.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$4.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$4.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$4.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve2, reject) => {
      settle$2(resolve2, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$4.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter2) => utils$4.isFunction(adapter2) || adapter2 === null || adapter2 === false;
const adapters$1 = {
  getAdapter: (adapters2) => {
    adapters2 = utils$4.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter2;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter2 = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter2 === void 0) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter2) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter2;
    }
    if (!adapter2) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter2;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters$1.getAdapter(config.adapter || defaults$1.adapter);
  return adapter2(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION$1 = "1.8.2";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack2;
          } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack2;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$4.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0)
      ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$4.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$4.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath$2(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL$2(fullPath, config.params, config.paramsSerializer);
  }
}
utils$4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$4.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind$2(Axios$1.prototype.request, context);
  utils$4.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$4.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$4.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters$1.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var bind$1 = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};
var bind2 = bind$1;
var toString$2 = Object.prototype.toString;
function isArray$6(val) {
  return toString$2.call(val) === "[object Array]";
}
function isUndefined$1(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString$2.call(val) === "[object ArrayBuffer]";
}
function isFormData$3(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString$4(val) {
  return typeof val === "string";
}
function isNumber$1(val) {
  return typeof val === "number";
}
function isObject$3(val) {
  return val !== null && typeof val === "object";
}
function isDate$2(val) {
  return toString$2.call(val) === "[object Date]";
}
function isFile(val) {
  return toString$2.call(val) === "[object File]";
}
function isBlob(val) {
  return toString$2.call(val) === "[object Blob]";
}
function isFunction$2(val) {
  return toString$2.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$3(val) && isFunction$2(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim(str) {
  return str.replace(/^\s*/, "").replace(/\s*$/, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$6(obj)) {
    for (var i = 0, l2 = obj.length; i < l2; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue2(val, key) {
    if (typeof result[key] === "object" && typeof val === "object") {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }
  for (var i = 0, l2 = arguments.length; i < l2; i++) {
    forEach(arguments[i], assignValue2);
  }
  return result;
}
function deepMerge() {
  var result = {};
  function assignValue2(val, key) {
    if (typeof result[key] === "object" && typeof val === "object") {
      result[key] = deepMerge(result[key], val);
    } else if (typeof val === "object") {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }
  for (var i = 0, l2 = arguments.length; i < l2; i++) {
    forEach(arguments[i], assignValue2);
  }
  return result;
}
function extend(a2, b2, thisArg) {
  forEach(b2, function assignValue2(val, key) {
    if (thisArg && typeof val === "function") {
      a2[key] = bind2(val, thisArg);
    } else {
      a2[key] = val;
    }
  });
  return a2;
}
var utils$1 = {
  isArray: isArray$6,
  isArrayBuffer,
  isBuffer,
  isFormData: isFormData$3,
  isArrayBufferView,
  isString: isString$4,
  isNumber: isNumber$1,
  isObject: isObject$3,
  isUndefined: isUndefined$1,
  isDate: isDate$2,
  isFile,
  isBlob,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  deepMerge,
  extend,
  trim
};
const utils$2 = /* @__PURE__ */ getDefaultExportFromCjs(utils$1);
var enhanceError$1 = function enhanceError(error, config, code2, request, response) {
  error.config = config;
  if (code2) {
    error.code = code2;
  }
  error.request = request;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};
var enhanceError2 = enhanceError$1;
var createError$1 = function createError(message, config, code2, request, response) {
  var error = new Error(message);
  return enhanceError2(error, config, code2, request, response);
};
const createError$2 = /* @__PURE__ */ getDefaultExportFromCjs(createError$1);
var createError2 = createError$1;
var settle = function settle2(resolve2, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(createError2(
      "Request failed with status code " + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};
const settle$1 = /* @__PURE__ */ getDefaultExportFromCjs(settle);
var utils = utils$1;
function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL = function buildURL2(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize2(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils.forEach(val, function parseValue(v2) {
        if (utils.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode(key) + "=" + encode(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
const buildURL$1 = /* @__PURE__ */ getDefaultExportFromCjs(buildURL);
var isAbsoluteURL$1 = function isAbsoluteURL(url) {
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath = function buildFullPath2(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
const buildFullPath$1 = /* @__PURE__ */ getDefaultExportFromCjs(buildFullPath);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encoder(input) {
  var str = String(input);
  var block;
  var charCode;
  var idx = 0;
  var map2 = chars;
  var output = "";
  for (
    ;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map2 = "=", idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map2.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 255) {
      throw new Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
    }
    block = block << 8 | charCode;
  }
  return output;
}
var platFormName = "wechat";
function getRequest() {
  switch (true) {
    case typeof wx$1 === "object":
      platFormName = "wechat";
      return wx$1.request.bind(wx$1);
    case typeof swan === "object":
      platFormName = "baidu";
      return swan.request.bind(swan);
    case typeof dd === "object":
      platFormName = "dd";
      return dd.httpRequest.bind(dd);
    case typeof my === "object":
      platFormName = "alipay";
      return (my.request || my.httpRequest).bind(my);
    default:
      return wx$1.request.bind(wx$1);
  }
}
function transformResponse2(mpResponse, config, mpRequestOption) {
  var headers = mpResponse.header || mpResponse.headers;
  var status = mpResponse.statusCode || mpResponse.status;
  var statusText = "";
  if (status === 200) {
    statusText = "OK";
  } else if (status === 400) {
    statusText = "Bad Request";
  }
  var response = {
    data: mpResponse.data,
    status,
    statusText,
    headers,
    config,
    request: mpRequestOption
  };
  return response;
}
function transformError(error, reject, config) {
  switch (platFormName) {
    case "wechat":
      if (error.errMsg.indexOf("request:fail abort") !== -1) {
        reject(createError$2("Request aborted", config, "ECONNABORTED", ""));
      } else if (error.errMsg.indexOf("timeout") !== -1) {
        reject(createError$2("timeout of " + config.timeout + "ms exceeded", config, "ECONNABORTED", ""));
      } else {
        reject(createError$2("Network Error", config, null, ""));
      }
      break;
    case "dd":
    case "alipay":
      if ([14, 19].includes(error.error)) {
        reject(createError$2("Request aborted", config, "ECONNABORTED", "", error));
      } else if ([13].includes(error.error)) {
        reject(createError$2("timeout of " + config.timeout + "ms exceeded", config, "ECONNABORTED", "", error));
      } else {
        reject(createError$2("Network Error", config, null, "", error));
      }
      break;
    case "baidu":
      reject(createError$2("Network Error", config, null, ""));
      break;
  }
}
function transformConfig(config) {
  var _a2;
  if ([
    "alipay",
    "dd"
    /* 钉钉 */
  ].includes(platFormName)) {
    config.headers = config.header;
    delete config.header;
    if ("dd" === platFormName && config.method !== "GET" && ((_a2 = config.headers) === null || _a2 === void 0 ? void 0 : _a2["Content-Type"]) === "application/json" && Object.prototype.toString.call(config.data) === "[object Object]") {
      config.data = JSON.stringify(config.data);
    }
  }
  return config;
}
var isJSONstr = function(str) {
  try {
    return typeof str === "string" && str.length && (str = JSON.parse(str)) && Object.prototype.toString.call(str) === "[object Object]";
  } catch (error) {
    return false;
  }
};
function mpAdapter(config, _a2) {
  var _b = (_a2 === void 0 ? {} : _a2).transformRequestOption, transformRequestOption = _b === void 0 ? function(requestOption) {
    return requestOption;
  } : _b;
  var request = getRequest();
  return new Promise(function(resolve2, reject) {
    var requestTask;
    var requestData = config.data;
    var requestHeaders = config.headers;
    var requestMethod = config.method && config.method.toUpperCase() || "GET";
    var mpRequestOption = {
      method: requestMethod,
      url: buildURL$1(buildFullPath$1(config.baseURL, config.url), config.params, config.paramsSerializer),
      timeout: config.timeout,
      // Listen for success
      success: function(mpResponse) {
        var response = transformResponse2(mpResponse, config, mpRequestOption);
        settle$1(resolve2, reject, response);
      },
      // Handle request Exception
      fail: function(error) {
        transformError(error, reject, config);
      },
      complete: function() {
        requestTask = void 0;
      }
    };
    if (config.auth) {
      var _a3 = [config.auth.username || "", config.auth.password || ""], username = _a3[0], password = _a3[1];
      requestHeaders.Authorization = "Basic " + encoder(username + ":" + password);
    }
    utils$2.forEach(requestHeaders, function setRequestHeader(val, key) {
      var _header = key.toLowerCase();
      if (typeof requestData === "undefined" && _header === "content-type" || _header === "referer") {
        delete requestHeaders[key];
      }
    });
    mpRequestOption.header = requestHeaders;
    if (config.responseType) {
      mpRequestOption.responseType = config.responseType;
    }
    if (config.cancelToken) {
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!requestTask) {
          return;
        }
        requestTask.abort();
        reject(cancel);
        requestTask = void 0;
      });
    }
    if (isJSONstr(requestData)) {
      requestData = JSON.parse(requestData);
    }
    if (requestData !== void 0) {
      mpRequestOption.data = requestData;
    }
    requestTask = request(transformRequestOption(transformConfig(mpRequestOption)));
  });
}
var sdkName$2 = "@cloudbase/js-sdk";
function setSdkName$2(name2) {
  sdkName$2 = name2;
}
function getSdkName$4() {
  return sdkName$2;
}
var PROTOCOL$1 = "https:";
function setProtocol$1(protocol) {
  PROTOCOL$1 = protocol;
}
function getProtocol$1() {
  return PROTOCOL$1;
}
var COMMUNITY_SITE_URL$4 = "https://support.qq.com/products/148793";
var ERRORS$8 = {
  INVALID_PARAMS: "INVALID_PARAMS",
  INVALID_SYNTAX: "INVALID_SYNTAX",
  INVALID_OPERATION: "INVALID_OPERATION",
  OPERATION_FAIL: "OPERATION_FAIL",
  NETWORK_ERROR: "NETWORK_ERROR",
  UNKOWN_ERROR: "UNKOWN_ERROR"
};
var StorageType;
(function(StorageType2) {
  StorageType2["local"] = "local";
  StorageType2["none"] = "none";
  StorageType2["session"] = "session";
})(StorageType || (StorageType = {}));
var AbstractSDKRequest = /* @__PURE__ */ function() {
  function AbstractSDKRequest2() {
  }
  return AbstractSDKRequest2;
}();
var AbstractStorage = /* @__PURE__ */ function() {
  function AbstractStorage2() {
  }
  return AbstractStorage2;
}();
function formatUrl$3(protocol, url, query) {
  if (query === void 0) {
    query = {};
  }
  var urlHasQuery = /\?/.test(url);
  var queryString = "";
  for (var key in query) {
    if (queryString === "") {
      !urlHasQuery && (url += "?");
    } else {
      queryString += "&";
    }
    queryString += key + "=" + encodeURIComponent(query[key]);
  }
  url += queryString;
  if (/^http(s)?\:\/\//.test(url)) {
    return url;
  }
  return "" + protocol + url;
}
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbstractSDKRequest,
  AbstractStorage,
  get StorageType() {
    return StorageType;
  },
  formatUrl: formatUrl$3
}, Symbol.toStringTag, { value: "Module" }));
function isArray$5(val) {
  return Object.prototype.toString.call(val) === "[object Array]";
}
function isString$3(val) {
  return typeof val === "string";
}
function isPalinObject$2(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
function isInstanceOf$1(instance, construct) {
  return instance instanceof construct;
}
function isFormData$2(val) {
  return Object.prototype.toString.call(val) === "[object FormData]";
}
function genSeqId$2() {
  return Math.random().toString(16).slice(2);
}
function generateRequestId$2() {
  var d2 = (/* @__PURE__ */ new Date()).getTime();
  var d22 = (performance === null || performance === void 0 ? void 0 : performance.now) && performance.now() * 1e3 || 0;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
    var r2 = Math.random() * 16;
    if (d2 > 0) {
      r2 = (d2 + r2) % 16 | 0;
      d2 = Math.floor(d2 / 16);
    } else {
      r2 = (d22 + r2) % 16 | 0;
      d22 = Math.floor(d22 / 16);
    }
    return (c2 === "x" ? r2 : r2 & 7 | 8).toString(16);
  });
}
function formatUrl$2(PROTOCOL2, url, query) {
  if (query === void 0) {
    query = {};
  }
  var urlHasQuery = /\?/.test(url);
  var queryString = "";
  Object.keys(query).forEach(function(key) {
    if (queryString === "") {
      !urlHasQuery && (url += "?");
    } else {
      queryString += "&";
    }
    queryString += "".concat(key, "=").concat(encodeURIComponent(query[key]));
  });
  url += queryString;
  if (/^http(s)?:\/\//.test(url)) {
    return url;
  }
  return "".concat(PROTOCOL2).concat(url);
}
function toQueryString$1(query) {
  if (query === void 0) {
    query = {};
  }
  var queryString = [];
  Object.keys(query).forEach(function(key) {
    queryString.push("".concat(key, "=").concat(encodeURIComponent(query[key])));
  });
  return queryString.join("&");
}
function execCallback$3(fn, err, data) {
  if (data === void 0) {
    data = null;
  }
  if (fn && typeof fn === "function") {
    return fn(err, data);
  }
  if (err) {
    throw err;
  }
  return data;
}
function printWarn$2(error, msg) {
  console.warn("[".concat(getSdkName$4(), "][").concat(error, "]:").concat(msg));
}
function printGroupLog$1(options) {
  var title = options.title, _a2 = options.subtitle, subtitle = _a2 === void 0 ? "" : _a2, _b = options.content, content = _b === void 0 ? [] : _b, _c = options.printTrace, printTrace = _c === void 0 ? false : _c, _d = options.collapsed, collapsed = _d === void 0 ? false : _d;
  if (collapsed) {
    console.groupCollapsed(title, subtitle);
  } else {
    console.group(title, subtitle);
  }
  for (var _i = 0, content_1 = content; _i < content_1.length; _i++) {
    var tip = content_1[_i];
    var type = tip.type, body = tip.body;
    switch (type) {
      case "info":
        console.log(body);
        break;
      case "warn":
        console.warn(body);
        break;
      case "error":
        console.error(body);
        break;
    }
  }
  if (printTrace) {
    console.trace("stack trace:");
  }
  console.groupEnd();
}
var __extends$e = /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign$z = function() {
  __assign$z = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$z.apply(this, arguments);
};
var __awaiter$A = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$A = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var WebRequest$1 = function(_super) {
  __extends$e(WebRequest2, _super);
  function WebRequest2(config) {
    var _this = _super.call(this) || this;
    var timeout = config.timeout, timeoutMsg = config.timeoutMsg, restrictedMethods = config.restrictedMethods;
    _this.timeout = timeout || 0;
    _this.timeoutMsg = timeoutMsg || "请求超时";
    _this.restrictedMethods = restrictedMethods || ["get", "post", "upload", "download"];
    return _this;
  }
  WebRequest2.prototype.get = function(options) {
    return this.request(__assign$z(__assign$z({}, options), { method: "get" }), this.restrictedMethods.includes("get"));
  };
  WebRequest2.prototype.post = function(options) {
    return this.request(__assign$z(__assign$z({}, options), { method: "post" }), this.restrictedMethods.includes("post"));
  };
  WebRequest2.prototype.put = function(options) {
    return this.request(__assign$z(__assign$z({}, options), { method: "put" }));
  };
  WebRequest2.prototype.upload = function(options) {
    var data = options.data, file = options.file, name2 = options.name, method = options.method, _a2 = options.headers, headers = _a2 === void 0 ? {} : _a2;
    var reqMethod = { post: "post", put: "put" }[method === null || method === void 0 ? void 0 : method.toLowerCase()] || "put";
    var formData = new FormData();
    if (reqMethod === "post") {
      Object.keys(data).forEach(function(key) {
        formData.append(key, data[key]);
      });
      formData.append("key", name2);
      formData.append("file", file);
      return this.request(__assign$z(__assign$z({}, options), { data: formData, method: reqMethod }), this.restrictedMethods.includes("upload"));
    }
    return this.request(__assign$z(__assign$z({}, options), { method: "put", headers, body: file }), this.restrictedMethods.includes("upload"));
  };
  WebRequest2.prototype.download = function(options) {
    return __awaiter$A(this, void 0, void 0, function() {
      var data, url, fileName, link;
      return __generator$A(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, this.get(__assign$z(__assign$z({}, options), { headers: {}, responseType: "blob" }))];
          case 1:
            data = _a2.sent().data;
            url = window.URL.createObjectURL(new Blob([data]));
            fileName = decodeURIComponent(new URL(options.url).pathname.split("/").pop() || "");
            link = document.createElement("a");
            link.href = url;
            link.setAttribute("download", fileName);
            link.style.display = "none";
            document.body.appendChild(link);
            link.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(link);
            return [3, 3];
          case 2:
            _a2.sent();
            return [3, 3];
          case 3:
            return [2, new Promise(function(resolve2) {
              resolve2({
                statusCode: 200,
                tempFilePath: options.url
              });
            })];
        }
      });
    });
  };
  WebRequest2.prototype.fetch = function(options) {
    var _a2;
    return __awaiter$A(this, void 0, void 0, function() {
      var abortController, url, _b, enableAbort, _c, stream, signal, timer, res;
      var _this = this;
      return __generator$A(this, function(_d) {
        switch (_d.label) {
          case 0:
            abortController = new AbortController();
            url = options.url, _b = options.enableAbort, enableAbort = _b === void 0 ? false : _b, _c = options.stream, stream = _c === void 0 ? false : _c, signal = options.signal;
            if (signal) {
              if (signal.aborted)
                abortController.abort();
              signal.addEventListener("abort", function() {
                return abortController.abort();
              });
            }
            timer = null;
            if (enableAbort && this.timeout) {
              timer = setTimeout(function() {
                console.warn(_this.timeoutMsg);
                abortController.abort(new Error(_this.timeoutMsg));
              }, this.timeout);
            }
            return [4, fetch(url, __assign$z(__assign$z({}, options), { signal: abortController.signal })).then(function(response) {
              return __awaiter$A(_this, void 0, void 0, function() {
                var _a3, _b2, _c2;
                return __generator$A(this, function(_d2) {
                  switch (_d2.label) {
                    case 0:
                      clearTimeout(timer);
                      if (!response.ok)
                        return [3, 1];
                      _a3 = response;
                      return [3, 3];
                    case 1:
                      _c2 = (_b2 = Promise).reject;
                      return [4, response.json()];
                    case 2:
                      _a3 = _c2.apply(_b2, [_d2.sent()]);
                      _d2.label = 3;
                    case 3:
                      return [2, _a3];
                  }
                });
              });
            }).catch(function(x2) {
              clearTimeout(timer);
              return Promise.reject(x2);
            })];
          case 1:
            res = _d.sent();
            return [2, {
              data: stream ? res.body : ((_a2 = res.headers.get("content-type")) === null || _a2 === void 0 ? void 0 : _a2.includes("application/json")) ? res.json() : res.text(),
              statusCode: res.status,
              header: res.headers
            }];
        }
      });
    });
  };
  WebRequest2.prototype.request = function(options, enableAbort) {
    var _this = this;
    if (enableAbort === void 0) {
      enableAbort = false;
    }
    var method = String(options.method).toLowerCase() || "get";
    return new Promise(function(resolve2) {
      var url = options.url, _a2 = options.headers, headers = _a2 === void 0 ? {} : _a2, data = options.data, responseType = options.responseType, withCredentials = options.withCredentials, body = options.body, onUploadProgress = options.onUploadProgress;
      var realUrl = formatUrl$2(getProtocol$1(), url, method === "get" ? data : {});
      var ajax = new XMLHttpRequest();
      ajax.open(method, realUrl);
      responseType && (ajax.responseType = responseType);
      Object.keys(headers).forEach(function(key) {
        ajax.setRequestHeader(key, headers[key]);
      });
      var timer;
      if (onUploadProgress) {
        ajax.upload.addEventListener("progress", onUploadProgress);
      }
      ajax.onreadystatechange = function() {
        var result = {};
        if (ajax.readyState === 4) {
          var headers_1 = ajax.getAllResponseHeaders();
          var arr = headers_1.trim().split(/[\r\n]+/);
          var headerMap_1 = {};
          arr.forEach(function(line) {
            var parts = line.split(": ");
            var header = parts.shift().toLowerCase();
            var value = parts.join(": ");
            headerMap_1[header] = value;
          });
          result.header = headerMap_1;
          result.statusCode = ajax.status;
          try {
            result.data = responseType === "blob" ? ajax.response : JSON.parse(ajax.responseText);
          } catch (e2) {
            result.data = responseType === "blob" ? ajax.response : ajax.responseText;
          }
          clearTimeout(timer);
          resolve2(result);
        }
      };
      if (enableAbort && _this.timeout) {
        timer = setTimeout(function() {
          console.warn(_this.timeoutMsg);
          ajax.abort();
        }, _this.timeout);
      }
      var payload;
      if (isFormData$2(data)) {
        payload = data;
      } else if (headers["content-type"] === "application/x-www-form-urlencoded") {
        payload = toQueryString$1(data);
      } else if (body) {
        payload = body;
      } else {
        payload = data ? JSON.stringify(data) : void 0;
      }
      if (withCredentials) {
        ajax.withCredentials = true;
      }
      ajax.send(payload);
    });
  };
  return WebRequest2;
}(AbstractSDKRequest);
function genAdapter$2() {
  var adapter2 = {
    root: window,
    reqClass: WebRequest$1,
    wsClass: WebSocket,
    localStorage
  };
  return adapter2;
}
var RUNTIME;
(function(RUNTIME2) {
  RUNTIME2["WEB"] = "web";
  RUNTIME2["WX_MP"] = "wx_mp";
})(RUNTIME || (RUNTIME = {}));
function useAdapters$1(adapters2) {
  var adapterList = isArray$5(adapters2) ? adapters2 : [adapters2];
  for (var _i = 0, adapterList_1 = adapterList; _i < adapterList_1.length; _i++) {
    var adapter2 = adapterList_1[_i];
    var isMatch2 = adapter2.isMatch, genAdapter2 = adapter2.genAdapter, runtime2 = adapter2.runtime;
    if (isMatch2()) {
      return {
        adapter: genAdapter2(),
        runtime: runtime2
      };
    }
  }
}
function useDefaultAdapter$1() {
  return {
    adapter: genAdapter$2(),
    runtime: RUNTIME.WEB
  };
}
var __extends$d = /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __awaiter$z = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$z = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var TcbCacheObject$1 = function(_super) {
  __extends$d(TcbCacheObject2, _super);
  function TcbCacheObject2(root2) {
    var _this = _super.call(this) || this;
    _this.root = root2;
    if (!root2.tcbCacheObject) {
      root2.tcbCacheObject = {};
    }
    return _this;
  }
  TcbCacheObject2.prototype.setItem = function(key, value) {
    this.root.tcbCacheObject[key] = value;
  };
  TcbCacheObject2.prototype.getItem = function(key) {
    return this.root.tcbCacheObject[key];
  };
  TcbCacheObject2.prototype.removeItem = function(key) {
    delete this.root.tcbCacheObject[key];
  };
  TcbCacheObject2.prototype.clear = function() {
    delete this.root.tcbCacheObject;
  };
  return TcbCacheObject2;
}(AbstractStorage);
function createStorage$1(persistence, adapter2) {
  switch (persistence) {
    case "local":
      if (!adapter2.localStorage) {
        printWarn$2(ERRORS$8.INVALID_PARAMS, "localStorage is not supported on current platform");
        return new TcbCacheObject$1(adapter2.root);
      }
      return adapter2.localStorage;
    case "none":
      return new TcbCacheObject$1(adapter2.root);
    default:
      if (!adapter2.localStorage) {
        printWarn$2(ERRORS$8.INVALID_PARAMS, "localStorage is not supported on current platform");
        return new TcbCacheObject$1(adapter2.root);
      }
      return adapter2.localStorage;
  }
}
var CloudbaseCache$2 = function() {
  function CloudbaseCache2(config) {
    this.keys = {};
    var persistence = config.persistence, _a2 = config.platformInfo, platformInfo = _a2 === void 0 ? {} : _a2, _b = config.keys, keys = _b === void 0 ? {} : _b;
    this.platformInfo = platformInfo;
    if (!this.storage) {
      this.persistenceTag = this.platformInfo.adapter.primaryStorage || persistence;
      this.storage = createStorage$1(this.persistenceTag, this.platformInfo.adapter);
      this.keys = keys;
    }
  }
  Object.defineProperty(CloudbaseCache2.prototype, "mode", {
    get: function() {
      return this.storage.mode || "sync";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CloudbaseCache2.prototype, "persistence", {
    get: function() {
      return this.persistenceTag;
    },
    enumerable: false,
    configurable: true
  });
  CloudbaseCache2.prototype.setStore = function(key, value, version2) {
    if (this.mode === "async") {
      printWarn$2(ERRORS$8.INVALID_OPERATION, "current platform's storage is asynchronous, please use setStoreAsync insteed");
      return;
    }
    if (!this.storage) {
      return;
    }
    try {
      var val = {
        version: version2 || "localCachev1",
        content: value
      };
      this.storage.setItem(key, JSON.stringify(val));
    } catch (e2) {
      throw new Error(JSON.stringify({
        code: ERRORS$8.OPERATION_FAIL,
        msg: "[".concat(getSdkName$4(), "][").concat(ERRORS$8.OPERATION_FAIL, "]setStore failed"),
        info: e2
      }));
    }
    return;
  };
  CloudbaseCache2.prototype.setStoreAsync = function(key, value, version2) {
    return __awaiter$z(this, void 0, void 0, function() {
      var val;
      return __generator$z(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!this.storage) {
              return [2];
            }
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            val = {
              version: version2 || "localCachev1",
              content: value
            };
            return [4, this.storage.setItem(key, JSON.stringify(val))];
          case 2:
            _a2.sent();
            return [3, 4];
          case 3:
            _a2.sent();
            return [2];
          case 4:
            return [2];
        }
      });
    });
  };
  CloudbaseCache2.prototype.getStore = function(key, version2) {
    var _a2;
    if (this.mode === "async") {
      printWarn$2(ERRORS$8.INVALID_OPERATION, "current platform's storage is asynchronous, please use getStoreAsync insteed");
      return;
    }
    try {
      if (typeof process !== "undefined" && ((_a2 = process.env) === null || _a2 === void 0 ? void 0 : _a2.tcb_token)) {
        return process.env.tcb_token;
      }
      if (!this.storage) {
        return "";
      }
    } catch (e2) {
      return "";
    }
    version2 = version2 || "localCachev1";
    var content = this.storage.getItem(key);
    if (!content) {
      return "";
    }
    if (content.indexOf(version2) >= 0) {
      var d2 = JSON.parse(content);
      return d2.content;
    }
    return "";
  };
  CloudbaseCache2.prototype.getStoreAsync = function(key, version2) {
    var _a2;
    return __awaiter$z(this, void 0, void 0, function() {
      var content, d2;
      return __generator$z(this, function(_b) {
        switch (_b.label) {
          case 0:
            try {
              if (typeof process !== "undefined" && ((_a2 = process.env) === null || _a2 === void 0 ? void 0 : _a2.tcb_token)) {
                return [2, process.env.tcb_token];
              }
              if (!this.storage) {
                return [2, ""];
              }
            } catch (e2) {
              return [2, ""];
            }
            version2 = version2 || "localCachev1";
            return [4, this.storage.getItem(key)];
          case 1:
            content = _b.sent();
            if (!content) {
              return [2, ""];
            }
            if (content.indexOf(version2) >= 0) {
              d2 = JSON.parse(content);
              return [2, d2.content];
            }
            return [2, ""];
        }
      });
    });
  };
  CloudbaseCache2.prototype.removeStore = function(key) {
    if (this.mode === "async") {
      printWarn$2(ERRORS$8.INVALID_OPERATION, "current platform's storage is asynchronous, please use removeStoreAsync insteed");
      return;
    }
    this.storage.removeItem(key);
  };
  CloudbaseCache2.prototype.removeStoreAsync = function(key) {
    return __awaiter$z(this, void 0, void 0, function() {
      return __generator$z(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.storage.removeItem(key)];
          case 1:
            _a2.sent();
            return [2];
        }
      });
    });
  };
  return CloudbaseCache2;
}();
var __extends$c = /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __spreadArray$4 = function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar2; i < l2; i++) {
      if (ar2 || !(i in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i);
        ar2[i] = from[i];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
function customeAddEventListener$1(name2, listener, listeners) {
  listeners[name2] = listeners[name2] || [];
  listeners[name2].push(listener);
}
function customRemoveEventListener$1(name2, listener, listeners) {
  if (listeners === null || listeners === void 0 ? void 0 : listeners[name2]) {
    var index2 = listeners[name2].indexOf(listener);
    if (index2 !== -1) {
      listeners[name2].splice(index2, 1);
    }
  }
}
var CloudbaseEvent$1 = /* @__PURE__ */ function() {
  function CloudbaseEvent2(name2, data) {
    this.data = data || null;
    this.name = name2;
  }
  return CloudbaseEvent2;
}();
var IErrorEvent$1 = function(_super) {
  __extends$c(IErrorEvent2, _super);
  function IErrorEvent2(error, data) {
    var _this = _super.call(this, "error", { error, data }) || this;
    _this.error = error;
    return _this;
  }
  return IErrorEvent2;
}(CloudbaseEvent$1);
var CloudbaseEventEmitter$2 = function() {
  function CloudbaseEventEmitter2() {
    this.listeners = {};
  }
  CloudbaseEventEmitter2.prototype.on = function(name2, listener) {
    customeAddEventListener$1(name2, listener, this.listeners);
    return this;
  };
  CloudbaseEventEmitter2.prototype.off = function(name2, listener) {
    customRemoveEventListener$1(name2, listener, this.listeners);
    return this;
  };
  CloudbaseEventEmitter2.prototype.fire = function(event, data) {
    if (isInstanceOf$1(event, IErrorEvent$1)) {
      console.error(event.error);
      return this;
    }
    var ev = isString$3(event) ? new CloudbaseEvent$1(event, data || {}) : event;
    var name2 = ev.name;
    if (this.listens(name2)) {
      ev.target = this;
      var handlers = this.listeners[name2] ? __spreadArray$4([], this.listeners[name2], true) : [];
      for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
        var fn = handlers_1[_i];
        fn.call(this, ev);
      }
    }
    return this;
  };
  CloudbaseEventEmitter2.prototype.listens = function(name2) {
    return this.listeners[name2] && this.listeners[name2].length > 0;
  };
  return CloudbaseEventEmitter2;
}();
var __awaiter$y = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$y = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var isFirefox$1 = false;
if (typeof navigator !== "undefined" && navigator.userAgent) {
  isFirefox$1 = navigator.userAgent.indexOf("Firefox") !== -1;
}
var REG_STACK_DECORATE$1 = isFirefox$1 ? /(\.js\/)?__decorate(\$\d+)?<@.*\d$/ : /(\/\w+\.js\.)?__decorate(\$\d+)?\s*\(.*\)$/;
var REG_STACK_LINK$1 = /https?:\/\/.+:\d*\/.*\.js:\d+:\d+/;
function catchErrorsDecorator$5(options) {
  var _a2 = options.mode, mode = _a2 === void 0 ? "async" : _a2, _b = options.customInfo, customInfo = _b === void 0 ? {} : _b, title = options.title, _c = options.messages, messages = _c === void 0 ? [] : _c;
  return function(target, methodName, descriptor) {
    var className = customInfo.className || target.constructor.name;
    var fnName = customInfo.methodName || methodName;
    var fn = descriptor.value;
    var sourceLink = getSourceLink$1(new Error());
    if (mode === "sync") {
      descriptor.value = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var innerErr = getRewritedError$1({
          err: new Error(),
          className,
          methodName: fnName,
          sourceLink
        });
        try {
          return fn.apply(this, args);
        } catch (err) {
          var failErr = err;
          var errMsg = err.message, error = err.error, errorDescription = err.error_description;
          var logs = {
            title: title || "".concat(className, ".").concat(fnName, " failed"),
            content: [{
              type: "error",
              body: err
            }]
          };
          if (errMsg && /^\{.*\}$/.test(errMsg)) {
            var msg = JSON.parse(errMsg);
            logs.subtitle = errMsg;
            if (msg.code) {
              if (innerErr) {
                innerErr.code = msg.code;
                innerErr.msg = msg.msg;
              } else {
                err.code = msg.code;
                err.message = msg.msg;
              }
              failErr = innerErr || err;
              logs.content = messages.map(function(msg2) {
                return {
                  type: "info",
                  body: msg2
                };
              });
            }
          }
          if (error && errorDescription) {
            logs.subtitle = errorDescription;
            if (innerErr) {
              innerErr.code = error;
              innerErr.msg = errorDescription;
            } else {
              err.code = error;
              err.message = errorDescription;
            }
            failErr = innerErr || err;
            logs.content = messages.map(function(msg2) {
              return {
                type: "info",
                body: msg2
              };
            });
          }
          printGroupLog$1(logs);
          throw failErr;
        }
      };
    } else {
      descriptor.value = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter$y(this, void 0, void 0, function() {
          var innerErr, err_1, failErr, errMsg, error, errorDescription, logs, msg;
          return __generator$y(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                innerErr = getRewritedError$1({
                  err: new Error(),
                  className,
                  methodName: fnName,
                  sourceLink
                });
                _a3.label = 1;
              case 1:
                _a3.trys.push([1, 3, , 4]);
                return [4, fn.apply(this, args)];
              case 2:
                return [2, _a3.sent()];
              case 3:
                err_1 = _a3.sent();
                failErr = err_1;
                errMsg = err_1.message, error = err_1.error, errorDescription = err_1.error_description;
                logs = {
                  title: title || "".concat(className, ".").concat(fnName, " failed"),
                  content: [{
                    type: "error",
                    body: err_1
                  }]
                };
                if (errMsg && /^\{.*\}$/.test(errMsg)) {
                  msg = JSON.parse(errMsg);
                  logs.subtitle = msg;
                  if (msg.code) {
                    if (innerErr) {
                      innerErr.code = msg.code;
                      innerErr.message = msg.msg;
                    } else {
                      err_1.code = msg.code;
                      err_1.message = msg.msg;
                    }
                    failErr = innerErr || err_1;
                    logs.content = messages.map(function(msg2) {
                      return {
                        type: "info",
                        body: msg2
                      };
                    });
                  }
                }
                if (error && errorDescription) {
                  logs.subtitle = errorDescription;
                  if (innerErr) {
                    innerErr.code = error;
                    innerErr.msg = errorDescription;
                  } else {
                    err_1.code = error;
                    err_1.message = errorDescription;
                  }
                  failErr = innerErr || err_1;
                  logs.content = messages.map(function(msg2) {
                    return {
                      type: "info",
                      body: msg2
                    };
                  });
                }
                printGroupLog$1(logs);
                throw failErr;
              case 4:
                return [2];
            }
          });
        });
      };
    }
  };
}
function getSourceLink$1(err) {
  var sourceLink = "";
  var outterErrStacks = err.stack.split("\n");
  var indexOfDecorator = outterErrStacks.findIndex(function(str) {
    return REG_STACK_DECORATE$1.test(str);
  });
  if (indexOfDecorator !== -1) {
    var match = REG_STACK_LINK$1.exec(outterErrStacks[indexOfDecorator + 1] || "");
    sourceLink = match ? match[0] : "";
  }
  return sourceLink;
}
function getRewritedError$1(options) {
  var err = options.err, className = options.className, methodName = options.methodName, sourceLink = options.sourceLink;
  if (!sourceLink) {
    return null;
  }
  var innerErrStack = err.stack.split("\n");
  var REG_STACK_INNER_METHOD = isFirefox$1 ? /^catchErrorsDecorator\/<\/descriptor.value@.*\d$/ : new RegExp("".concat(className, "\\.descriptor.value\\s*\\[as\\s").concat(methodName, "\\]\\s*\\(.*\\)$"));
  var REG_STACK_INNER_METHOD_WITHOUT_LINK = isFirefox$1 ? /^catchErrorsDecorator\/<\/descriptor.value/ : new RegExp("".concat(className, "\\.descriptor.value\\s*\\[as\\s").concat(methodName, "\\]"));
  var indexOfSource = innerErrStack.findIndex(function(str) {
    return REG_STACK_INNER_METHOD.test(str);
  });
  var innerErr;
  if (indexOfSource !== -1) {
    var realErrStack = innerErrStack.filter(function(v2, i) {
      return i > indexOfSource;
    });
    realErrStack.unshift(innerErrStack[indexOfSource].replace(REG_STACK_INNER_METHOD_WITHOUT_LINK, "".concat(className, ".").concat(methodName)).replace(REG_STACK_LINK$1, sourceLink));
    innerErr = new Error();
    innerErr.stack = "".concat(isFirefox$1 ? "@debugger" : "Error", "\n").concat(realErrStack.join("\n"));
  }
  return innerErr;
}
function e$1(e2) {
  this.message = e2;
}
e$1.prototype = new Error(), e$1.prototype.name = "InvalidCharacterError";
"undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
  var t2 = String(r2).replace(/=+$/, "");
  if (t2.length % 4 == 1)
    throw new e$1("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n2, o2, a2 = 0, i = 0, c2 = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a2 % 4 ? 64 * n2 + o2 : o2, a2++ % 4) ? c2 += String.fromCharCode(255 & n2 >> (-2 * a2 & 6)) : 0)
    o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
  return c2;
};
function n$1(e2) {
  this.message = e2;
}
n$1.prototype = new Error(), n$1.prototype.name = "InvalidTokenError";
/**
 * @license
 * web-streams-polyfill v4.1.0
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */
function e() {
}
function t(e2) {
  return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
}
const r = e;
function o(e2, t2) {
  try {
    Object.defineProperty(e2, "name", { value: t2, configurable: true });
  } catch (e3) {
  }
}
const n = Promise, a = Promise.resolve.bind(n), i$1 = Promise.prototype.then, l = Promise.reject.bind(n), s = a;
function u(e2) {
  return new n(e2);
}
function c(e2) {
  return u((t2) => t2(e2));
}
function d(e2) {
  return l(e2);
}
function f(e2, t2, r2) {
  return i$1.call(e2, t2, r2);
}
function b(e2, t2, o2) {
  f(f(e2, t2, o2), void 0, r);
}
function h(e2, t2) {
  b(e2, t2);
}
function m(e2, t2) {
  b(e2, void 0, t2);
}
function _(e2, t2, r2) {
  return f(e2, t2, r2);
}
function p(e2) {
  f(e2, void 0, r);
}
let y = (e2) => {
  if ("function" == typeof queueMicrotask)
    y = queueMicrotask;
  else {
    const e3 = c(void 0);
    y = (t2) => f(e3, t2);
  }
  return y(e2);
};
function S(e2, t2, r2) {
  if ("function" != typeof e2)
    throw new TypeError("Argument is not a function");
  return Function.prototype.apply.call(e2, t2, r2);
}
function g(e2, t2, r2) {
  try {
    return c(S(e2, t2, r2));
  } catch (e3) {
    return d(e3);
  }
}
class v {
  constructor() {
    this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
  }
  get length() {
    return this._size;
  }
  push(e2) {
    const t2 = this._back;
    let r2 = t2;
    16383 === t2._elements.length && (r2 = { _elements: [], _next: void 0 }), t2._elements.push(e2), r2 !== t2 && (this._back = r2, t2._next = r2), ++this._size;
  }
  shift() {
    const e2 = this._front;
    let t2 = e2;
    const r2 = this._cursor;
    let o2 = r2 + 1;
    const n2 = e2._elements, a2 = n2[r2];
    return 16384 === o2 && (t2 = e2._next, o2 = 0), --this._size, this._cursor = o2, e2 !== t2 && (this._front = t2), n2[r2] = void 0, a2;
  }
  forEach(e2) {
    let t2 = this._cursor, r2 = this._front, o2 = r2._elements;
    for (; !(t2 === o2.length && void 0 === r2._next || t2 === o2.length && (r2 = r2._next, o2 = r2._elements, t2 = 0, 0 === o2.length)); )
      e2(o2[t2]), ++t2;
  }
  peek() {
    const e2 = this._front, t2 = this._cursor;
    return e2._elements[t2];
  }
}
const w = Symbol("[[AbortSteps]]"), R = Symbol("[[ErrorSteps]]"), T = Symbol("[[CancelSteps]]"), C = Symbol("[[PullSteps]]"), P = Symbol("[[ReleaseSteps]]");
function q(e2, t2) {
  e2._ownerReadableStream = t2, t2._reader = e2, "readable" === t2._state ? B(e2) : "closed" === t2._state ? function(e3) {
    B(e3), A(e3);
  }(e2) : k(e2, t2._storedError);
}
function E(e2, t2) {
  return Or(e2._ownerReadableStream, t2);
}
function W(e2) {
  const t2 = e2._ownerReadableStream;
  "readable" === t2._state ? j(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e3, t3) {
    k(e3, t3);
  }(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), t2._readableStreamController[P](), t2._reader = void 0, e2._ownerReadableStream = void 0;
}
function O(e2) {
  return new TypeError("Cannot " + e2 + " a stream using a released reader");
}
function B(e2) {
  e2._closedPromise = u((t2, r2) => {
    e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2;
  });
}
function k(e2, t2) {
  B(e2), j(e2, t2);
}
function j(e2, t2) {
  void 0 !== e2._closedPromise_reject && (p(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
}
function A(e2) {
  void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
}
const z = Number.isFinite || function(e2) {
  return "number" == typeof e2 && isFinite(e2);
}, D = Math.trunc || function(e2) {
  return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
};
function L(e2, t2) {
  if (void 0 !== e2 && ("object" != typeof (r2 = e2) && "function" != typeof r2))
    throw new TypeError(`${t2} is not an object.`);
  var r2;
}
function F(e2, t2) {
  if ("function" != typeof e2)
    throw new TypeError(`${t2} is not a function.`);
}
function I(e2, t2) {
  if (!/* @__PURE__ */ function(e3) {
    return "object" == typeof e3 && null !== e3 || "function" == typeof e3;
  }(e2))
    throw new TypeError(`${t2} is not an object.`);
}
function $(e2, t2, r2) {
  if (void 0 === e2)
    throw new TypeError(`Parameter ${t2} is required in '${r2}'.`);
}
function M(e2, t2, r2) {
  if (void 0 === e2)
    throw new TypeError(`${t2} is required in '${r2}'.`);
}
function Y(e2) {
  return Number(e2);
}
function x(e2) {
  return 0 === e2 ? 0 : e2;
}
function Q(e2, t2) {
  const r2 = Number.MAX_SAFE_INTEGER;
  let o2 = Number(e2);
  if (o2 = x(o2), !z(o2))
    throw new TypeError(`${t2} is not a finite number`);
  if (o2 = function(e3) {
    return x(D(e3));
  }(o2), o2 < 0 || o2 > r2)
    throw new TypeError(`${t2} is outside the accepted range of 0 to ${r2}, inclusive`);
  return z(o2) && 0 !== o2 ? o2 : 0;
}
function N(e2, t2) {
  if (!Er(e2))
    throw new TypeError(`${t2} is not a ReadableStream.`);
}
function H(e2) {
  return new ReadableStreamDefaultReader(e2);
}
function V(e2, t2) {
  e2._reader._readRequests.push(t2);
}
function U(e2, t2, r2) {
  const o2 = e2._reader._readRequests.shift();
  r2 ? o2._closeSteps() : o2._chunkSteps(t2);
}
function G(e2) {
  return e2._reader._readRequests.length;
}
function X(e2) {
  const t2 = e2._reader;
  return void 0 !== t2 && !!J(t2);
}
class ReadableStreamDefaultReader {
  constructor(e2) {
    if ($(e2, 1, "ReadableStreamDefaultReader"), N(e2, "First parameter"), Wr(e2))
      throw new TypeError("This stream has already been locked for exclusive reading by another reader");
    q(this, e2), this._readRequests = new v();
  }
  get closed() {
    return J(this) ? this._closedPromise : d(ee("closed"));
  }
  cancel(e2 = void 0) {
    return J(this) ? void 0 === this._ownerReadableStream ? d(O("cancel")) : E(this, e2) : d(ee("cancel"));
  }
  read() {
    if (!J(this))
      return d(ee("read"));
    if (void 0 === this._ownerReadableStream)
      return d(O("read from"));
    let e2, t2;
    const r2 = u((r3, o2) => {
      e2 = r3, t2 = o2;
    });
    return K(this, { _chunkSteps: (t3) => e2({ value: t3, done: false }), _closeSteps: () => e2({ value: void 0, done: true }), _errorSteps: (e3) => t2(e3) }), r2;
  }
  releaseLock() {
    if (!J(this))
      throw ee("releaseLock");
    void 0 !== this._ownerReadableStream && function(e2) {
      W(e2);
      const t2 = new TypeError("Reader was released");
      Z(e2, t2);
    }(this);
  }
}
function J(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readRequests") && e2 instanceof ReadableStreamDefaultReader);
}
function K(e2, t2) {
  const r2 = e2._ownerReadableStream;
  r2._disturbed = true, "closed" === r2._state ? t2._closeSteps() : "errored" === r2._state ? t2._errorSteps(r2._storedError) : r2._readableStreamController[C](t2);
}
function Z(e2, t2) {
  const r2 = e2._readRequests;
  e2._readRequests = new v(), r2.forEach((e3) => {
    e3._errorSteps(t2);
  });
}
function ee(e2) {
  return new TypeError(`ReadableStreamDefaultReader.prototype.${e2} can only be used on a ReadableStreamDefaultReader`);
}
var te, re, oe;
function ne(e2) {
  return e2.slice();
}
function ae(e2, t2, r2, o2, n2) {
  new Uint8Array(e2).set(new Uint8Array(r2, o2, n2), t2);
}
Object.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), o(ReadableStreamDefaultReader.prototype.cancel, "cancel"), o(ReadableStreamDefaultReader.prototype.read, "read"), o(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
let ie = (e2) => (ie = "function" == typeof e2.transfer ? (e3) => e3.transfer() : "function" == typeof structuredClone ? (e3) => structuredClone(e3, { transfer: [e3] }) : (e3) => e3, ie(e2)), le = (e2) => (le = "boolean" == typeof e2.detached ? (e3) => e3.detached : (e3) => 0 === e3.byteLength, le(e2));
function se(e2, t2, r2) {
  if (e2.slice)
    return e2.slice(t2, r2);
  const o2 = r2 - t2, n2 = new ArrayBuffer(o2);
  return ae(n2, 0, e2, t2, o2), n2;
}
function ue(e2, t2) {
  const r2 = e2[t2];
  if (null != r2) {
    if ("function" != typeof r2)
      throw new TypeError(`${String(t2)} is not a function`);
    return r2;
  }
}
function ce(e2) {
  try {
    const t2 = e2.done, r2 = e2.value;
    return f(s(r2), (e3) => ({ done: t2, value: e3 }));
  } catch (e3) {
    return d(e3);
  }
}
const de = null !== (oe = null !== (te = Symbol.asyncIterator) && void 0 !== te ? te : null === (re = Symbol.for) || void 0 === re ? void 0 : re.call(Symbol, "Symbol.asyncIterator")) && void 0 !== oe ? oe : "@@asyncIterator";
function fe(e2, r2 = "sync", o2) {
  if (void 0 === o2)
    if ("async" === r2) {
      if (void 0 === (o2 = ue(e2, de))) {
        return function(e3) {
          const r3 = { next() {
            let t2;
            try {
              t2 = be(e3);
            } catch (e4) {
              return d(e4);
            }
            return ce(t2);
          }, return(r4) {
            let o3;
            try {
              const t2 = ue(e3.iterator, "return");
              if (void 0 === t2)
                return c({ done: true, value: r4 });
              o3 = S(t2, e3.iterator, [r4]);
            } catch (e4) {
              return d(e4);
            }
            return t(o3) ? ce(o3) : d(new TypeError("The iterator.return() method must return an object"));
          } };
          return { iterator: r3, nextMethod: r3.next, done: false };
        }(fe(e2, "sync", ue(e2, Symbol.iterator)));
      }
    } else
      o2 = ue(e2, Symbol.iterator);
  if (void 0 === o2)
    throw new TypeError("The object is not iterable");
  const n2 = S(o2, e2, []);
  if (!t(n2))
    throw new TypeError("The iterator method must return an object");
  return { iterator: n2, nextMethod: n2.next, done: false };
}
function be(e2) {
  const r2 = S(e2.nextMethod, e2.iterator, []);
  if (!t(r2))
    throw new TypeError("The iterator.next() method must return an object");
  return r2;
}
class he {
  constructor(e2, t2) {
    this._ongoingPromise = void 0, this._isFinished = false, this._reader = e2, this._preventCancel = t2;
  }
  next() {
    const e2 = () => this._nextSteps();
    return this._ongoingPromise = this._ongoingPromise ? _(this._ongoingPromise, e2, e2) : e2(), this._ongoingPromise;
  }
  return(e2) {
    const t2 = () => this._returnSteps(e2);
    return this._ongoingPromise = this._ongoingPromise ? _(this._ongoingPromise, t2, t2) : t2(), this._ongoingPromise;
  }
  _nextSteps() {
    if (this._isFinished)
      return Promise.resolve({ value: void 0, done: true });
    const e2 = this._reader;
    let t2, r2;
    const o2 = u((e3, o3) => {
      t2 = e3, r2 = o3;
    });
    return K(e2, { _chunkSteps: (e3) => {
      this._ongoingPromise = void 0, y(() => t2({ value: e3, done: false }));
    }, _closeSteps: () => {
      this._ongoingPromise = void 0, this._isFinished = true, W(e2), t2({ value: void 0, done: true });
    }, _errorSteps: (t3) => {
      this._ongoingPromise = void 0, this._isFinished = true, W(e2), r2(t3);
    } }), o2;
  }
  _returnSteps(e2) {
    if (this._isFinished)
      return Promise.resolve({ value: e2, done: true });
    this._isFinished = true;
    const t2 = this._reader;
    if (!this._preventCancel) {
      const r2 = E(t2, e2);
      return W(t2), _(r2, () => ({ value: e2, done: true }));
    }
    return W(t2), c({ value: e2, done: true });
  }
}
const me = { next() {
  return _e(this) ? this._asyncIteratorImpl.next() : d(pe("next"));
}, return(e2) {
  return _e(this) ? this._asyncIteratorImpl.return(e2) : d(pe("return"));
}, [de]() {
  return this;
} };
function _e(e2) {
  if (!t(e2))
    return false;
  if (!Object.prototype.hasOwnProperty.call(e2, "_asyncIteratorImpl"))
    return false;
  try {
    return e2._asyncIteratorImpl instanceof he;
  } catch (e3) {
    return false;
  }
}
function pe(e2) {
  return new TypeError(`ReadableStreamAsyncIterator.${e2} can only be used on a ReadableSteamAsyncIterator`);
}
Object.defineProperty(me, de, { enumerable: false });
const ye = Number.isNaN || function(e2) {
  return e2 != e2;
};
function Se(e2) {
  const t2 = se(e2.buffer, e2.byteOffset, e2.byteOffset + e2.byteLength);
  return new Uint8Array(t2);
}
function ge(e2) {
  const t2 = e2._queue.shift();
  return e2._queueTotalSize -= t2.size, e2._queueTotalSize < 0 && (e2._queueTotalSize = 0), t2.value;
}
function ve(e2, t2, r2) {
  if ("number" != typeof (o2 = r2) || ye(o2) || o2 < 0 || r2 === 1 / 0)
    throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
  var o2;
  e2._queue.push({ value: t2, size: r2 }), e2._queueTotalSize += r2;
}
function we(e2) {
  e2._queue = new v(), e2._queueTotalSize = 0;
}
function Re(e2) {
  return e2 === DataView;
}
class ReadableStreamBYOBRequest {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get view() {
    if (!Ce(this))
      throw Ke("view");
    return this._view;
  }
  respond(e2) {
    if (!Ce(this))
      throw Ke("respond");
    if ($(e2, 1, "respond"), e2 = Q(e2, "First parameter"), void 0 === this._associatedReadableByteStreamController)
      throw new TypeError("This BYOB request has been invalidated");
    if (le(this._view.buffer))
      throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
    Ge(this._associatedReadableByteStreamController, e2);
  }
  respondWithNewView(e2) {
    if (!Ce(this))
      throw Ke("respondWithNewView");
    if ($(e2, 1, "respondWithNewView"), !ArrayBuffer.isView(e2))
      throw new TypeError("You can only respond with array buffer views");
    if (void 0 === this._associatedReadableByteStreamController)
      throw new TypeError("This BYOB request has been invalidated");
    if (le(e2.buffer))
      throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
    Xe(this._associatedReadableByteStreamController, e2);
  }
}
Object.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), o(ReadableStreamBYOBRequest.prototype.respond, "respond"), o(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
class ReadableByteStreamController {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get byobRequest() {
    if (!Te(this))
      throw Ze("byobRequest");
    return Ve(this);
  }
  get desiredSize() {
    if (!Te(this))
      throw Ze("desiredSize");
    return Ue(this);
  }
  close() {
    if (!Te(this))
      throw Ze("close");
    if (this._closeRequested)
      throw new TypeError("The stream has already been closed; do not close it again!");
    const e2 = this._controlledReadableByteStream._state;
    if ("readable" !== e2)
      throw new TypeError(`The stream (in ${e2} state) is not in the readable state and cannot be closed`);
    xe(this);
  }
  enqueue(e2) {
    if (!Te(this))
      throw Ze("enqueue");
    if ($(e2, 1, "enqueue"), !ArrayBuffer.isView(e2))
      throw new TypeError("chunk must be an array buffer view");
    if (0 === e2.byteLength)
      throw new TypeError("chunk must have non-zero byteLength");
    if (0 === e2.buffer.byteLength)
      throw new TypeError("chunk's buffer must have non-zero byteLength");
    if (this._closeRequested)
      throw new TypeError("stream is closed or draining");
    const t2 = this._controlledReadableByteStream._state;
    if ("readable" !== t2)
      throw new TypeError(`The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);
    Qe(this, e2);
  }
  error(e2 = void 0) {
    if (!Te(this))
      throw Ze("error");
    Ne(this, e2);
  }
  [T](e2) {
    qe(this), we(this);
    const t2 = this._cancelAlgorithm(e2);
    return Ye(this), t2;
  }
  [C](e2) {
    const t2 = this._controlledReadableByteStream;
    if (this._queueTotalSize > 0)
      return void He(this, e2);
    const r2 = this._autoAllocateChunkSize;
    if (void 0 !== r2) {
      let t3;
      try {
        t3 = new ArrayBuffer(r2);
      } catch (t4) {
        return void e2._errorSteps(t4);
      }
      const o2 = { buffer: t3, bufferByteLength: r2, byteOffset: 0, byteLength: r2, bytesFilled: 0, minimumFill: 1, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
      this._pendingPullIntos.push(o2);
    }
    V(t2, e2), Pe(this);
  }
  [P]() {
    if (this._pendingPullIntos.length > 0) {
      const e2 = this._pendingPullIntos.peek();
      e2.readerType = "none", this._pendingPullIntos = new v(), this._pendingPullIntos.push(e2);
    }
  }
}
function Te(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableByteStream") && e2 instanceof ReadableByteStreamController);
}
function Ce(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_associatedReadableByteStreamController") && e2 instanceof ReadableStreamBYOBRequest);
}
function Pe(e2) {
  const t2 = function(e3) {
    const t3 = e3._controlledReadableByteStream;
    if ("readable" !== t3._state)
      return false;
    if (e3._closeRequested)
      return false;
    if (!e3._started)
      return false;
    if (X(t3) && G(t3) > 0)
      return true;
    if (nt(t3) && ot(t3) > 0)
      return true;
    const r2 = Ue(e3);
    if (r2 > 0)
      return true;
    return false;
  }(e2);
  if (!t2)
    return;
  if (e2._pulling)
    return void (e2._pullAgain = true);
  e2._pulling = true;
  b(e2._pullAlgorithm(), () => (e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, Pe(e2)), null), (t3) => (Ne(e2, t3), null));
}
function qe(e2) {
  Le(e2), e2._pendingPullIntos = new v();
}
function Ee(e2, t2) {
  let r2 = false;
  "closed" === e2._state && (r2 = true);
  const o2 = Oe(t2);
  "default" === t2.readerType ? U(e2, o2, r2) : function(e3, t3, r3) {
    const o3 = e3._reader, n2 = o3._readIntoRequests.shift();
    r3 ? n2._closeSteps(t3) : n2._chunkSteps(t3);
  }(e2, o2, r2);
}
function We(e2, t2) {
  for (let r2 = 0; r2 < t2.length; ++r2)
    Ee(e2, t2[r2]);
}
function Oe(e2) {
  const t2 = e2.bytesFilled, r2 = e2.elementSize;
  return new e2.viewConstructor(e2.buffer, e2.byteOffset, t2 / r2);
}
function Be(e2, t2, r2, o2) {
  e2._queue.push({ buffer: t2, byteOffset: r2, byteLength: o2 }), e2._queueTotalSize += o2;
}
function ke(e2, t2, r2, o2) {
  let n2;
  try {
    n2 = se(t2, r2, r2 + o2);
  } catch (t3) {
    throw Ne(e2, t3), t3;
  }
  Be(e2, n2, 0, o2);
}
function je(e2, t2) {
  t2.bytesFilled > 0 && ke(e2, t2.buffer, t2.byteOffset, t2.bytesFilled), Me(e2);
}
function Ae(e2, t2) {
  const r2 = Math.min(e2._queueTotalSize, t2.byteLength - t2.bytesFilled), o2 = t2.bytesFilled + r2;
  let n2 = r2, a2 = false;
  const i = o2 - o2 % t2.elementSize;
  i >= t2.minimumFill && (n2 = i - t2.bytesFilled, a2 = true);
  const l2 = e2._queue;
  for (; n2 > 0; ) {
    const r3 = l2.peek(), o3 = Math.min(n2, r3.byteLength), a3 = t2.byteOffset + t2.bytesFilled;
    ae(t2.buffer, a3, r3.buffer, r3.byteOffset, o3), r3.byteLength === o3 ? l2.shift() : (r3.byteOffset += o3, r3.byteLength -= o3), e2._queueTotalSize -= o3, ze(e2, o3, t2), n2 -= o3;
  }
  return a2;
}
function ze(e2, t2, r2) {
  r2.bytesFilled += t2;
}
function De(e2) {
  0 === e2._queueTotalSize && e2._closeRequested ? (Ye(e2), Br(e2._controlledReadableByteStream)) : Pe(e2);
}
function Le(e2) {
  null !== e2._byobRequest && (e2._byobRequest._associatedReadableByteStreamController = void 0, e2._byobRequest._view = null, e2._byobRequest = null);
}
function Fe(e2) {
  const t2 = [];
  for (; e2._pendingPullIntos.length > 0 && 0 !== e2._queueTotalSize; ) {
    const r2 = e2._pendingPullIntos.peek();
    Ae(e2, r2) && (Me(e2), t2.push(r2));
  }
  return t2;
}
function Ie(e2, t2, r2, o2) {
  const n2 = e2._controlledReadableByteStream, a2 = t2.constructor, i = function(e3) {
    return Re(e3) ? 1 : e3.BYTES_PER_ELEMENT;
  }(a2), { byteOffset: l2, byteLength: s2 } = t2, u2 = r2 * i;
  let c2;
  try {
    c2 = ie(t2.buffer);
  } catch (e3) {
    return void o2._errorSteps(e3);
  }
  const d2 = { buffer: c2, bufferByteLength: c2.byteLength, byteOffset: l2, byteLength: s2, bytesFilled: 0, minimumFill: u2, elementSize: i, viewConstructor: a2, readerType: "byob" };
  if (e2._pendingPullIntos.length > 0)
    return e2._pendingPullIntos.push(d2), void rt(n2, o2);
  if ("closed" !== n2._state) {
    if (e2._queueTotalSize > 0) {
      if (Ae(e2, d2)) {
        const t3 = Oe(d2);
        return De(e2), void o2._chunkSteps(t3);
      }
      if (e2._closeRequested) {
        const t3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
        return Ne(e2, t3), void o2._errorSteps(t3);
      }
    }
    e2._pendingPullIntos.push(d2), rt(n2, o2), Pe(e2);
  } else {
    const e3 = new a2(d2.buffer, d2.byteOffset, 0);
    o2._closeSteps(e3);
  }
}
function $e(e2, t2) {
  const r2 = e2._pendingPullIntos.peek();
  Le(e2);
  "closed" === e2._controlledReadableByteStream._state ? function(e3, t3) {
    "none" === t3.readerType && Me(e3);
    const r3 = e3._controlledReadableByteStream;
    if (nt(r3)) {
      const t4 = [];
      for (let o2 = 0; o2 < ot(r3); ++o2)
        t4.push(Me(e3));
      We(r3, t4);
    }
  }(e2, r2) : function(e3, t3, r3) {
    if (ze(0, t3, r3), "none" === r3.readerType) {
      je(e3, r3);
      const t4 = Fe(e3);
      return void We(e3._controlledReadableByteStream, t4);
    }
    if (r3.bytesFilled < r3.minimumFill)
      return;
    Me(e3);
    const o2 = r3.bytesFilled % r3.elementSize;
    if (o2 > 0) {
      const t4 = r3.byteOffset + r3.bytesFilled;
      ke(e3, r3.buffer, t4 - o2, o2);
    }
    r3.bytesFilled -= o2;
    const n2 = Fe(e3);
    Ee(e3._controlledReadableByteStream, r3), We(e3._controlledReadableByteStream, n2);
  }(e2, t2, r2), Pe(e2);
}
function Me(e2) {
  return e2._pendingPullIntos.shift();
}
function Ye(e2) {
  e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0;
}
function xe(e2) {
  const t2 = e2._controlledReadableByteStream;
  if (!e2._closeRequested && "readable" === t2._state)
    if (e2._queueTotalSize > 0)
      e2._closeRequested = true;
    else {
      if (e2._pendingPullIntos.length > 0) {
        const t3 = e2._pendingPullIntos.peek();
        if (t3.bytesFilled % t3.elementSize != 0) {
          const t4 = new TypeError("Insufficient bytes to fill elements in the given buffer");
          throw Ne(e2, t4), t4;
        }
      }
      Ye(e2), Br(t2);
    }
}
function Qe(e2, t2) {
  const r2 = e2._controlledReadableByteStream;
  if (e2._closeRequested || "readable" !== r2._state)
    return;
  const { buffer: o2, byteOffset: n2, byteLength: a2 } = t2;
  if (le(o2))
    throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
  const i = ie(o2);
  if (e2._pendingPullIntos.length > 0) {
    const t3 = e2._pendingPullIntos.peek();
    if (le(t3.buffer))
      throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
    Le(e2), t3.buffer = ie(t3.buffer), "none" === t3.readerType && je(e2, t3);
  }
  if (X(r2))
    if (function(e3) {
      const t3 = e3._controlledReadableByteStream._reader;
      for (; t3._readRequests.length > 0; ) {
        if (0 === e3._queueTotalSize)
          return;
        He(e3, t3._readRequests.shift());
      }
    }(e2), 0 === G(r2))
      Be(e2, i, n2, a2);
    else {
      e2._pendingPullIntos.length > 0 && Me(e2);
      U(r2, new Uint8Array(i, n2, a2), false);
    }
  else if (nt(r2)) {
    Be(e2, i, n2, a2);
    const t3 = Fe(e2);
    We(e2._controlledReadableByteStream, t3);
  } else
    Be(e2, i, n2, a2);
  Pe(e2);
}
function Ne(e2, t2) {
  const r2 = e2._controlledReadableByteStream;
  "readable" === r2._state && (qe(e2), we(e2), Ye(e2), kr(r2, t2));
}
function He(e2, t2) {
  const r2 = e2._queue.shift();
  e2._queueTotalSize -= r2.byteLength, De(e2);
  const o2 = new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  t2._chunkSteps(o2);
}
function Ve(e2) {
  if (null === e2._byobRequest && e2._pendingPullIntos.length > 0) {
    const t2 = e2._pendingPullIntos.peek(), r2 = new Uint8Array(t2.buffer, t2.byteOffset + t2.bytesFilled, t2.byteLength - t2.bytesFilled), o2 = Object.create(ReadableStreamBYOBRequest.prototype);
    !function(e3, t3, r3) {
      e3._associatedReadableByteStreamController = t3, e3._view = r3;
    }(o2, e2, r2), e2._byobRequest = o2;
  }
  return e2._byobRequest;
}
function Ue(e2) {
  const t2 = e2._controlledReadableByteStream._state;
  return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
}
function Ge(e2, t2) {
  const r2 = e2._pendingPullIntos.peek();
  if ("closed" === e2._controlledReadableByteStream._state) {
    if (0 !== t2)
      throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
  } else {
    if (0 === t2)
      throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
    if (r2.bytesFilled + t2 > r2.byteLength)
      throw new RangeError("bytesWritten out of range");
  }
  r2.buffer = ie(r2.buffer), $e(e2, t2);
}
function Xe(e2, t2) {
  const r2 = e2._pendingPullIntos.peek();
  if ("closed" === e2._controlledReadableByteStream._state) {
    if (0 !== t2.byteLength)
      throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
  } else if (0 === t2.byteLength)
    throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
  if (r2.byteOffset + r2.bytesFilled !== t2.byteOffset)
    throw new RangeError("The region specified by view does not match byobRequest");
  if (r2.bufferByteLength !== t2.buffer.byteLength)
    throw new RangeError("The buffer of view has different capacity than byobRequest");
  if (r2.bytesFilled + t2.byteLength > r2.byteLength)
    throw new RangeError("The region specified by view is larger than byobRequest");
  const o2 = t2.byteLength;
  r2.buffer = ie(t2.buffer), $e(e2, o2);
}
function Je(e2, t2, r2, o2, n2, a2, i) {
  t2._controlledReadableByteStream = e2, t2._pullAgain = false, t2._pulling = false, t2._byobRequest = null, t2._queue = t2._queueTotalSize = void 0, we(t2), t2._closeRequested = false, t2._started = false, t2._strategyHWM = a2, t2._pullAlgorithm = o2, t2._cancelAlgorithm = n2, t2._autoAllocateChunkSize = i, t2._pendingPullIntos = new v(), e2._readableStreamController = t2;
  b(c(r2()), () => (t2._started = true, Pe(t2), null), (e3) => (Ne(t2, e3), null));
}
function Ke(e2) {
  return new TypeError(`ReadableStreamBYOBRequest.prototype.${e2} can only be used on a ReadableStreamBYOBRequest`);
}
function Ze(e2) {
  return new TypeError(`ReadableByteStreamController.prototype.${e2} can only be used on a ReadableByteStreamController`);
}
function et(e2, t2) {
  if ("byob" !== (e2 = `${e2}`))
    throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamReaderMode`);
  return e2;
}
function tt(e2) {
  return new ReadableStreamBYOBReader(e2);
}
function rt(e2, t2) {
  e2._reader._readIntoRequests.push(t2);
}
function ot(e2) {
  return e2._reader._readIntoRequests.length;
}
function nt(e2) {
  const t2 = e2._reader;
  return void 0 !== t2 && !!at(t2);
}
Object.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), o(ReadableByteStreamController.prototype.close, "close"), o(ReadableByteStreamController.prototype.enqueue, "enqueue"), o(ReadableByteStreamController.prototype.error, "error"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, { value: "ReadableByteStreamController", configurable: true });
class ReadableStreamBYOBReader {
  constructor(e2) {
    if ($(e2, 1, "ReadableStreamBYOBReader"), N(e2, "First parameter"), Wr(e2))
      throw new TypeError("This stream has already been locked for exclusive reading by another reader");
    if (!Te(e2._readableStreamController))
      throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
    q(this, e2), this._readIntoRequests = new v();
  }
  get closed() {
    return at(this) ? this._closedPromise : d(st("closed"));
  }
  cancel(e2 = void 0) {
    return at(this) ? void 0 === this._ownerReadableStream ? d(O("cancel")) : E(this, e2) : d(st("cancel"));
  }
  read(e2, t2 = {}) {
    if (!at(this))
      return d(st("read"));
    if (!ArrayBuffer.isView(e2))
      return d(new TypeError("view must be an array buffer view"));
    if (0 === e2.byteLength)
      return d(new TypeError("view must have non-zero byteLength"));
    if (0 === e2.buffer.byteLength)
      return d(new TypeError("view's buffer must have non-zero byteLength"));
    if (le(e2.buffer))
      return d(new TypeError("view's buffer has been detached"));
    let r2;
    try {
      r2 = function(e3, t3) {
        var r3;
        return L(e3, t3), { min: Q(null !== (r3 = null == e3 ? void 0 : e3.min) && void 0 !== r3 ? r3 : 1, `${t3} has member 'min' that`) };
      }(t2, "options");
    } catch (e3) {
      return d(e3);
    }
    const o2 = r2.min;
    if (0 === o2)
      return d(new TypeError("options.min must be greater than 0"));
    if (function(e3) {
      return Re(e3.constructor);
    }(e2)) {
      if (o2 > e2.byteLength)
        return d(new RangeError("options.min must be less than or equal to view's byteLength"));
    } else if (o2 > e2.length)
      return d(new RangeError("options.min must be less than or equal to view's length"));
    if (void 0 === this._ownerReadableStream)
      return d(O("read from"));
    let n2, a2;
    const i = u((e3, t3) => {
      n2 = e3, a2 = t3;
    });
    return it(this, e2, o2, { _chunkSteps: (e3) => n2({ value: e3, done: false }), _closeSteps: (e3) => n2({ value: e3, done: true }), _errorSteps: (e3) => a2(e3) }), i;
  }
  releaseLock() {
    if (!at(this))
      throw st("releaseLock");
    void 0 !== this._ownerReadableStream && function(e2) {
      W(e2);
      const t2 = new TypeError("Reader was released");
      lt(e2, t2);
    }(this);
  }
}
function at(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readIntoRequests") && e2 instanceof ReadableStreamBYOBReader);
}
function it(e2, t2, r2, o2) {
  const n2 = e2._ownerReadableStream;
  n2._disturbed = true, "errored" === n2._state ? o2._errorSteps(n2._storedError) : Ie(n2._readableStreamController, t2, r2, o2);
}
function lt(e2, t2) {
  const r2 = e2._readIntoRequests;
  e2._readIntoRequests = new v(), r2.forEach((e3) => {
    e3._errorSteps(t2);
  });
}
function st(e2) {
  return new TypeError(`ReadableStreamBYOBReader.prototype.${e2} can only be used on a ReadableStreamBYOBReader`);
}
function ut(e2, t2) {
  const { highWaterMark: r2 } = e2;
  if (void 0 === r2)
    return t2;
  if (ye(r2) || r2 < 0)
    throw new RangeError("Invalid highWaterMark");
  return r2;
}
function ct(e2) {
  const { size: t2 } = e2;
  return t2 || (() => 1);
}
function dt(e2, t2) {
  L(e2, t2);
  const r2 = null == e2 ? void 0 : e2.highWaterMark, o2 = null == e2 ? void 0 : e2.size;
  return { highWaterMark: void 0 === r2 ? void 0 : Y(r2), size: void 0 === o2 ? void 0 : ft(o2, `${t2} has member 'size' that`) };
}
function ft(e2, t2) {
  return F(e2, t2), (t3) => Y(e2(t3));
}
function bt(e2, t2, r2) {
  return F(e2, r2), (r3) => g(e2, t2, [r3]);
}
function ht(e2, t2, r2) {
  return F(e2, r2), () => g(e2, t2, []);
}
function mt(e2, t2, r2) {
  return F(e2, r2), (r3) => S(e2, t2, [r3]);
}
function _t(e2, t2, r2) {
  return F(e2, r2), (r3, o2) => g(e2, t2, [r3, o2]);
}
function pt(e2, t2) {
  if (!gt(e2))
    throw new TypeError(`${t2} is not a WritableStream.`);
}
Object.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), o(ReadableStreamBYOBReader.prototype.cancel, "cancel"), o(ReadableStreamBYOBReader.prototype.read, "read"), o(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
class WritableStream {
  constructor(e2 = {}, t2 = {}) {
    void 0 === e2 ? e2 = null : I(e2, "First parameter");
    const r2 = dt(t2, "Second parameter"), o2 = function(e3, t3) {
      L(e3, t3);
      const r3 = null == e3 ? void 0 : e3.abort, o3 = null == e3 ? void 0 : e3.close, n3 = null == e3 ? void 0 : e3.start, a2 = null == e3 ? void 0 : e3.type, i = null == e3 ? void 0 : e3.write;
      return { abort: void 0 === r3 ? void 0 : bt(r3, e3, `${t3} has member 'abort' that`), close: void 0 === o3 ? void 0 : ht(o3, e3, `${t3} has member 'close' that`), start: void 0 === n3 ? void 0 : mt(n3, e3, `${t3} has member 'start' that`), write: void 0 === i ? void 0 : _t(i, e3, `${t3} has member 'write' that`), type: a2 };
    }(e2, "First parameter");
    St(this);
    if (void 0 !== o2.type)
      throw new RangeError("Invalid type is specified");
    const n2 = ct(r2);
    !function(e3, t3, r3, o3) {
      const n3 = Object.create(WritableStreamDefaultController.prototype);
      let a2, i, l2, s2;
      a2 = void 0 !== t3.start ? () => t3.start(n3) : () => {
      };
      i = void 0 !== t3.write ? (e4) => t3.write(e4, n3) : () => c(void 0);
      l2 = void 0 !== t3.close ? () => t3.close() : () => c(void 0);
      s2 = void 0 !== t3.abort ? (e4) => t3.abort(e4) : () => c(void 0);
      Ft(e3, n3, a2, i, l2, s2, r3, o3);
    }(this, o2, ut(r2, 1), n2);
  }
  get locked() {
    if (!gt(this))
      throw Nt("locked");
    return vt(this);
  }
  abort(e2 = void 0) {
    return gt(this) ? vt(this) ? d(new TypeError("Cannot abort a stream that already has a writer")) : wt(this, e2) : d(Nt("abort"));
  }
  close() {
    return gt(this) ? vt(this) ? d(new TypeError("Cannot close a stream that already has a writer")) : qt(this) ? d(new TypeError("Cannot close an already-closing stream")) : Rt(this) : d(Nt("close"));
  }
  getWriter() {
    if (!gt(this))
      throw Nt("getWriter");
    return yt(this);
  }
}
function yt(e2) {
  return new WritableStreamDefaultWriter(e2);
}
function St(e2) {
  e2._state = "writable", e2._storedError = void 0, e2._writer = void 0, e2._writableStreamController = void 0, e2._writeRequests = new v(), e2._inFlightWriteRequest = void 0, e2._closeRequest = void 0, e2._inFlightCloseRequest = void 0, e2._pendingAbortRequest = void 0, e2._backpressure = false;
}
function gt(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_writableStreamController") && e2 instanceof WritableStream);
}
function vt(e2) {
  return void 0 !== e2._writer;
}
function wt(e2, t2) {
  var r2;
  if ("closed" === e2._state || "errored" === e2._state)
    return c(void 0);
  e2._writableStreamController._abortReason = t2, null === (r2 = e2._writableStreamController._abortController) || void 0 === r2 || r2.abort(t2);
  const o2 = e2._state;
  if ("closed" === o2 || "errored" === o2)
    return c(void 0);
  if (void 0 !== e2._pendingAbortRequest)
    return e2._pendingAbortRequest._promise;
  let n2 = false;
  "erroring" === o2 && (n2 = true, t2 = void 0);
  const a2 = u((r3, o3) => {
    e2._pendingAbortRequest = { _promise: void 0, _resolve: r3, _reject: o3, _reason: t2, _wasAlreadyErroring: n2 };
  });
  return e2._pendingAbortRequest._promise = a2, n2 || Ct(e2, t2), a2;
}
function Rt(e2) {
  const t2 = e2._state;
  if ("closed" === t2 || "errored" === t2)
    return d(new TypeError(`The stream (in ${t2} state) is not in the writable state and cannot be closed`));
  const r2 = u((t3, r3) => {
    const o3 = { _resolve: t3, _reject: r3 };
    e2._closeRequest = o3;
  }), o2 = e2._writer;
  var n2;
  return void 0 !== o2 && e2._backpressure && "writable" === t2 && or(o2), ve(n2 = e2._writableStreamController, Dt, 0), Mt(n2), r2;
}
function Tt(e2, t2) {
  "writable" !== e2._state ? Pt(e2) : Ct(e2, t2);
}
function Ct(e2, t2) {
  const r2 = e2._writableStreamController;
  e2._state = "erroring", e2._storedError = t2;
  const o2 = e2._writer;
  void 0 !== o2 && jt(o2, t2), !function(e3) {
    if (void 0 === e3._inFlightWriteRequest && void 0 === e3._inFlightCloseRequest)
      return false;
    return true;
  }(e2) && r2._started && Pt(e2);
}
function Pt(e2) {
  e2._state = "errored", e2._writableStreamController[R]();
  const t2 = e2._storedError;
  if (e2._writeRequests.forEach((e3) => {
    e3._reject(t2);
  }), e2._writeRequests = new v(), void 0 === e2._pendingAbortRequest)
    return void Et(e2);
  const r2 = e2._pendingAbortRequest;
  if (e2._pendingAbortRequest = void 0, r2._wasAlreadyErroring)
    return r2._reject(t2), void Et(e2);
  b(e2._writableStreamController[w](r2._reason), () => (r2._resolve(), Et(e2), null), (t3) => (r2._reject(t3), Et(e2), null));
}
function qt(e2) {
  return void 0 !== e2._closeRequest || void 0 !== e2._inFlightCloseRequest;
}
function Et(e2) {
  void 0 !== e2._closeRequest && (e2._closeRequest._reject(e2._storedError), e2._closeRequest = void 0);
  const t2 = e2._writer;
  void 0 !== t2 && Jt(t2, e2._storedError);
}
function Wt(e2, t2) {
  const r2 = e2._writer;
  void 0 !== r2 && t2 !== e2._backpressure && (t2 ? function(e3) {
    Zt(e3);
  }(r2) : or(r2)), e2._backpressure = t2;
}
Object.defineProperties(WritableStream.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), o(WritableStream.prototype.abort, "abort"), o(WritableStream.prototype.close, "close"), o(WritableStream.prototype.getWriter, "getWriter"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, { value: "WritableStream", configurable: true });
class WritableStreamDefaultWriter {
  constructor(e2) {
    if ($(e2, 1, "WritableStreamDefaultWriter"), pt(e2, "First parameter"), vt(e2))
      throw new TypeError("This stream has already been locked for exclusive writing by another writer");
    this._ownerWritableStream = e2, e2._writer = this;
    const t2 = e2._state;
    if ("writable" === t2)
      !qt(e2) && e2._backpressure ? Zt(this) : tr(this), Gt(this);
    else if ("erroring" === t2)
      er(this, e2._storedError), Gt(this);
    else if ("closed" === t2)
      tr(this), Gt(r2 = this), Kt(r2);
    else {
      const t3 = e2._storedError;
      er(this, t3), Xt(this, t3);
    }
    var r2;
  }
  get closed() {
    return Ot(this) ? this._closedPromise : d(Vt("closed"));
  }
  get desiredSize() {
    if (!Ot(this))
      throw Vt("desiredSize");
    if (void 0 === this._ownerWritableStream)
      throw Ut("desiredSize");
    return function(e2) {
      const t2 = e2._ownerWritableStream, r2 = t2._state;
      if ("errored" === r2 || "erroring" === r2)
        return null;
      if ("closed" === r2)
        return 0;
      return $t(t2._writableStreamController);
    }(this);
  }
  get ready() {
    return Ot(this) ? this._readyPromise : d(Vt("ready"));
  }
  abort(e2 = void 0) {
    return Ot(this) ? void 0 === this._ownerWritableStream ? d(Ut("abort")) : function(e3, t2) {
      return wt(e3._ownerWritableStream, t2);
    }(this, e2) : d(Vt("abort"));
  }
  close() {
    if (!Ot(this))
      return d(Vt("close"));
    const e2 = this._ownerWritableStream;
    return void 0 === e2 ? d(Ut("close")) : qt(e2) ? d(new TypeError("Cannot close an already-closing stream")) : Bt(this);
  }
  releaseLock() {
    if (!Ot(this))
      throw Vt("releaseLock");
    void 0 !== this._ownerWritableStream && At(this);
  }
  write(e2 = void 0) {
    return Ot(this) ? void 0 === this._ownerWritableStream ? d(Ut("write to")) : zt(this, e2) : d(Vt("write"));
  }
}
function Ot(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_ownerWritableStream") && e2 instanceof WritableStreamDefaultWriter);
}
function Bt(e2) {
  return Rt(e2._ownerWritableStream);
}
function kt(e2, t2) {
  "pending" === e2._closedPromiseState ? Jt(e2, t2) : function(e3, t3) {
    Xt(e3, t3);
  }(e2, t2);
}
function jt(e2, t2) {
  "pending" === e2._readyPromiseState ? rr(e2, t2) : function(e3, t3) {
    er(e3, t3);
  }(e2, t2);
}
function At(e2) {
  const t2 = e2._ownerWritableStream, r2 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
  jt(e2, r2), kt(e2, r2), t2._writer = void 0, e2._ownerWritableStream = void 0;
}
function zt(e2, t2) {
  const r2 = e2._ownerWritableStream, o2 = r2._writableStreamController, n2 = function(e3, t3) {
    if (void 0 === e3._strategySizeAlgorithm)
      return 1;
    try {
      return e3._strategySizeAlgorithm(t3);
    } catch (t4) {
      return Yt(e3, t4), 1;
    }
  }(o2, t2);
  if (r2 !== e2._ownerWritableStream)
    return d(Ut("write to"));
  const a2 = r2._state;
  if ("errored" === a2)
    return d(r2._storedError);
  if (qt(r2) || "closed" === a2)
    return d(new TypeError("The stream is closing or closed and cannot be written to"));
  if ("erroring" === a2)
    return d(r2._storedError);
  const i = function(e3) {
    return u((t3, r3) => {
      const o3 = { _resolve: t3, _reject: r3 };
      e3._writeRequests.push(o3);
    });
  }(r2);
  return function(e3, t3, r3) {
    try {
      ve(e3, t3, r3);
    } catch (t4) {
      return void Yt(e3, t4);
    }
    const o3 = e3._controlledWritableStream;
    if (!qt(o3) && "writable" === o3._state) {
      Wt(o3, xt(e3));
    }
    Mt(e3);
  }(o2, t2, n2), i;
}
Object.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), o(WritableStreamDefaultWriter.prototype.abort, "abort"), o(WritableStreamDefaultWriter.prototype.close, "close"), o(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock"), o(WritableStreamDefaultWriter.prototype.write, "write"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
const Dt = {};
class WritableStreamDefaultController {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get abortReason() {
    if (!Lt(this))
      throw Ht("abortReason");
    return this._abortReason;
  }
  get signal() {
    if (!Lt(this))
      throw Ht("signal");
    if (void 0 === this._abortController)
      throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
    return this._abortController.signal;
  }
  error(e2 = void 0) {
    if (!Lt(this))
      throw Ht("error");
    "writable" === this._controlledWritableStream._state && Qt(this, e2);
  }
  [w](e2) {
    const t2 = this._abortAlgorithm(e2);
    return It(this), t2;
  }
  [R]() {
    we(this);
  }
}
function Lt(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledWritableStream") && e2 instanceof WritableStreamDefaultController);
}
function Ft(e2, t2, r2, o2, n2, a2, i, l2) {
  t2._controlledWritableStream = e2, e2._writableStreamController = t2, t2._queue = void 0, t2._queueTotalSize = void 0, we(t2), t2._abortReason = void 0, t2._abortController = function() {
    if ("function" == typeof AbortController)
      return new AbortController();
  }(), t2._started = false, t2._strategySizeAlgorithm = l2, t2._strategyHWM = i, t2._writeAlgorithm = o2, t2._closeAlgorithm = n2, t2._abortAlgorithm = a2;
  const s2 = xt(t2);
  Wt(e2, s2);
  b(c(r2()), () => (t2._started = true, Mt(t2), null), (r3) => (t2._started = true, Tt(e2, r3), null));
}
function It(e2) {
  e2._writeAlgorithm = void 0, e2._closeAlgorithm = void 0, e2._abortAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
}
function $t(e2) {
  return e2._strategyHWM - e2._queueTotalSize;
}
function Mt(e2) {
  const t2 = e2._controlledWritableStream;
  if (!e2._started)
    return;
  if (void 0 !== t2._inFlightWriteRequest)
    return;
  if ("erroring" === t2._state)
    return void Pt(t2);
  if (0 === e2._queue.length)
    return;
  const r2 = e2._queue.peek().value;
  r2 === Dt ? function(e3) {
    const t3 = e3._controlledWritableStream;
    (function(e4) {
      e4._inFlightCloseRequest = e4._closeRequest, e4._closeRequest = void 0;
    })(t3), ge(e3);
    const r3 = e3._closeAlgorithm();
    It(e3), b(r3, () => (function(e4) {
      e4._inFlightCloseRequest._resolve(void 0), e4._inFlightCloseRequest = void 0, "erroring" === e4._state && (e4._storedError = void 0, void 0 !== e4._pendingAbortRequest && (e4._pendingAbortRequest._resolve(), e4._pendingAbortRequest = void 0)), e4._state = "closed";
      const t4 = e4._writer;
      void 0 !== t4 && Kt(t4);
    }(t3), null), (e4) => (function(e5, t4) {
      e5._inFlightCloseRequest._reject(t4), e5._inFlightCloseRequest = void 0, void 0 !== e5._pendingAbortRequest && (e5._pendingAbortRequest._reject(t4), e5._pendingAbortRequest = void 0), Tt(e5, t4);
    }(t3, e4), null));
  }(e2) : function(e3, t3) {
    const r3 = e3._controlledWritableStream;
    !function(e4) {
      e4._inFlightWriteRequest = e4._writeRequests.shift();
    }(r3);
    const o2 = e3._writeAlgorithm(t3);
    b(o2, () => {
      !function(e4) {
        e4._inFlightWriteRequest._resolve(void 0), e4._inFlightWriteRequest = void 0;
      }(r3);
      const t4 = r3._state;
      if (ge(e3), !qt(r3) && "writable" === t4) {
        const t5 = xt(e3);
        Wt(r3, t5);
      }
      return Mt(e3), null;
    }, (t4) => ("writable" === r3._state && It(e3), function(e4, t5) {
      e4._inFlightWriteRequest._reject(t5), e4._inFlightWriteRequest = void 0, Tt(e4, t5);
    }(r3, t4), null));
  }(e2, r2);
}
function Yt(e2, t2) {
  "writable" === e2._controlledWritableStream._state && Qt(e2, t2);
}
function xt(e2) {
  return $t(e2) <= 0;
}
function Qt(e2, t2) {
  const r2 = e2._controlledWritableStream;
  It(e2), Ct(r2, t2);
}
function Nt(e2) {
  return new TypeError(`WritableStream.prototype.${e2} can only be used on a WritableStream`);
}
function Ht(e2) {
  return new TypeError(`WritableStreamDefaultController.prototype.${e2} can only be used on a WritableStreamDefaultController`);
}
function Vt(e2) {
  return new TypeError(`WritableStreamDefaultWriter.prototype.${e2} can only be used on a WritableStreamDefaultWriter`);
}
function Ut(e2) {
  return new TypeError("Cannot " + e2 + " a stream using a released writer");
}
function Gt(e2) {
  e2._closedPromise = u((t2, r2) => {
    e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2, e2._closedPromiseState = "pending";
  });
}
function Xt(e2, t2) {
  Gt(e2), Jt(e2, t2);
}
function Jt(e2, t2) {
  void 0 !== e2._closedPromise_reject && (p(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "rejected");
}
function Kt(e2) {
  void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "resolved");
}
function Zt(e2) {
  e2._readyPromise = u((t2, r2) => {
    e2._readyPromise_resolve = t2, e2._readyPromise_reject = r2;
  }), e2._readyPromiseState = "pending";
}
function er(e2, t2) {
  Zt(e2), rr(e2, t2);
}
function tr(e2) {
  Zt(e2), or(e2);
}
function rr(e2, t2) {
  void 0 !== e2._readyPromise_reject && (p(e2._readyPromise), e2._readyPromise_reject(t2), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "rejected");
}
function or(e2) {
  void 0 !== e2._readyPromise_resolve && (e2._readyPromise_resolve(void 0), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "fulfilled");
}
Object.defineProperties(WritableStreamDefaultController.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
const nr = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof global ? global : void 0;
const ar = function() {
  const e2 = null == nr ? void 0 : nr.DOMException;
  return function(e3) {
    if ("function" != typeof e3 && "object" != typeof e3)
      return false;
    if ("DOMException" !== e3.name)
      return false;
    try {
      return new e3(), true;
    } catch (e4) {
      return false;
    }
  }(e2) ? e2 : void 0;
}() || function() {
  const e2 = function(e3, t2) {
    this.message = e3 || "", this.name = t2 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  };
  return o(e2, "DOMException"), e2.prototype = Object.create(Error.prototype), Object.defineProperty(e2.prototype, "constructor", { value: e2, writable: true, configurable: true }), e2;
}();
function ir(t2, r2, o2, n2, a2, i) {
  const l2 = H(t2), s2 = yt(r2);
  t2._disturbed = true;
  let _2 = false, y2 = c(void 0);
  return u((S2, g2) => {
    let v2;
    if (void 0 !== i) {
      if (v2 = () => {
        const e2 = void 0 !== i.reason ? i.reason : new ar("Aborted", "AbortError"), o3 = [];
        n2 || o3.push(() => "writable" === r2._state ? wt(r2, e2) : c(void 0)), a2 || o3.push(() => "readable" === t2._state ? Or(t2, e2) : c(void 0)), q2(() => Promise.all(o3.map((e3) => e3())), true, e2);
      }, i.aborted)
        return void v2();
      i.addEventListener("abort", v2);
    }
    var w2, R2, T2;
    if (P2(t2, l2._closedPromise, (e2) => (n2 ? E2(true, e2) : q2(() => wt(r2, e2), true, e2), null)), P2(r2, s2._closedPromise, (e2) => (a2 ? E2(true, e2) : q2(() => Or(t2, e2), true, e2), null)), w2 = t2, R2 = l2._closedPromise, T2 = () => (o2 ? E2() : q2(() => function(e2) {
      const t3 = e2._ownerWritableStream, r3 = t3._state;
      return qt(t3) || "closed" === r3 ? c(void 0) : "errored" === r3 ? d(t3._storedError) : Bt(e2);
    }(s2)), null), "closed" === w2._state ? T2() : h(R2, T2), qt(r2) || "closed" === r2._state) {
      const e2 = new TypeError("the destination writable stream closed before all data could be piped to it");
      a2 ? E2(true, e2) : q2(() => Or(t2, e2), true, e2);
    }
    function C2() {
      const e2 = y2;
      return f(y2, () => e2 !== y2 ? C2() : void 0);
    }
    function P2(e2, t3, r3) {
      "errored" === e2._state ? r3(e2._storedError) : m(t3, r3);
    }
    function q2(e2, t3, o3) {
      function n3() {
        return b(e2(), () => O2(t3, o3), (e3) => O2(true, e3)), null;
      }
      _2 || (_2 = true, "writable" !== r2._state || qt(r2) ? n3() : h(C2(), n3));
    }
    function E2(e2, t3) {
      _2 || (_2 = true, "writable" !== r2._state || qt(r2) ? O2(e2, t3) : h(C2(), () => O2(e2, t3)));
    }
    function O2(e2, t3) {
      return At(s2), W(l2), void 0 !== i && i.removeEventListener("abort", v2), e2 ? g2(t3) : S2(void 0), null;
    }
    p(u((t3, r3) => {
      !function o3(n3) {
        n3 ? t3() : f(_2 ? c(true) : f(s2._readyPromise, () => u((t4, r4) => {
          K(l2, { _chunkSteps: (r5) => {
            y2 = f(zt(s2, r5), void 0, e), t4(false);
          }, _closeSteps: () => t4(true), _errorSteps: r4 });
        })), o3, r3);
      }(false);
    }));
  });
}
class ReadableStreamDefaultController {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get desiredSize() {
    if (!lr(this))
      throw pr("desiredSize");
    return hr(this);
  }
  close() {
    if (!lr(this))
      throw pr("close");
    if (!mr(this))
      throw new TypeError("The stream is not in a state that permits close");
    dr(this);
  }
  enqueue(e2 = void 0) {
    if (!lr(this))
      throw pr("enqueue");
    if (!mr(this))
      throw new TypeError("The stream is not in a state that permits enqueue");
    return fr(this, e2);
  }
  error(e2 = void 0) {
    if (!lr(this))
      throw pr("error");
    br(this, e2);
  }
  [T](e2) {
    we(this);
    const t2 = this._cancelAlgorithm(e2);
    return cr(this), t2;
  }
  [C](e2) {
    const t2 = this._controlledReadableStream;
    if (this._queue.length > 0) {
      const r2 = ge(this);
      this._closeRequested && 0 === this._queue.length ? (cr(this), Br(t2)) : sr(this), e2._chunkSteps(r2);
    } else
      V(t2, e2), sr(this);
  }
  [P]() {
  }
}
function lr(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableStream") && e2 instanceof ReadableStreamDefaultController);
}
function sr(e2) {
  if (!ur(e2))
    return;
  if (e2._pulling)
    return void (e2._pullAgain = true);
  e2._pulling = true;
  b(e2._pullAlgorithm(), () => (e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, sr(e2)), null), (t2) => (br(e2, t2), null));
}
function ur(e2) {
  const t2 = e2._controlledReadableStream;
  if (!mr(e2))
    return false;
  if (!e2._started)
    return false;
  if (Wr(t2) && G(t2) > 0)
    return true;
  return hr(e2) > 0;
}
function cr(e2) {
  e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
}
function dr(e2) {
  if (!mr(e2))
    return;
  const t2 = e2._controlledReadableStream;
  e2._closeRequested = true, 0 === e2._queue.length && (cr(e2), Br(t2));
}
function fr(e2, t2) {
  if (!mr(e2))
    return;
  const r2 = e2._controlledReadableStream;
  if (Wr(r2) && G(r2) > 0)
    U(r2, t2, false);
  else {
    let r3;
    try {
      r3 = e2._strategySizeAlgorithm(t2);
    } catch (t3) {
      throw br(e2, t3), t3;
    }
    try {
      ve(e2, t2, r3);
    } catch (t3) {
      throw br(e2, t3), t3;
    }
  }
  sr(e2);
}
function br(e2, t2) {
  const r2 = e2._controlledReadableStream;
  "readable" === r2._state && (we(e2), cr(e2), kr(r2, t2));
}
function hr(e2) {
  const t2 = e2._controlledReadableStream._state;
  return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
}
function mr(e2) {
  const t2 = e2._controlledReadableStream._state;
  return !e2._closeRequested && "readable" === t2;
}
function _r(e2, t2, r2, o2, n2, a2, i) {
  t2._controlledReadableStream = e2, t2._queue = void 0, t2._queueTotalSize = void 0, we(t2), t2._started = false, t2._closeRequested = false, t2._pullAgain = false, t2._pulling = false, t2._strategySizeAlgorithm = i, t2._strategyHWM = a2, t2._pullAlgorithm = o2, t2._cancelAlgorithm = n2, e2._readableStreamController = t2;
  b(c(r2()), () => (t2._started = true, sr(t2), null), (e3) => (br(t2, e3), null));
}
function pr(e2) {
  return new TypeError(`ReadableStreamDefaultController.prototype.${e2} can only be used on a ReadableStreamDefaultController`);
}
function yr(e2, t2) {
  return Te(e2._readableStreamController) ? function(e3) {
    let t3, r2, o2, n2, a2, i = H(e3), l2 = false, s2 = false, d2 = false, f2 = false, b2 = false;
    const h2 = u((e4) => {
      a2 = e4;
    });
    function _2(e4) {
      m(e4._closedPromise, (t4) => (e4 !== i || (Ne(o2._readableStreamController, t4), Ne(n2._readableStreamController, t4), f2 && b2 || a2(void 0)), null));
    }
    function p2() {
      at(i) && (W(i), i = H(e3), _2(i));
      K(i, { _chunkSteps: (t4) => {
        y(() => {
          s2 = false, d2 = false;
          const r3 = t4;
          let i2 = t4;
          if (!f2 && !b2)
            try {
              i2 = Se(t4);
            } catch (t5) {
              return Ne(o2._readableStreamController, t5), Ne(n2._readableStreamController, t5), void a2(Or(e3, t5));
            }
          f2 || Qe(o2._readableStreamController, r3), b2 || Qe(n2._readableStreamController, i2), l2 = false, s2 ? g2() : d2 && v2();
        });
      }, _closeSteps: () => {
        l2 = false, f2 || xe(o2._readableStreamController), b2 || xe(n2._readableStreamController), o2._readableStreamController._pendingPullIntos.length > 0 && Ge(o2._readableStreamController, 0), n2._readableStreamController._pendingPullIntos.length > 0 && Ge(n2._readableStreamController, 0), f2 && b2 || a2(void 0);
      }, _errorSteps: () => {
        l2 = false;
      } });
    }
    function S2(t4, r3) {
      J(i) && (W(i), i = tt(e3), _2(i));
      const u2 = r3 ? n2 : o2, c2 = r3 ? o2 : n2;
      it(i, t4, 1, { _chunkSteps: (t5) => {
        y(() => {
          s2 = false, d2 = false;
          const o3 = r3 ? b2 : f2;
          if (r3 ? f2 : b2)
            o3 || Xe(u2._readableStreamController, t5);
          else {
            let r4;
            try {
              r4 = Se(t5);
            } catch (t6) {
              return Ne(u2._readableStreamController, t6), Ne(c2._readableStreamController, t6), void a2(Or(e3, t6));
            }
            o3 || Xe(u2._readableStreamController, t5), Qe(c2._readableStreamController, r4);
          }
          l2 = false, s2 ? g2() : d2 && v2();
        });
      }, _closeSteps: (e4) => {
        l2 = false;
        const t5 = r3 ? b2 : f2, o3 = r3 ? f2 : b2;
        t5 || xe(u2._readableStreamController), o3 || xe(c2._readableStreamController), void 0 !== e4 && (t5 || Xe(u2._readableStreamController, e4), !o3 && c2._readableStreamController._pendingPullIntos.length > 0 && Ge(c2._readableStreamController, 0)), t5 && o3 || a2(void 0);
      }, _errorSteps: () => {
        l2 = false;
      } });
    }
    function g2() {
      if (l2)
        return s2 = true, c(void 0);
      l2 = true;
      const e4 = Ve(o2._readableStreamController);
      return null === e4 ? p2() : S2(e4._view, false), c(void 0);
    }
    function v2() {
      if (l2)
        return d2 = true, c(void 0);
      l2 = true;
      const e4 = Ve(n2._readableStreamController);
      return null === e4 ? p2() : S2(e4._view, true), c(void 0);
    }
    function w2(o3) {
      if (f2 = true, t3 = o3, b2) {
        const o4 = ne([t3, r2]), n3 = Or(e3, o4);
        a2(n3);
      }
      return h2;
    }
    function R2(o3) {
      if (b2 = true, r2 = o3, f2) {
        const o4 = ne([t3, r2]), n3 = Or(e3, o4);
        a2(n3);
      }
      return h2;
    }
    function T2() {
    }
    return o2 = Pr(T2, g2, w2), n2 = Pr(T2, v2, R2), _2(i), [o2, n2];
  }(e2) : function(e3, t3) {
    const r2 = H(e3);
    let o2, n2, a2, i, l2, s2 = false, d2 = false, f2 = false, b2 = false;
    const h2 = u((e4) => {
      l2 = e4;
    });
    function _2() {
      if (s2)
        return d2 = true, c(void 0);
      s2 = true;
      return K(r2, { _chunkSteps: (e4) => {
        y(() => {
          d2 = false;
          const t4 = e4, r3 = e4;
          f2 || fr(a2._readableStreamController, t4), b2 || fr(i._readableStreamController, r3), s2 = false, d2 && _2();
        });
      }, _closeSteps: () => {
        s2 = false, f2 || dr(a2._readableStreamController), b2 || dr(i._readableStreamController), f2 && b2 || l2(void 0);
      }, _errorSteps: () => {
        s2 = false;
      } }), c(void 0);
    }
    function p2(t4) {
      if (f2 = true, o2 = t4, b2) {
        const t5 = ne([o2, n2]), r3 = Or(e3, t5);
        l2(r3);
      }
      return h2;
    }
    function S2(t4) {
      if (b2 = true, n2 = t4, f2) {
        const t5 = ne([o2, n2]), r3 = Or(e3, t5);
        l2(r3);
      }
      return h2;
    }
    function g2() {
    }
    return a2 = Cr(g2, _2, p2), i = Cr(g2, _2, S2), m(r2._closedPromise, (e4) => (br(a2._readableStreamController, e4), br(i._readableStreamController, e4), f2 && b2 || l2(void 0), null)), [a2, i];
  }(e2);
}
function Sr(r2) {
  return t(o2 = r2) && void 0 !== o2.getReader ? function(r3) {
    let o3;
    function n2() {
      let e2;
      try {
        e2 = r3.read();
      } catch (e3) {
        return d(e3);
      }
      return _(e2, (e3) => {
        if (!t(e3))
          throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
        if (e3.done)
          dr(o3._readableStreamController);
        else {
          const t2 = e3.value;
          fr(o3._readableStreamController, t2);
        }
      });
    }
    function a2(e2) {
      try {
        return c(r3.cancel(e2));
      } catch (e3) {
        return d(e3);
      }
    }
    return o3 = Cr(e, n2, a2, 0), o3;
  }(r2.getReader()) : function(r3) {
    let o3;
    const n2 = fe(r3, "async");
    function a2() {
      let e2;
      try {
        e2 = be(n2);
      } catch (e3) {
        return d(e3);
      }
      return _(c(e2), (e3) => {
        if (!t(e3))
          throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
        if (e3.done)
          dr(o3._readableStreamController);
        else {
          const t2 = e3.value;
          fr(o3._readableStreamController, t2);
        }
      });
    }
    function i(e2) {
      const r4 = n2.iterator;
      let o4;
      try {
        o4 = ue(r4, "return");
      } catch (e3) {
        return d(e3);
      }
      if (void 0 === o4)
        return c(void 0);
      return _(g(o4, r4, [e2]), (e3) => {
        if (!t(e3))
          throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
      });
    }
    return o3 = Cr(e, a2, i, 0), o3;
  }(r2);
  var o2;
}
function gr(e2, t2, r2) {
  return F(e2, r2), (r3) => g(e2, t2, [r3]);
}
function vr(e2, t2, r2) {
  return F(e2, r2), (r3) => g(e2, t2, [r3]);
}
function wr(e2, t2, r2) {
  return F(e2, r2), (r3) => S(e2, t2, [r3]);
}
function Rr(e2, t2) {
  if ("bytes" !== (e2 = `${e2}`))
    throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamType`);
  return e2;
}
function Tr(e2, t2) {
  L(e2, t2);
  const r2 = null == e2 ? void 0 : e2.preventAbort, o2 = null == e2 ? void 0 : e2.preventCancel, n2 = null == e2 ? void 0 : e2.preventClose, a2 = null == e2 ? void 0 : e2.signal;
  return void 0 !== a2 && function(e3, t3) {
    if (!function(e4) {
      if ("object" != typeof e4 || null === e4)
        return false;
      try {
        return "boolean" == typeof e4.aborted;
      } catch (e5) {
        return false;
      }
    }(e3))
      throw new TypeError(`${t3} is not an AbortSignal.`);
  }(a2, `${t2} has member 'signal' that`), { preventAbort: Boolean(r2), preventCancel: Boolean(o2), preventClose: Boolean(n2), signal: a2 };
}
Object.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), o(ReadableStreamDefaultController.prototype.close, "close"), o(ReadableStreamDefaultController.prototype.enqueue, "enqueue"), o(ReadableStreamDefaultController.prototype.error, "error"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
let ReadableStream$2 = class ReadableStream2 {
  constructor(e2 = {}, t2 = {}) {
    void 0 === e2 ? e2 = null : I(e2, "First parameter");
    const r2 = dt(t2, "Second parameter"), o2 = function(e3, t3) {
      L(e3, t3);
      const r3 = e3, o3 = null == r3 ? void 0 : r3.autoAllocateChunkSize, n2 = null == r3 ? void 0 : r3.cancel, a2 = null == r3 ? void 0 : r3.pull, i = null == r3 ? void 0 : r3.start, l2 = null == r3 ? void 0 : r3.type;
      return { autoAllocateChunkSize: void 0 === o3 ? void 0 : Q(o3, `${t3} has member 'autoAllocateChunkSize' that`), cancel: void 0 === n2 ? void 0 : gr(n2, r3, `${t3} has member 'cancel' that`), pull: void 0 === a2 ? void 0 : vr(a2, r3, `${t3} has member 'pull' that`), start: void 0 === i ? void 0 : wr(i, r3, `${t3} has member 'start' that`), type: void 0 === l2 ? void 0 : Rr(l2, `${t3} has member 'type' that`) };
    }(e2, "First parameter");
    if (qr(this), "bytes" === o2.type) {
      if (void 0 !== r2.size)
        throw new RangeError("The strategy for a byte stream cannot have a size function");
      !function(e3, t3, r3) {
        const o3 = Object.create(ReadableByteStreamController.prototype);
        let n2, a2, i;
        n2 = void 0 !== t3.start ? () => t3.start(o3) : () => {
        }, a2 = void 0 !== t3.pull ? () => t3.pull(o3) : () => c(void 0), i = void 0 !== t3.cancel ? (e4) => t3.cancel(e4) : () => c(void 0);
        const l2 = t3.autoAllocateChunkSize;
        if (0 === l2)
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        Je(e3, o3, n2, a2, i, r3, l2);
      }(this, o2, ut(r2, 0));
    } else {
      const e3 = ct(r2);
      !function(e4, t3, r3, o3) {
        const n2 = Object.create(ReadableStreamDefaultController.prototype);
        let a2, i, l2;
        a2 = void 0 !== t3.start ? () => t3.start(n2) : () => {
        }, i = void 0 !== t3.pull ? () => t3.pull(n2) : () => c(void 0), l2 = void 0 !== t3.cancel ? (e5) => t3.cancel(e5) : () => c(void 0), _r(e4, n2, a2, i, l2, r3, o3);
      }(this, o2, ut(r2, 1), e3);
    }
  }
  get locked() {
    if (!Er(this))
      throw jr("locked");
    return Wr(this);
  }
  cancel(e2 = void 0) {
    return Er(this) ? Wr(this) ? d(new TypeError("Cannot cancel a stream that already has a reader")) : Or(this, e2) : d(jr("cancel"));
  }
  getReader(e2 = void 0) {
    if (!Er(this))
      throw jr("getReader");
    return void 0 === function(e3, t2) {
      L(e3, t2);
      const r2 = null == e3 ? void 0 : e3.mode;
      return { mode: void 0 === r2 ? void 0 : et(r2, `${t2} has member 'mode' that`) };
    }(e2, "First parameter").mode ? H(this) : tt(this);
  }
  pipeThrough(e2, t2 = {}) {
    if (!Er(this))
      throw jr("pipeThrough");
    $(e2, 1, "pipeThrough");
    const r2 = function(e3, t3) {
      L(e3, t3);
      const r3 = null == e3 ? void 0 : e3.readable;
      M(r3, "readable", "ReadableWritablePair"), N(r3, `${t3} has member 'readable' that`);
      const o3 = null == e3 ? void 0 : e3.writable;
      return M(o3, "writable", "ReadableWritablePair"), pt(o3, `${t3} has member 'writable' that`), { readable: r3, writable: o3 };
    }(e2, "First parameter"), o2 = Tr(t2, "Second parameter");
    if (Wr(this))
      throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
    if (vt(r2.writable))
      throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
    return p(ir(this, r2.writable, o2.preventClose, o2.preventAbort, o2.preventCancel, o2.signal)), r2.readable;
  }
  pipeTo(e2, t2 = {}) {
    if (!Er(this))
      return d(jr("pipeTo"));
    if (void 0 === e2)
      return d("Parameter 1 is required in 'pipeTo'.");
    if (!gt(e2))
      return d(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
    let r2;
    try {
      r2 = Tr(t2, "Second parameter");
    } catch (e3) {
      return d(e3);
    }
    return Wr(this) ? d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : vt(e2) ? d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : ir(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);
  }
  tee() {
    if (!Er(this))
      throw jr("tee");
    return ne(yr(this));
  }
  values(e2 = void 0) {
    if (!Er(this))
      throw jr("values");
    return function(e3, t2) {
      const r2 = H(e3), o2 = new he(r2, t2), n2 = Object.create(me);
      return n2._asyncIteratorImpl = o2, n2;
    }(this, function(e3, t2) {
      L(e3, t2);
      const r2 = null == e3 ? void 0 : e3.preventCancel;
      return { preventCancel: Boolean(r2) };
    }(e2, "First parameter").preventCancel);
  }
  [de](e2) {
    return this.values(e2);
  }
  static from(e2) {
    return Sr(e2);
  }
};
function Cr(e2, t2, r2, o2 = 1, n2 = () => 1) {
  const a2 = Object.create(ReadableStream$2.prototype);
  qr(a2);
  return _r(a2, Object.create(ReadableStreamDefaultController.prototype), e2, t2, r2, o2, n2), a2;
}
function Pr(e2, t2, r2) {
  const o2 = Object.create(ReadableStream$2.prototype);
  qr(o2);
  return Je(o2, Object.create(ReadableByteStreamController.prototype), e2, t2, r2, 0, void 0), o2;
}
function qr(e2) {
  e2._state = "readable", e2._reader = void 0, e2._storedError = void 0, e2._disturbed = false;
}
function Er(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readableStreamController") && e2 instanceof ReadableStream$2);
}
function Wr(e2) {
  return void 0 !== e2._reader;
}
function Or(t2, r2) {
  if (t2._disturbed = true, "closed" === t2._state)
    return c(void 0);
  if ("errored" === t2._state)
    return d(t2._storedError);
  Br(t2);
  const o2 = t2._reader;
  if (void 0 !== o2 && at(o2)) {
    const e2 = o2._readIntoRequests;
    o2._readIntoRequests = new v(), e2.forEach((e3) => {
      e3._closeSteps(void 0);
    });
  }
  return _(t2._readableStreamController[T](r2), e);
}
function Br(e2) {
  e2._state = "closed";
  const t2 = e2._reader;
  if (void 0 !== t2 && (A(t2), J(t2))) {
    const e3 = t2._readRequests;
    t2._readRequests = new v(), e3.forEach((e4) => {
      e4._closeSteps();
    });
  }
}
function kr(e2, t2) {
  e2._state = "errored", e2._storedError = t2;
  const r2 = e2._reader;
  void 0 !== r2 && (j(r2, t2), J(r2) ? Z(r2, t2) : lt(r2, t2));
}
function jr(e2) {
  return new TypeError(`ReadableStream.prototype.${e2} can only be used on a ReadableStream`);
}
Object.defineProperties(ReadableStream$2, { from: { enumerable: true } }), Object.defineProperties(ReadableStream$2.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), o(ReadableStream$2.from, "from"), o(ReadableStream$2.prototype.cancel, "cancel"), o(ReadableStream$2.prototype.getReader, "getReader"), o(ReadableStream$2.prototype.pipeThrough, "pipeThrough"), o(ReadableStream$2.prototype.pipeTo, "pipeTo"), o(ReadableStream$2.prototype.tee, "tee"), o(ReadableStream$2.prototype.values, "values"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStream$2.prototype, Symbol.toStringTag, { value: "ReadableStream", configurable: true }), Object.defineProperty(ReadableStream$2.prototype, de, { value: ReadableStream$2.prototype.values, writable: true, configurable: true });
const zr = (e2) => e2.byteLength;
o(zr, "size");
const Fr = () => 1;
o(Fr, "size");
function Mr(e2, t2, r2) {
  return F(e2, r2), (r3) => g(e2, t2, [r3]);
}
function Yr(e2, t2, r2) {
  return F(e2, r2), (r3) => S(e2, t2, [r3]);
}
function xr(e2, t2, r2) {
  return F(e2, r2), (r3, o2) => g(e2, t2, [r3, o2]);
}
function Qr(e2, t2, r2) {
  return F(e2, r2), (r3) => g(e2, t2, [r3]);
}
let TransformStream$1 = class TransformStream {
  constructor(e2 = {}, t2 = {}, r2 = {}) {
    void 0 === e2 && (e2 = null);
    const o2 = dt(t2, "Second parameter"), n2 = dt(r2, "Third parameter"), a2 = function(e3, t3) {
      L(e3, t3);
      const r3 = null == e3 ? void 0 : e3.cancel, o3 = null == e3 ? void 0 : e3.flush, n3 = null == e3 ? void 0 : e3.readableType, a3 = null == e3 ? void 0 : e3.start, i2 = null == e3 ? void 0 : e3.transform, l3 = null == e3 ? void 0 : e3.writableType;
      return { cancel: void 0 === r3 ? void 0 : Qr(r3, e3, `${t3} has member 'cancel' that`), flush: void 0 === o3 ? void 0 : Mr(o3, e3, `${t3} has member 'flush' that`), readableType: n3, start: void 0 === a3 ? void 0 : Yr(a3, e3, `${t3} has member 'start' that`), transform: void 0 === i2 ? void 0 : xr(i2, e3, `${t3} has member 'transform' that`), writableType: l3 };
    }(e2, "First parameter");
    if (void 0 !== a2.readableType)
      throw new RangeError("Invalid readableType specified");
    if (void 0 !== a2.writableType)
      throw new RangeError("Invalid writableType specified");
    const i = ut(n2, 0), l2 = ct(n2), s2 = ut(o2, 1), f2 = ct(o2);
    let h2;
    !function(e3, t3, r3, o3, n3, a3) {
      function i2() {
        return t3;
      }
      function l3(t4) {
        return function(e4, t5) {
          const r4 = e4._transformStreamController;
          if (e4._backpressure) {
            return _(e4._backpressureChangePromise, () => {
              const o4 = e4._writable;
              if ("erroring" === o4._state)
                throw o4._storedError;
              return Zr(r4, t5);
            });
          }
          return Zr(r4, t5);
        }(e3, t4);
      }
      function s3(t4) {
        return function(e4, t5) {
          const r4 = e4._transformStreamController;
          if (void 0 !== r4._finishPromise)
            return r4._finishPromise;
          const o4 = e4._readable;
          r4._finishPromise = u((e5, t6) => {
            r4._finishPromise_resolve = e5, r4._finishPromise_reject = t6;
          });
          const n4 = r4._cancelAlgorithm(t5);
          return Jr(r4), b(n4, () => ("errored" === o4._state ? ro(r4, o4._storedError) : (br(o4._readableStreamController, t5), to(r4)), null), (e5) => (br(o4._readableStreamController, e5), ro(r4, e5), null)), r4._finishPromise;
        }(e3, t4);
      }
      function c2() {
        return function(e4) {
          const t4 = e4._transformStreamController;
          if (void 0 !== t4._finishPromise)
            return t4._finishPromise;
          const r4 = e4._readable;
          t4._finishPromise = u((e5, r5) => {
            t4._finishPromise_resolve = e5, t4._finishPromise_reject = r5;
          });
          const o4 = t4._flushAlgorithm();
          return Jr(t4), b(o4, () => ("errored" === r4._state ? ro(t4, r4._storedError) : (dr(r4._readableStreamController), to(t4)), null), (e5) => (br(r4._readableStreamController, e5), ro(t4, e5), null)), t4._finishPromise;
        }(e3);
      }
      function d2() {
        return function(e4) {
          return Gr(e4, false), e4._backpressureChangePromise;
        }(e3);
      }
      function f3(t4) {
        return function(e4, t5) {
          const r4 = e4._transformStreamController;
          if (void 0 !== r4._finishPromise)
            return r4._finishPromise;
          const o4 = e4._writable;
          r4._finishPromise = u((e5, t6) => {
            r4._finishPromise_resolve = e5, r4._finishPromise_reject = t6;
          });
          const n4 = r4._cancelAlgorithm(t5);
          return Jr(r4), b(n4, () => ("errored" === o4._state ? ro(r4, o4._storedError) : (Yt(o4._writableStreamController, t5), Ur(e4), to(r4)), null), (t6) => (Yt(o4._writableStreamController, t6), Ur(e4), ro(r4, t6), null)), r4._finishPromise;
        }(e3, t4);
      }
      e3._writable = function(e4, t4, r4, o4, n4 = 1, a4 = () => 1) {
        const i3 = Object.create(WritableStream.prototype);
        return St(i3), Ft(i3, Object.create(WritableStreamDefaultController.prototype), e4, t4, r4, o4, n4, a4), i3;
      }(i2, l3, c2, s3, r3, o3), e3._readable = Cr(i2, d2, f3, n3, a3), e3._backpressure = void 0, e3._backpressureChangePromise = void 0, e3._backpressureChangePromise_resolve = void 0, Gr(e3, true), e3._transformStreamController = void 0;
    }(this, u((e3) => {
      h2 = e3;
    }), s2, f2, i, l2), function(e3, t3) {
      const r3 = Object.create(TransformStreamDefaultController.prototype);
      let o3, n3, a3;
      o3 = void 0 !== t3.transform ? (e4) => t3.transform(e4, r3) : (e4) => {
        try {
          return Kr(r3, e4), c(void 0);
        } catch (e5) {
          return d(e5);
        }
      };
      n3 = void 0 !== t3.flush ? () => t3.flush(r3) : () => c(void 0);
      a3 = void 0 !== t3.cancel ? (e4) => t3.cancel(e4) : () => c(void 0);
      !function(e4, t4, r4, o4, n4) {
        t4._controlledTransformStream = e4, e4._transformStreamController = t4, t4._transformAlgorithm = r4, t4._flushAlgorithm = o4, t4._cancelAlgorithm = n4, t4._finishPromise = void 0, t4._finishPromise_resolve = void 0, t4._finishPromise_reject = void 0;
      }(e3, r3, o3, n3, a3);
    }(this, a2), void 0 !== a2.start ? h2(a2.start(this._transformStreamController)) : h2(void 0);
  }
  get readable() {
    if (!Nr(this))
      throw oo("readable");
    return this._readable;
  }
  get writable() {
    if (!Nr(this))
      throw oo("writable");
    return this._writable;
  }
};
function Nr(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_transformStreamController") && e2 instanceof TransformStream$1);
}
function Hr(e2, t2) {
  br(e2._readable._readableStreamController, t2), Vr(e2, t2);
}
function Vr(e2, t2) {
  Jr(e2._transformStreamController), Yt(e2._writable._writableStreamController, t2), Ur(e2);
}
function Ur(e2) {
  e2._backpressure && Gr(e2, false);
}
function Gr(e2, t2) {
  void 0 !== e2._backpressureChangePromise && e2._backpressureChangePromise_resolve(), e2._backpressureChangePromise = u((t3) => {
    e2._backpressureChangePromise_resolve = t3;
  }), e2._backpressure = t2;
}
Object.defineProperties(TransformStream$1.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(TransformStream$1.prototype, Symbol.toStringTag, { value: "TransformStream", configurable: true });
class TransformStreamDefaultController {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get desiredSize() {
    if (!Xr(this))
      throw eo("desiredSize");
    return hr(this._controlledTransformStream._readable._readableStreamController);
  }
  enqueue(e2 = void 0) {
    if (!Xr(this))
      throw eo("enqueue");
    Kr(this, e2);
  }
  error(e2 = void 0) {
    if (!Xr(this))
      throw eo("error");
    var t2;
    t2 = e2, Hr(this._controlledTransformStream, t2);
  }
  terminate() {
    if (!Xr(this))
      throw eo("terminate");
    !function(e2) {
      const t2 = e2._controlledTransformStream;
      dr(t2._readable._readableStreamController);
      const r2 = new TypeError("TransformStream terminated");
      Vr(t2, r2);
    }(this);
  }
}
function Xr(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledTransformStream") && e2 instanceof TransformStreamDefaultController);
}
function Jr(e2) {
  e2._transformAlgorithm = void 0, e2._flushAlgorithm = void 0, e2._cancelAlgorithm = void 0;
}
function Kr(e2, t2) {
  const r2 = e2._controlledTransformStream, o2 = r2._readable._readableStreamController;
  if (!mr(o2))
    throw new TypeError("Readable side is not in a state that permits enqueue");
  try {
    fr(o2, t2);
  } catch (e3) {
    throw Vr(r2, e3), r2._readable._storedError;
  }
  const n2 = function(e3) {
    return !ur(e3);
  }(o2);
  n2 !== r2._backpressure && Gr(r2, true);
}
function Zr(e2, t2) {
  return _(e2._transformAlgorithm(t2), void 0, (t3) => {
    throw Hr(e2._controlledTransformStream, t3), t3;
  });
}
function eo(e2) {
  return new TypeError(`TransformStreamDefaultController.prototype.${e2} can only be used on a TransformStreamDefaultController`);
}
function to(e2) {
  void 0 !== e2._finishPromise_resolve && (e2._finishPromise_resolve(), e2._finishPromise_resolve = void 0, e2._finishPromise_reject = void 0);
}
function ro(e2, t2) {
  void 0 !== e2._finishPromise_reject && (p(e2._finishPromise), e2._finishPromise_reject(t2), e2._finishPromise_resolve = void 0, e2._finishPromise_reject = void 0);
}
function oo(e2) {
  return new TypeError(`TransformStream.prototype.${e2} can only be used on a TransformStream`);
}
Object.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), o(TransformStreamDefaultController.prototype.enqueue, "enqueue"), o(TransformStreamDefaultController.prototype.error, "error"), o(TransformStreamDefaultController.prototype.terminate, "terminate"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, { value: "TransformStreamDefaultController", configurable: true });
var __extends$b = /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign$y = function() {
  __assign$y = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$y.apply(this, arguments);
};
var __awaiter$x = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$x = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
function isMatch$1() {
  if (typeof wx$1 === "undefined") {
    return false;
  }
  if (typeof Page === "undefined") {
    return false;
  }
  if (!wx$1.getSystemInfoSync) {
    return false;
  }
  if (!wx$1.getStorageSync) {
    return false;
  }
  if (!wx$1.setStorageSync) {
    return false;
  }
  if (!wx$1.connectSocket) {
    return false;
  }
  if (!wx$1.request) {
    return false;
  }
  try {
    if (!wx$1.getSystemInfoSync()) {
      return false;
    }
    if (wx$1.getSystemInfoSync().AppPlatform === "qq") {
      return false;
    }
  } catch (e2) {
    return false;
  }
  return true;
}
function isPlugin() {
  return typeof App === "undefined" && typeof getApp === "undefined" && !wx$1.onAppHide && !wx$1.offAppHide && !wx$1.onAppShow && !wx$1.offAppShow;
}
var TASK_ABORT_ERROR_MSG = "Error when aborting requestTask";
var WxRequest = function(_super) {
  __extends$b(WxRequest2, _super);
  function WxRequest2(config) {
    if (config === void 0) {
      config = {};
    }
    var _this = _super.call(this) || this;
    var timeout = config.timeout, timeoutMsg = config.timeoutMsg, restrictedMethods = config.restrictedMethods;
    _this._timeout = timeout || 0;
    _this._timeoutMsg = timeoutMsg || "请求超时";
    _this._restrictedMethods = restrictedMethods || ["get", "post", "upload", "download"];
    return _this;
  }
  WxRequest2.prototype.post = function(options) {
    var self2 = this;
    return new Promise(function(resolve2, reject) {
      var url = options.url, data = options.data, headers = options.headers;
      var task = wx$1.request({
        url: formatUrl$3("https:", url),
        data,
        timeout: self2._timeout,
        method: "POST",
        header: headers,
        success: function(res) {
          resolve2(res);
        },
        fail: function(err) {
          reject(err);
        },
        complete: function(err) {
          if (!err || !err.errMsg) {
            return;
          }
          if (!self2._timeout || self2._restrictedMethods.indexOf("post") === -1) {
            return;
          }
          var errMsg = err.errMsg;
          if (errMsg === "request:fail timeout") {
            console.warn(self2._timeoutMsg);
            try {
              task.abort();
            } catch (e2) {
            }
          }
        }
      });
    });
  };
  WxRequest2.prototype.upload = function(options) {
    var _this = this;
    var self2 = this;
    return new Promise(function(resolve2) {
      return __awaiter$x(_this, void 0, void 0, function() {
        var url, file, data, headers, onUploadProgress, task;
        return __generator$x(this, function(_a2) {
          url = options.url, file = options.file, data = options.data, headers = options.headers, onUploadProgress = options.onUploadProgress;
          task = wx$1.uploadFile({
            url,
            filePath: file,
            name: "file",
            formData: __assign$y({}, data),
            header: headers,
            timeout: this._timeout,
            success: function(res) {
              var result = {
                statusCode: res.statusCode,
                data: res.data || {}
              };
              if (res.statusCode === 200 && data.success_action_status) {
                result.statusCode = parseInt(data.success_action_status, 10);
              }
              resolve2(result);
            },
            fail: function(err) {
              resolve2(err);
            },
            complete: function(err) {
              if (!err || !err.errMsg) {
                return;
              }
              if (!self2._timeout || self2._restrictedMethods.indexOf("upload") === -1) {
                return;
              }
              var errMsg = err.errMsg;
              if (errMsg === "request:fail timeout") {
                console.warn(self2._timeoutMsg);
                try {
                  task.abort();
                } catch (e2) {
                }
              }
            }
          });
          if (onUploadProgress) {
            task.onProgressUpdate(function(res) {
              onUploadProgress(res);
            });
          }
          return [2];
        });
      });
    });
  };
  WxRequest2.prototype.download = function(options) {
    var _this = this;
    var self2 = this;
    return new Promise(function(resolve2, reject) {
      var url = options.url, headers = options.headers;
      var task = wx$1.downloadFile({
        url: formatUrl$3("https:", url),
        header: headers,
        timeout: _this._timeout,
        success: function(res) {
          if (res.statusCode === 200 && res.tempFilePath) {
            resolve2({
              statusCode: 200,
              tempFilePath: res.tempFilePath
            });
          } else {
            resolve2(res);
          }
        },
        fail: function(err) {
          reject(err);
        },
        complete: function(err) {
          if (!err || !err.errMsg) {
            return;
          }
          if (!self2._timeout || self2._restrictedMethods.indexOf("download") === -1) {
            return;
          }
          var errMsg = err.errMsg;
          if (errMsg === "request:fail timeout") {
            console.warn(self2._timeoutMsg);
            try {
              task.abort();
            } catch (e2) {
            }
          }
        }
      });
    });
  };
  WxRequest2.prototype.fetch = function(options) {
    var url = options.url, body = options.body, enableAbort = options.enableAbort, headers = options.headers, method = options.method, _a2 = options.stream, shouldStream = _a2 === void 0 ? false : _a2, signal = options.signal;
    var self2 = this;
    var controller = null;
    var stream = new ReadableStream$2({
      start: function(c2) {
        controller = c2;
      },
      cancel: function() {
        controller = null;
      }
    });
    return new Promise(function(resolve2, reject) {
      shouldStream && resolve2({ data: stream });
      var task = wx$1.request({
        url: formatUrl$3("https:", url),
        data: body,
        timeout: self2._timeout,
        method: method.toUpperCase(),
        header: headers,
        success: function(res) {
          var _a3;
          (_a3 = controller) === null || _a3 === void 0 ? void 0 : _a3.close();
          !shouldStream && resolve2(res);
        },
        fail: function(err) {
          var _a3;
          (_a3 = controller) === null || _a3 === void 0 ? void 0 : _a3.close();
          reject(err);
          if (shouldStream) {
            throw err;
          }
        },
        complete: function(err) {
          if (!err || !err.errMsg) {
            return;
          }
          if (!self2._timeout || self2._restrictedMethods.indexOf("post") === -1 || !enableAbort) {
            return;
          }
          var errMsg = err.errMsg;
          if (errMsg === "request:fail timeout") {
            console.warn(self2._timeoutMsg);
            try {
              task.abort();
            } catch (e2) {
              console.warn(TASK_ABORT_ERROR_MSG, e2);
            }
          }
        },
        enableChunked: shouldStream
      });
      task.onChunkReceived(function(buffer2) {
        var _a3;
        (_a3 = controller) === null || _a3 === void 0 ? void 0 : _a3.enqueue(new Uint8Array(buffer2.data));
      });
      if (signal) {
        var abort_1 = function() {
          try {
            task.abort();
          } catch (e2) {
            console.warn(TASK_ABORT_ERROR_MSG, e2);
          }
        };
        if (signal.aborted) {
          abort_1();
        } else {
          signal.addEventListener("abort", function() {
            return abort_1();
          });
        }
      }
    });
  };
  return WxRequest2;
}(AbstractSDKRequest);
var wxMpStorage = {
  setItem: function(key, value) {
    wx$1.setStorageSync(key, value);
  },
  getItem: function(key) {
    return wx$1.getStorageSync(key);
  },
  removeItem: function(key) {
    wx$1.removeStorageSync(key);
  },
  clear: function() {
    wx$1.clearStorageSync();
  }
};
var WxMpWebSocket = /* @__PURE__ */ function() {
  function WxMpWebSocket2(url, options) {
    if (options === void 0) {
      options = {};
    }
    var ws = wx$1.connectSocket(__assign$y({ url }, options));
    var socketTask = {
      set onopen(cb) {
        ws.onOpen(cb);
      },
      set onmessage(cb) {
        ws.onMessage(cb);
      },
      set onclose(cb) {
        ws.onClose(cb);
      },
      set onerror(cb) {
        ws.onError(cb);
      },
      send: function(data) {
        return ws.send({ data });
      },
      close: function(code2, reason) {
        return ws.close({
          code: code2,
          reason
        });
      },
      get readyState() {
        return ws.readyState;
      },
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    return socketTask;
  }
  return WxMpWebSocket2;
}();
function genAdapter$1() {
  var adapter2 = {
    root: {},
    reqClass: WxRequest,
    wsClass: WxMpWebSocket,
    localStorage: wxMpStorage,
    primaryStorage: StorageType.local,
    getAppSign: function() {
      var info = wx$1.getAccountInfoSync();
      if (isPlugin()) {
        return info && info.plugin ? info.plugin.appId : "";
      } else {
        return info && info.miniProgram ? info.miniProgram.appId : "";
      }
    }
  };
  return adapter2;
}
var adapter = {
  genAdapter: genAdapter$1,
  isMatch: isMatch$1,
  runtime: "wx_mp"
};
var __spreadArray$3 = function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar2; i < l2; i++) {
      if (ar2 || !(i in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i);
        ar2[i] = from[i];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
var ERRORS$7 = ERRORS$8;
var components$1 = {};
function registerComponent(app, component2) {
  var name2 = component2.name, namespace = component2.namespace, entity = component2.entity, injectEvents = component2.injectEvents, _a2 = component2.IIFE, IIFE = _a2 === void 0 ? false : _a2;
  if (components$1[name2] || namespace && app[namespace]) {
    throw new Error(JSON.stringify({
      code: ERRORS$7.INVALID_OPERATION,
      msg: "Duplicate component ".concat(name2)
    }));
  }
  if (IIFE) {
    if (!entity || typeof entity !== "function") {
      throw new Error(JSON.stringify({
        code: ERRORS$7.INVALID_PARAMS,
        msg: "IIFE component's entity must be a function"
      }));
    }
    entity.call(app);
  }
  components$1[name2] = component2;
  if (namespace) {
    app.prototype[namespace] = entity;
  } else {
    deepExtend(app.prototype, entity);
  }
  if (injectEvents) {
    var bus2 = injectEvents.bus, events2 = injectEvents.events;
    if (!bus2 || !events2 || events2.length === 0) {
      return;
    }
    var originCallback_1 = app.prototype.fire || function() {
    };
    if (!app.prototype.events) {
      app.prototype.events = {};
    }
    var originEvents = app.prototype.events || {};
    if (originEvents[name2]) {
      app.prototype.events[name2].events = __spreadArray$3(__spreadArray$3([], app.prototype.events[name2].events, true), events2, true);
    } else {
      app.prototype.events[name2] = { bus: bus2, events: events2 };
    }
    app.prototype.fire = function(eventName, data) {
      originCallback_1(eventName, data);
      var eventNames = Object.keys(this.events);
      for (var _i = 0, eventNames_1 = eventNames; _i < eventNames_1.length; _i++) {
        var name_1 = eventNames_1[_i];
        var _a3 = this.events[name_1], bus_1 = _a3.bus, eventList = _a3.events;
        if (eventList.includes(eventName)) {
          bus_1.fire(eventName, data);
          break;
        }
      }
    };
  }
}
function deepExtend(target, source) {
  if (!(source instanceof Object)) {
    return source;
  }
  switch (source.constructor) {
    case Date: {
      var dateValue = source;
      return new Date(dateValue.getTime());
    }
    case Object:
      if (target === void 0) {
        target = {};
      }
      break;
    case Array:
      target = [];
      break;
    default:
      return source;
  }
  var sourceKeys = Object.keys(source);
  for (var _i = 0, sourceKeys_1 = sourceKeys; _i < sourceKeys_1.length; _i++) {
    var key = sourceKeys_1[_i];
    if (!Object.prototype.hasOwnProperty.call(source, key)) {
      continue;
    }
    target[key] = deepExtend(target[key], source[key]);
  }
  return target;
}
function registerHook(app, hook2) {
  var entity = hook2.entity, target = hook2.target;
  if (Object.prototype.hasOwnProperty.call(app, target)) {
    throw new Error(JSON.stringify({
      code: ERRORS$7.INVALID_OPERATION,
      msg: "target:".concat(target, " is not exist")
    }));
  }
  var originMethod = app.prototype[target];
  if (typeof originMethod !== "function") {
    throw new Error(JSON.stringify({
      code: ERRORS$7.INVALID_OPERATION,
      msg: "target:".concat(target, " is not a function which is the only type supports hook")
    }));
  }
  app.prototype[target] = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    entity.call.apply(entity, __spreadArray$3([this], args, false));
    return originMethod.call.apply(originMethod, __spreadArray$3([this], args, false));
  };
}
var Platform = {};
var __assign$x = function() {
  __assign$x = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$x.apply(this, arguments);
};
var USER_INFO_KEY = "user_info";
var CloudbaseCache$1 = CloudbaseCache$2;
var cacheMap = {};
var localCacheMap = {};
function initCache(config) {
  var env = config.env, platformInfo = config.platformInfo;
  var userInfoKey = "".concat(USER_INFO_KEY, "_").concat(env);
  var keys = {
    userInfoKey
  };
  cacheMap[env] = cacheMap[env] || new CloudbaseCache$1(__assign$x(__assign$x({}, config), { keys, platformInfo }));
  localCacheMap[env] = localCacheMap[env] || new CloudbaseCache$1(__assign$x(__assign$x({}, config), { keys, platformInfo, persistence: "local" }));
}
function getCacheByEnvId(env) {
  return cacheMap[env];
}
function getLocalCache(env) {
  return localCacheMap[env];
}
var __assign$w = function() {
  __assign$w = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$w.apply(this, arguments);
};
var setUtilitiesSdkName = setSdkName$2, setUtilitiesProtocol = setProtocol$1;
var sdkVersion = "";
var sdkName$1 = "@cloudbase/js-sdk";
function setSdkVersion(version2) {
  sdkVersion = version2;
}
function getSdkVersion() {
  return sdkVersion;
}
function setSdkName$1(name2) {
  sdkName$1 = name2;
  setUtilitiesSdkName(name2);
}
function getSdkName$3() {
  return sdkName$1;
}
var DATA_VERSION = "2020-01-10";
var END_POINT_INFO_ARR = [];
var END_POINT_INFO_SEARCH_KEYS = ["env", "endPointKey", "region"];
var DEFAULT_PROTOCOL = "https:";
function findMatchedInfo(info) {
  return END_POINT_INFO_ARR.find(function(targetInfo) {
    return END_POINT_INFO_SEARCH_KEYS.filter(function(searchKey) {
      return info[searchKey] != null;
    }).every(function(searchKey) {
      return targetInfo[searchKey] === info[searchKey];
    });
  });
}
function setEndPointInfo(newInfo) {
  var _a2, _b;
  var endPointInfo = findMatchedInfo(newInfo);
  if (endPointInfo) {
    if (newInfo.baseUrl != null) {
      endPointInfo.baseUrl = newInfo.baseUrl;
    }
    if (newInfo.protocol != null) {
      endPointInfo.protocol = newInfo.protocol;
    }
  } else {
    END_POINT_INFO_ARR.push(__assign$w(__assign$w({}, newInfo), { protocol: (_a2 = newInfo.protocol) !== null && _a2 !== void 0 ? _a2 : DEFAULT_PROTOCOL }));
  }
  if (newInfo.endPointKey === "CLOUD_API") {
    setUtilitiesProtocol((_b = newInfo.protocol) !== null && _b !== void 0 ? _b : DEFAULT_PROTOCOL);
  }
}
function getEndPointInfo(env, endPointKey, region) {
  return findMatchedInfo({ env, endPointKey, region });
}
function setGatewayEndPointWithEnv(env, protocol) {
  setEndPointInfo({ endPointKey: "GATEWAY", env, baseUrl: "//".concat(env, ".api.tcloudbasegateway.com/v1"), protocol });
}
function setRegionLevelEndpoint(env, region, protocol) {
  var baseUrl = region ? "//".concat(env, ".").concat(region, ".tcb-api.tencentcloudapi.com/web") : "//".concat(env, ".ap-shanghai.tcb-api.tencentcloudapi.com/web");
  setEndPointInfo({ env, region, baseUrl, protocol, endPointKey: "CLOUD_API" });
}
function getBaseEndPoint(env) {
  var info = getEndPointInfo(env, "CLOUD_API");
  var PROTOCOL2 = info.protocol, BASE_URL = info.baseUrl;
  var webEndpoint = "".concat(PROTOCOL2).concat(BASE_URL);
  return webEndpoint.match(/(http(s)?:)?\/\/([^/?#]*)/)[0];
}
var LOGINTYPE;
(function(LOGINTYPE2) {
  LOGINTYPE2["NULL"] = "NULL";
  LOGINTYPE2["ANONYMOUS"] = "ANONYMOUS";
  LOGINTYPE2["WECHAT"] = "WECHAT";
  LOGINTYPE2["WECHAT_PUBLIC"] = "WECHAT-PUBLIC";
  LOGINTYPE2["WECHAT_OPEN"] = "WECHAT-OPEN";
  LOGINTYPE2["CUSTOM"] = "CUSTOM";
  LOGINTYPE2["EMAIL"] = "EMAIL";
  LOGINTYPE2["USERNAME"] = "USERNAME";
  LOGINTYPE2["PHONE"] = "PHONE";
})(LOGINTYPE || (LOGINTYPE = {}));
var __assign$v = function() {
  __assign$v = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$v.apply(this, arguments);
};
var __awaiter$w = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$w = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest$3 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
var ERRORS$6 = ERRORS$8;
var genSeqId$1 = genSeqId$2, isFormData$1 = isFormData$2, formatUrl$1 = formatUrl$2;
var ACTIONS_WITHOUT_ACCESSTOKEN = [
  "auth.getJwt",
  "auth.logout",
  "auth.signInWithTicket",
  "auth.signInAnonymously",
  "auth.signIn",
  "auth.fetchAccessTokenWithRefreshToken",
  "auth.signUpWithEmailAndPassword",
  "auth.activateEndUserMail",
  "auth.sendPasswordResetEmail",
  "auth.resetPasswordWithToken",
  "auth.isUsernameRegistered"
];
function bindHooks(instance, name2, hooks) {
  var originMethod = instance[name2];
  instance[name2] = function(options) {
    var data = {};
    var headers = {};
    hooks.forEach(function(hook2) {
      var _a2 = hook2.call(instance, options), appendedData = _a2.data, appendedHeaders = _a2.headers;
      Object.assign(data, appendedData);
      Object.assign(headers, appendedHeaders);
    });
    var originData = options.data;
    originData && function() {
      if (isFormData$1(originData)) {
        Object.keys(data).forEach(function(key) {
          originData.append(key, data[key]);
        });
        return;
      }
      options.data = __assign$v(__assign$v({}, originData), data);
    }();
    options.headers = __assign$v(__assign$v({}, options.headers || {}), headers);
    return originMethod.call(instance, options);
  };
}
function beforeEach() {
  var seqId = genSeqId$1();
  return {
    data: {
      seqId
    },
    headers: {
      "X-SDK-Version": "@cloudbase/js-sdk/".concat(getSdkVersion()),
      "x-seqid": seqId
    }
  };
}
var CloudbaseRequest = function() {
  function CloudbaseRequest2(config) {
    this.throwWhenRequestFail = false;
    this.config = config;
    var reqConfig = {
      timeout: this.config.timeout,
      timeoutMsg: "[@cloudbase/js-sdk] 请求在".concat(this.config.timeout / 1e3, "s内未完成，已中断"),
      restrictedMethods: ["post", "put"]
    };
    this.reqClass = new Platform.adapter.reqClass(reqConfig);
    this.throwWhenRequestFail = config.throw || false;
    this.localCache = getLocalCache(this.config.env);
    bindHooks(this.reqClass, "post", [beforeEach]);
    bindHooks(this.reqClass, "upload", [beforeEach]);
    bindHooks(this.reqClass, "download", [beforeEach]);
  }
  CloudbaseRequest2.prototype.post = function(options) {
    return __awaiter$w(this, void 0, void 0, function() {
      var res;
      return __generator$w(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.reqClass.post(options)];
          case 1:
            res = _a2.sent();
            return [2, res];
        }
      });
    });
  };
  CloudbaseRequest2.prototype.upload = function(options) {
    return __awaiter$w(this, void 0, void 0, function() {
      var res;
      return __generator$w(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.reqClass.upload(options)];
          case 1:
            res = _a2.sent();
            return [2, res];
        }
      });
    });
  };
  CloudbaseRequest2.prototype.download = function(options) {
    return __awaiter$w(this, void 0, void 0, function() {
      var res;
      return __generator$w(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.reqClass.download(options)];
          case 1:
            res = _a2.sent();
            return [2, res];
        }
      });
    });
  };
  CloudbaseRequest2.prototype.getBaseEndPoint = function() {
    return getBaseEndPoint(this.config.env);
  };
  CloudbaseRequest2.prototype.getOauthAccessTokenV2 = function(oauthClient) {
    return __awaiter$w(this, void 0, void 0, function() {
      var validAccessToken, credentials;
      return __generator$w(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, oauthClient.getAccessToken()];
          case 1:
            validAccessToken = _a2.sent();
            return [4, oauthClient.getCredentials()];
          case 2:
            credentials = _a2.sent();
            return [2, {
              accessToken: validAccessToken,
              accessTokenExpire: new Date(credentials.expires_at).getTime()
            }];
        }
      });
    });
  };
  CloudbaseRequest2.prototype.request = function(action, params, options) {
    var _a2, _b;
    return __awaiter$w(this, void 0, void 0, function() {
      var tcbTraceKey, contentType, tmpObj, app, oauthInstance, oauthClient, _c, payload, opts, traceHeader, parse, inQuery, search, formatQuery, _d, BASE_URL, PROTOCOL2, newUrl, res, resTraceHeader;
      return __generator$w(this, function(_e2) {
        switch (_e2.label) {
          case 0:
            tcbTraceKey = "x-tcb-trace_".concat(this.config.env);
            contentType = "application/x-www-form-urlencoded";
            tmpObj = __assign$v({ action, dataVersion: DATA_VERSION, env: this.config.env }, params);
            if (!(ACTIONS_WITHOUT_ACCESSTOKEN.indexOf(action) === -1))
              return [3, 2];
            app = this.config._fromApp;
            if (!app.oauthInstance) {
              throw new Error("you can't request without auth");
            }
            oauthInstance = app.oauthInstance;
            oauthClient = oauthInstance.oauth2client;
            _c = tmpObj;
            return [4, this.getOauthAccessTokenV2(oauthClient)];
          case 1:
            _c.access_token = _e2.sent().accessToken;
            _e2.label = 2;
          case 2:
            if (action === "storage.uploadFile") {
              payload = new FormData();
              Object.keys(payload).forEach(function(key) {
                if (Object.prototype.hasOwnProperty.call(payload, key) && payload[key] !== void 0) {
                  payload.append(key, tmpObj[key]);
                }
              });
              contentType = "multipart/form-data";
            } else {
              contentType = "application/json;charset=UTF-8";
              payload = {};
              Object.keys(tmpObj).forEach(function(key) {
                if (tmpObj[key] !== void 0) {
                  payload[key] = tmpObj[key];
                }
              });
            }
            opts = {
              headers: {
                "content-type": contentType
              }
            };
            if (options === null || options === void 0 ? void 0 : options.onUploadProgress) {
              opts.onUploadProgress = options.onUploadProgress;
            }
            if (this.config.region) {
              opts.headers["X-TCB-Region"] = this.config.region;
            }
            traceHeader = this.localCache.getStore(tcbTraceKey);
            if (traceHeader) {
              opts.headers["X-TCB-Trace"] = traceHeader;
            }
            parse = (options === null || options === void 0 ? void 0 : options.parse) !== void 0 ? options.parse : params.parse;
            inQuery = (options === null || options === void 0 ? void 0 : options.inQuery) !== void 0 ? options.inQuery : params.inQuery;
            search = (options === null || options === void 0 ? void 0 : options.search) !== void 0 ? options.search : params.search;
            formatQuery = __assign$v(__assign$v({}, (options === null || options === void 0 ? void 0 : options.defaultQuery) || {}), { env: this.config.env });
            parse && (formatQuery.parse = true);
            inQuery && (formatQuery = __assign$v(__assign$v({}, inQuery), formatQuery));
            _d = getEndPointInfo(this.config.env, "CLOUD_API"), BASE_URL = _d.baseUrl, PROTOCOL2 = _d.protocol;
            if (options.pathname) {
              newUrl = formatUrl$1(PROTOCOL2, "".concat((_a2 = getBaseEndPoint(this.config.env)) === null || _a2 === void 0 ? void 0 : _a2.replace(/^https?:/, ""), "/").concat(options.pathname), formatQuery);
            } else {
              newUrl = formatUrl$1(PROTOCOL2, BASE_URL, formatQuery);
            }
            if (search) {
              newUrl += search;
            }
            return [4, this.post(__assign$v({ url: newUrl, data: payload }, opts))];
          case 3:
            res = _e2.sent();
            resTraceHeader = (_b = res.header) === null || _b === void 0 ? void 0 : _b["x-tcb-trace"];
            if (resTraceHeader) {
              this.localCache.setStore(tcbTraceKey, resTraceHeader);
            }
            if (Number(res.status) !== 200 && Number(res.statusCode) !== 200 || !res.data) {
              throw new Error("network request error");
            }
            return [2, res];
        }
      });
    });
  };
  CloudbaseRequest2.prototype.fetch = function(options) {
    var _a2, _b, _c, _d, _e2, _f, _g, _h;
    return __awaiter$w(this, void 0, void 0, function() {
      var token, _j, headers, restOptions, getAccessToken, doFetch, result, err_1;
      var _this = this;
      return __generator$w(this, function(_k) {
        switch (_k.label) {
          case 0:
            token = options.token, _j = options.headers, headers = _j === void 0 ? {} : _j, restOptions = __rest$3(options, ["token", "headers"]);
            getAccessToken = function() {
              return __awaiter$w(_this, void 0, void 0, function() {
                var app, oauthInstance, oauthClient;
                return __generator$w(this, function(_a3) {
                  switch (_a3.label) {
                    case 0:
                      if (token != null) {
                        return [2, token];
                      }
                      app = this.config._fromApp;
                      if (!app.oauthInstance) {
                        throw new Error("you can't request without auth");
                      }
                      oauthInstance = app.oauthInstance;
                      oauthClient = oauthInstance.oauth2client;
                      return [4, this.getOauthAccessTokenV2(oauthClient)];
                    case 1:
                      return [2, _a3.sent().accessToken];
                  }
                });
              });
            };
            doFetch = function() {
              return __awaiter$w(_this, void 0, void 0, function() {
                var _a3, _b2, _c2;
                var _d2, _e3;
                return __generator$w(this, function(_f2) {
                  switch (_f2.label) {
                    case 0:
                      _b2 = (_a3 = this.reqClass).fetch;
                      _d2 = {};
                      _e3 = {};
                      _c2 = "Bearer ".concat;
                      return [4, getAccessToken()];
                    case 1:
                      return [2, _b2.apply(_a3, [__assign$v.apply(void 0, [(_d2.headers = __assign$v.apply(void 0, [(_e3.Authorization = _c2.apply("Bearer ", [_f2.sent()]), _e3), headers]), _d2), restOptions])])];
                  }
                });
              });
            };
            _k.label = 1;
          case 1:
            _k.trys.push([1, 3, , 6]);
            return [4, doFetch()];
          case 2:
            result = _k.sent();
            return [2, result];
          case 3:
            err_1 = _k.sent();
            if (!((err_1 === null || err_1 === void 0 ? void 0 : err_1.code) === "ACCESS_TOKEN_EXPIRED"))
              return [3, 5];
            if (typeof ((_d = (_c = (_b = (_a2 = this.config) === null || _a2 === void 0 ? void 0 : _a2._fromApp) === null || _b === void 0 ? void 0 : _b.oauthInstance) === null || _c === void 0 ? void 0 : _c.authApi) === null || _d === void 0 ? void 0 : _d.refreshTokenForce) !== "function") {
              throw err_1;
            }
            return [4, (_h = (_g = (_f = (_e2 = this.config) === null || _e2 === void 0 ? void 0 : _e2._fromApp) === null || _f === void 0 ? void 0 : _f.oauthInstance) === null || _g === void 0 ? void 0 : _g.authApi) === null || _h === void 0 ? void 0 : _h.refreshTokenForce()];
          case 4:
            _k.sent();
            return [2, doFetch()];
          case 5:
            throw err_1;
          case 6:
            return [2];
        }
      });
    });
  };
  CloudbaseRequest2.prototype.send = function(action, data, options) {
    if (data === void 0) {
      data = {};
    }
    if (options === void 0) {
      options = {};
    }
    return __awaiter$w(this, void 0, void 0, function() {
      var response;
      return __generator$w(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.request(action, data, __assign$v(__assign$v({}, options), { onUploadProgress: data.onUploadProgress }))];
          case 1:
            response = _a2.sent();
            if (response.data.code && this.throwWhenRequestFail) {
              throw new Error(JSON.stringify({
                code: ERRORS$6.OPERATION_FAIL,
                msg: "[".concat(response.data.code, "] ").concat(response.data.message)
              }));
            }
            return [2, response.data];
        }
      });
    });
  };
  return CloudbaseRequest2;
}();
var requestMap = {};
function initRequest(config) {
  requestMap[config.env] = new CloudbaseRequest(__assign$v(__assign$v({}, config), { throw: true }));
}
function getRequestByEnvId(env) {
  return requestMap[env];
}
var __assign$u = function() {
  __assign$u = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$u.apply(this, arguments);
};
var __decorate$4 = function(decorators2, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators2, target, key, desc);
  else
    for (var i = decorators2.length - 1; i >= 0; i--)
      if (d2 = decorators2[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata$4 = function(k2, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k2, v2);
};
var __awaiter$v = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$v = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var useAdapters = useAdapters$1, useDefaultAdapter = useDefaultAdapter$1;
var ERRORS$5 = ERRORS$8, COMMUNITY_SITE_URL$3 = COMMUNITY_SITE_URL$4;
var printWarn$1 = printWarn$2;
var catchErrorsDecorator$4 = catchErrorsDecorator$5;
var DEFAULT_INIT_CONFIG = {
  timeout: 15e3,
  persistence: "local"
};
var MAX_TIMEOUT = 1e3 * 60 * 10;
var MIN_TIMEOUT = 100;
var extensionMap = {};
var Cloudbase = function() {
  function Cloudbase2(config) {
    this.cloudbaseConfig = config ? config : this.cloudbaseConfig;
    this.authInstance = null;
    this.oauthInstance = null;
    this.version = getSdkVersion();
  }
  Object.defineProperty(Cloudbase2.prototype, "config", {
    get: function() {
      return this.cloudbaseConfig;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Cloudbase2.prototype, "platform", {
    get: function() {
      return Platform;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Cloudbase2.prototype, "cache", {
    get: function() {
      return getCacheByEnvId(this.cloudbaseConfig.env);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Cloudbase2.prototype, "localCache", {
    get: function() {
      return getLocalCache(this.cloudbaseConfig.env);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Cloudbase2.prototype, "request", {
    get: function() {
      return getRequestByEnvId(this.cloudbaseConfig.env);
    },
    enumerable: false,
    configurable: true
  });
  Cloudbase2.prototype.init = function(config) {
    var _a2;
    if (!config.env) {
      throw new Error(JSON.stringify({
        code: ERRORS$5.INVALID_PARAMS,
        msg: "env must not be specified"
      }));
    }
    if (!Platform.adapter) {
      this.useDefaultAdapter();
    }
    var reqConfig = {
      timeout: config.timeout || 5e3,
      timeoutMsg: "[".concat(getSdkName$3(), "][REQUEST TIMEOUT] request had been abort since didn't finished within").concat(config.timeout / 1e3, "s")
    };
    this.requestClient = new Platform.adapter.reqClass(reqConfig);
    this.cloudbaseConfig = __assign$u(__assign$u({}, DEFAULT_INIT_CONFIG), config);
    this.cloudbaseConfig.timeout = this.formatTimeout(this.cloudbaseConfig.timeout);
    var _b = this.cloudbaseConfig, env = _b.env, persistence = _b.persistence, debug = _b.debug, timeout = _b.timeout, oauthClient = _b.oauthClient;
    initCache({ env, persistence, debug, platformInfo: this.platform });
    setRegionLevelEndpoint(env, config.region || "");
    setGatewayEndPointWithEnv(env);
    var app = new Cloudbase2(this.cloudbaseConfig);
    initRequest({ env, region: config.region || "", timeout, oauthClient, _fromApp: app });
    app.requestClient = this.requestClient;
    (_a2 = this === null || this === void 0 ? void 0 : this.fire) === null || _a2 === void 0 ? void 0 : _a2.call(this, "cloudbase_init", app);
    return app;
  };
  Cloudbase2.prototype.updateConfig = function(config) {
    var persistence = config.persistence, debug = config.debug;
    this.cloudbaseConfig.persistence = persistence;
    this.cloudbaseConfig.debug = debug;
    initCache({ env: this.cloudbaseConfig.env, persistence, debug, platformInfo: this.platform });
  };
  Cloudbase2.prototype.registerExtension = function(ext) {
    extensionMap[ext.name] = ext;
  };
  Cloudbase2.prototype.invokeExtension = function(name2, opts) {
    return __awaiter$v(this, void 0, void 0, function() {
      var ext;
      return __generator$v(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            ext = extensionMap[name2];
            if (!ext) {
              throw new Error(JSON.stringify({
                code: ERRORS$5.INVALID_PARAMS,
                msg: "extension:".concat(name2, " must be registered before invoke")
              }));
            }
            return [4, ext.invoke(opts, this)];
          case 1:
            return [2, _a2.sent()];
        }
      });
    });
  };
  Cloudbase2.prototype.useAdapters = function(adapters2) {
    var _a2 = useAdapters(adapters2) || {}, adapter2 = _a2.adapter, runtime2 = _a2.runtime;
    adapter2 && (Platform.adapter = adapter2);
    runtime2 && (Platform.runtime = runtime2);
  };
  Cloudbase2.prototype.registerHook = function(hook2) {
    registerHook(Cloudbase2, hook2);
  };
  Cloudbase2.prototype.registerComponent = function(component2) {
    registerComponent(Cloudbase2, component2);
  };
  Cloudbase2.prototype.registerVersion = function(version2) {
    setSdkVersion(version2);
    this.version = version2;
  };
  Cloudbase2.prototype.registerSdkName = function(name2) {
    setSdkName$1(name2);
  };
  Cloudbase2.prototype.registerEndPoint = function(url, protocol) {
    setEndPointInfo({ baseUrl: url, protocol, env: this.config.env, endPointKey: "CLOUD_API" });
  };
  Cloudbase2.prototype.registerEndPointWithKey = function(props) {
    setEndPointInfo({
      env: this.config.env,
      endPointKey: props.key,
      baseUrl: props.url,
      protocol: props.protocol
    });
  };
  Cloudbase2.prototype.getEndPointWithKey = function(key) {
    var info = getEndPointInfo(this.config.env, key);
    return {
      BASE_URL: info.baseUrl,
      PROTOCOL: info.protocol
    };
  };
  Cloudbase2.prototype.useDefaultAdapter = function() {
    var _a2 = useDefaultAdapter(), adapter2 = _a2.adapter, runtime2 = _a2.runtime;
    Platform.adapter = adapter2;
    Platform.runtime = runtime2;
  };
  Cloudbase2.prototype.formatTimeout = function(timeout) {
    switch (true) {
      case timeout > MAX_TIMEOUT:
        printWarn$1(ERRORS$5.INVALID_PARAMS, "timeout is greater than maximum value[10min]");
        return MAX_TIMEOUT;
      case timeout < MIN_TIMEOUT:
        printWarn$1(ERRORS$5.INVALID_PARAMS, "timeout is less than maximum value[100ms]");
        return MIN_TIMEOUT;
      default:
        return timeout;
    }
  };
  __decorate$4([
    catchErrorsDecorator$4({
      mode: "sync",
      title: "Cloudbase 初始化失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 cloudbase.init() 的语法或参数是否正确",
        "  2 - 如果是非浏览器环境，是否配置了安全应用来源（https://docs.cloudbase.net/api-reference/webv3/adapter#%E7%AC%AC-2-%E6%AD%A5%E9%85%8D%E7%BD%AE%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8%E6%9D%A5%E6%BA%90）",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(COMMUNITY_SITE_URL$3)
      ]
    }),
    __metadata$4("design:type", Function),
    __metadata$4("design:paramtypes", [Object]),
    __metadata$4("design:returntype", Cloudbase2)
  ], Cloudbase2.prototype, "init", null);
  __decorate$4([
    catchErrorsDecorator$4({
      title: "调用扩展能力失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 invokeExtension() 的语法或参数是否正确",
        "  2 - 被调用的扩展能力是否已经安装并通过 registerExtension() 注册",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(COMMUNITY_SITE_URL$3)
      ]
    }),
    __metadata$4("design:type", Function),
    __metadata$4("design:paramtypes", [String, Object]),
    __metadata$4("design:returntype", Promise)
  ], Cloudbase2.prototype, "invokeExtension", null);
  return Cloudbase2;
}();
var cloudbase$1 = new Cloudbase();
cloudbase$1.useAdapters(adapter);
var ApiUrls;
(function(ApiUrls2) {
  ApiUrls2["AUTH_SIGN_UP_URL"] = "/auth/v1/signup";
  ApiUrls2["AUTH_TOKEN_URL"] = "/auth/v1/token";
  ApiUrls2["AUTH_REVOKE_URL"] = "/auth/v1/revoke";
  ApiUrls2["WEDA_USER_URL"] = "/auth/v1/plugin/weda/userinfo";
  ApiUrls2["AUTH_RESET_PASSWORD"] = "/auth/v1/reset";
  ApiUrls2["AUTH_GET_DEVICE_CODE"] = "/auth/v1/device/code";
  ApiUrls2["CHECK_USERNAME"] = "/auth/v1/checkUsername";
  ApiUrls2["CHECK_IF_USER_EXIST"] = "/auth/v1/checkIfUserExist";
  ApiUrls2["GET_PROVIDER_TYPE"] = "/auth/v1/mgr/provider/providerSubType";
  ApiUrls2["AUTH_SIGN_IN_URL"] = "/auth/v1/signin";
  ApiUrls2["AUTH_SIGN_IN_ANONYMOUSLY_URL"] = "/auth/v1/signin/anonymously";
  ApiUrls2["AUTH_SIGN_IN_WITH_PROVIDER_URL"] = "/auth/v1/signin/with/provider";
  ApiUrls2["AUTH_SIGN_IN_WITH_WECHAT_URL"] = "/auth/v1/signin/wechat/noauth";
  ApiUrls2["AUTH_SIGN_IN_CUSTOM"] = "/auth/v1/signin/custom";
  ApiUrls2["PROVIDER_TOKEN_URL"] = "/auth/v1/provider/token";
  ApiUrls2["PROVIDER_URI_URL"] = "/auth/v1/provider/uri";
  ApiUrls2["USER_ME_URL"] = "/auth/v1/user/me";
  ApiUrls2["AUTH_SIGNOUT_URL"] = "/auth/v1/user/signout";
  ApiUrls2["USER_QUERY_URL"] = "/auth/v1/user/query";
  ApiUrls2["USER_PRIFILE_URL"] = "/auth/v1/user/profile";
  ApiUrls2["USER_BASIC_EDIT_URL"] = "/auth/v1/user/basic/edit";
  ApiUrls2["USER_TRANS_BY_PROVIDER_URL"] = "/auth/v1/user/trans/by/provider";
  ApiUrls2["PROVIDER_LIST"] = "/auth/v1/user/provider";
  ApiUrls2["PROVIDER_BIND_URL"] = "/auth/v1/user/provider/bind";
  ApiUrls2["PROVIDER_UNBIND_URL"] = "/auth/v1/user/provider";
  ApiUrls2["CHECK_PWD_URL"] = "/auth/v1/user/sudo";
  ApiUrls2["SUDO_URL"] = "/auth/v1/user/sudo";
  ApiUrls2["BIND_CONTACT_URL"] = "/auth/v1/user/contact";
  ApiUrls2["AUTH_SET_PASSWORD"] = "/auth/v1/user/password";
  ApiUrls2["AUTHORIZE_DEVICE_URL"] = "/auth/v1/user/device/authorize";
  ApiUrls2["AUTHORIZE_URL"] = "/auth/v1/user/authorize";
  ApiUrls2["AUTHORIZE_INFO_URL"] = "/auth/v1/user/authorize/info";
  ApiUrls2["AUTHORIZED_DEVICES_DELETE_URL"] = "/auth/v1/user/authorized/devices/";
  ApiUrls2["AUTH_REVOKE_ALL_URL"] = "/auth/v1/user/revoke/all";
  ApiUrls2["GET_USER_BEHAVIOR_LOG"] = "/auth/v1/user/security/history";
  ApiUrls2["VERIFICATION_URL"] = "/auth/v1/verification";
  ApiUrls2["VERIFY_URL"] = "/auth/v1/verification/verify";
  ApiUrls2["CAPTCHA_DATA_URL"] = "/auth/v1/captcha/data";
  ApiUrls2["VERIFY_CAPTCHA_DATA_URL"] = "/auth/v1/captcha/data/verify";
  ApiUrls2["GET_CAPTCHA_URL"] = "/auth/v1/captcha/init";
  ApiUrls2["GET_MINIPROGRAM_QRCODE"] = "/auth/v1/qrcode/generate";
  ApiUrls2["GET_MINIPROGRAM_QRCODE_STATUS"] = "/auth/v1/qrcode/get/status";
})(ApiUrls || (ApiUrls = {}));
var ApiUrlsV2;
(function(ApiUrlsV22) {
  ApiUrlsV22["AUTH_SIGN_IN_URL"] = "/auth/v2/signin/username";
  ApiUrlsV22["AUTH_TOKEN_URL"] = "/auth/v2/token";
  ApiUrlsV22["USER_ME_URL"] = "/auth/v2/user/me";
  ApiUrlsV22["VERIFY_URL"] = "/auth/v2/signin/verificationcode";
  ApiUrlsV22["AUTH_SIGN_IN_WITH_PROVIDER_URL"] = "/auth/v2/signin/with/provider";
  ApiUrlsV22["AUTH_PUBLIC_KEY"] = "/auth/v2/signin/publichkey";
  ApiUrlsV22["AUTH_RESET_PASSWORD"] = "/auth/v2/signin/password/update";
})(ApiUrlsV2 || (ApiUrlsV2 = {}));
var VerificationUsages;
(function(VerificationUsages2) {
  VerificationUsages2["REGISTER"] = "REGISTER";
  VerificationUsages2["SIGN_IN"] = "SIGN_IN";
  VerificationUsages2["PASSWORD_RESET"] = "PASSWORD_RESET";
  VerificationUsages2["EMAIL_ADDRESS_CHANGE"] = "EMAIL_ADDRESS_CHANGE";
  VerificationUsages2["PHONE_NUMBER_CHANGE"] = "PHONE_NUMBER_CHANGE";
})(VerificationUsages || (VerificationUsages = {}));
var ErrorType;
(function(ErrorType2) {
  ErrorType2["UNREACHABLE"] = "unreachable";
  ErrorType2["LOCAL"] = "local";
  ErrorType2["CANCELLED"] = "cancelled";
  ErrorType2["UNKNOWN"] = "unknown";
  ErrorType2["UNAUTHENTICATED"] = "unauthenticated";
  ErrorType2["RESOURCE_EXHAUSTED"] = "resource_exhausted";
  ErrorType2["FAILED_PRECONDITION"] = "failed_precondition";
  ErrorType2["INVALID_ARGUMENT"] = "invalid_argument";
  ErrorType2["DEADLINE_EXCEEDED"] = "deadline_exceeded";
  ErrorType2["NOT_FOUND"] = "not_found";
  ErrorType2["ALREADY_EXISTS"] = "already_exists";
  ErrorType2["PERMISSION_DENIED"] = "permission_denied";
  ErrorType2["ABORTED"] = "aborted";
  ErrorType2["OUT_OF_RANGE"] = "out_of_range";
  ErrorType2["UNIMPLEMENTED"] = "unimplemented";
  ErrorType2["INTERNAL"] = "internal";
  ErrorType2["UNAVAILABLE"] = "unavailable";
  ErrorType2["DATA_LOSS"] = "data_loss";
  ErrorType2["INVALID_PASSWORD"] = "invalid_password";
  ErrorType2["PASSWORD_NOT_SET"] = "password_not_set";
  ErrorType2["INVALID_STATUS"] = "invalid_status";
  ErrorType2["USER_PENDING"] = "user_pending";
  ErrorType2["USER_BLOCKED"] = "user_blocked";
  ErrorType2["INVALID_VERIFICATION_CODE"] = "invalid_verification_code";
  ErrorType2["TWO_FACTOR_REQUIRED"] = "two_factor_required";
  ErrorType2["INVALID_TWO_FACTOR"] = "invalid_two_factor";
  ErrorType2["INVALID_TWO_FACTOR_RECOVERY"] = "invalid_two_factor_recovery";
  ErrorType2["UNDER_REVIEW"] = "under_review";
  ErrorType2["INVALID_REQUEST"] = "invalid_request";
  ErrorType2["UNAUTHORIZED_CLIENT"] = "unauthorized_client";
  ErrorType2["ACCESS_DENIED"] = "access_denied";
  ErrorType2["UNSUPPORTED_RESPONSE_TYPE"] = "unsupported_response_type";
  ErrorType2["INVALID_SCOPE"] = "invalid_scope";
  ErrorType2["INVALID_GRANT"] = "invalid_grant";
  ErrorType2["SERVER_ERROR"] = "server_error";
  ErrorType2["TEMPORARILY_UNAVAILABLE"] = "temporarily_unavailable";
  ErrorType2["INTERACTION_REQUIRED"] = "interaction_required";
  ErrorType2["LOGIN_REQUIRED"] = "login_required";
  ErrorType2["ACCOUNT_SELECTION_REQUIRED"] = "account_selection_required";
  ErrorType2["CONSENT_REQUIRED"] = "consent_required";
  ErrorType2["INVALID_REQUEST_URI"] = "invalid_request_uri";
  ErrorType2["INVALID_REQUEST_OBJECT"] = "invalid_request_object";
  ErrorType2["REQUEST_NOT_SUPPORTED"] = "request_not_supported";
  ErrorType2["REQUEST_URI_NOT_SUPPORTED"] = "request_uri_not_supported";
  ErrorType2["REGISTRATION_NOT_SUPPORTED"] = "registration_not_supported";
  ErrorType2["CAPTCHA_REQUIRED"] = "captcha_required";
  ErrorType2["CAPTCHA_INVALID"] = "captcha_invalid";
})(ErrorType || (ErrorType = {}));
var Syntax;
(function(Syntax2) {
  Syntax2["CLIENT_ID"] = "client_id";
  Syntax2["CLIENT_SECRET"] = "client_secret";
  Syntax2["RESPONSE_TYPE"] = "response_type";
  Syntax2["SCOPE"] = "scope";
  Syntax2["STATE"] = "state";
  Syntax2["REDIRECT_URI"] = "redirect_uri";
  Syntax2["ERROR"] = "error";
  Syntax2["ERROR_DESCRIPTION"] = "error_description";
  Syntax2["ERROR_URI"] = "error_uri";
  Syntax2["GRANT_TYPE"] = "grant_type";
  Syntax2["CODE"] = "code";
  Syntax2["ACCESS_TOKEN"] = "access_token";
  Syntax2["TOKEN_TYPE"] = "token_type";
  Syntax2["EXPIRES_IN"] = "expires_in";
  Syntax2["USERNAME"] = "username";
  Syntax2["PASSWORD"] = "password";
  Syntax2["REFRESH_TOKEN"] = "refresh_token";
})(Syntax || (Syntax = {}));
function uuidv4() {
  return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    const r2 = Math.random() * 16 | 0;
    const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
    return v2.toString(16);
  });
}
const deepClone = (value) => {
  const clone2 = (copiedValue) => {
    for (const key in value) {
      if (value.hasOwnProperty(key)) {
        copiedValue[key] = deepClone(value[key]);
      }
    }
    return copiedValue;
  };
  const type = value === null || value === void 0 ? "NullOrUndefined" : Object.prototype.toString.call(value).slice(8, -1);
  if ([
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ].includes(type)) {
    return value.slice();
  }
  switch (type) {
    case "Object":
      return clone2(Object.create(Object.getPrototypeOf(value)));
    case "Array":
      return clone2([]);
    case "Date":
      return new Date(value.valueOf());
    case "RegExp":
      return new RegExp(value.source, (value.global ? "g" : "") + (value.ignoreCase ? "i" : "") + (value.multiline ? "m" : "") + (value.sticky ? "y" : "") + (value.unicode ? "u" : ""));
    default:
      return value;
  }
};
const getPathName = (url) => {
  const regex = /^(?:http(s)?:\/\/[^\/]+)?(\/[^\?#]*)/;
  const match = url.match(regex);
  if (match) {
    return match[2] || "";
  }
  return "";
};
class SinglePromise {
  constructor(options) {
    this.clientId = (options == null ? void 0 : options.clientId) || "";
    globalThis.jsSdkFnPromiseMap = globalThis.jsSdkFnPromiseMap || /* @__PURE__ */ new Map();
  }
  async run(key, fn) {
    key = `${this.clientId}_${key}`;
    let result = globalThis.jsSdkFnPromiseMap.get(key);
    if (!result) {
      result = new Promise((resolve2, reject) => {
        (async () => {
          try {
            await this.runIdlePromise();
            const fnResult = fn();
            resolve2(await fnResult);
          } catch (error) {
            reject(error);
          } finally {
            globalThis.jsSdkFnPromiseMap.delete(key);
          }
        })();
      });
      globalThis.jsSdkFnPromiseMap.set(key, result);
    }
    return result;
  }
  runIdlePromise() {
    return Promise.resolve();
  }
}
const b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function weBtoa(string) {
  string = String(string);
  let bitmap;
  let a2;
  let b2;
  let c2;
  let result = "";
  let i = 0;
  const rest = string.length % 3;
  for (; i < string.length; ) {
    if ((a2 = string.charCodeAt(i++)) > 255 || (b2 = string.charCodeAt(i++)) > 255 || (c2 = string.charCodeAt(i++)) > 255)
      throw new TypeError("Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.");
    bitmap = a2 << 16 | b2 << 8 | c2;
    result += b64.charAt(bitmap >> 18 & 63) + b64.charAt(bitmap >> 12 & 63) + b64.charAt(bitmap >> 6 & 63) + b64.charAt(bitmap & 63);
  }
  return rest ? result.slice(0, rest - 3) + "===".substring(rest) : result;
}
function isMatch() {
  if (typeof wx$1 === "undefined") {
    return false;
  }
  if (typeof Page === "undefined") {
    return false;
  }
  if (!wx$1.getSystemInfoSync) {
    return false;
  }
  if (!wx$1.getStorageSync) {
    return false;
  }
  if (!wx$1.setStorageSync) {
    return false;
  }
  if (!wx$1.connectSocket) {
    return false;
  }
  if (!wx$1.request) {
    return false;
  }
  try {
    if (!wx$1.getSystemInfoSync()) {
      return false;
    }
    if (wx$1.getSystemInfoSync().AppPlatform === "qq") {
      return false;
    }
  } catch (e2) {
    return false;
  }
  return true;
}
const RequestIdHeaderName = "x-request-id";
const DeviceIdHeaderName = "x-device-id";
const DeviceIdSectionName = "device_id";
const defaultRequest = async function(url, options) {
  let result = null;
  let responseError = null;
  try {
    const copyOptions = Object.assign({}, options);
    if (!copyOptions.method) {
      copyOptions.method = "GET";
    }
    if (copyOptions.body && typeof copyOptions.body !== "string") {
      copyOptions.body = JSON.stringify(copyOptions.body);
    }
    const responseResult = await fetch(url, copyOptions);
    const jsonResponse = await responseResult.json();
    if (jsonResponse == null ? void 0 : jsonResponse.error) {
      responseError = jsonResponse;
      responseError.error_uri = new URL(url).pathname;
    } else {
      result = jsonResponse;
    }
  } catch (error) {
    responseError = {
      error: ErrorType.UNREACHABLE,
      error_description: error.message,
      error_uri: new URL(url).pathname
    };
  }
  if (responseError) {
    throw responseError;
  } else {
    return result;
  }
};
function generateRequestId$1() {
  return uuidv4();
}
class DefaultStorage {
  constructor(opts) {
    this._env = (opts == null ? void 0 : opts.env) || "";
  }
  async getItem(key) {
    return window.localStorage.getItem(`${key}${this._env}`);
  }
  async removeItem(key) {
    window.localStorage.removeItem(`${key}${this._env}`);
  }
  async setItem(key, value) {
    window.localStorage.setItem(`${key}${this._env}`, value);
  }
  getItemSync(key) {
    return window.localStorage.getItem(`${key}${this._env}`);
  }
  removeItemSync(key) {
    window.localStorage.removeItem(`${key}${this._env}`);
  }
  setItemSync(key, value) {
    window.localStorage.setItem(`${key}${this._env}`, value);
  }
}
const defaultStorage = new DefaultStorage();
function isCredentialsExpired(credentials) {
  let isExpired = true;
  if ((credentials == null ? void 0 : credentials.expires_at) && (credentials == null ? void 0 : credentials.access_token)) {
    isExpired = credentials.expires_at < /* @__PURE__ */ new Date();
  }
  return isExpired;
}
class LocalCredentials {
  constructor(options) {
    this.credentials = null;
    this.singlePromise = null;
    this.tokenSectionName = options.tokenSectionName;
    this.storage = options.storage;
    this.clientId = options.clientId;
    this.singlePromise = new SinglePromise({ clientId: this.clientId });
  }
  getStorageCredentialsSync() {
    let credentials = null;
    const tokenStr = this.storage.getItemSync(this.tokenSectionName);
    if (tokenStr !== void 0 && tokenStr !== null) {
      try {
        credentials = JSON.parse(tokenStr);
        if (credentials == null ? void 0 : credentials.expires_at) {
          credentials.expires_at = new Date(credentials.expires_at);
        }
      } catch (error) {
        this.storage.removeItem(this.tokenSectionName);
        credentials = null;
      }
    }
    return credentials;
  }
  async setCredentials(credentials) {
    if (credentials == null ? void 0 : credentials.expires_in) {
      if (!(credentials == null ? void 0 : credentials.expires_at)) {
        credentials.expires_at = new Date(Date.now() + (credentials.expires_in - 30) * 1e3);
      }
      if (this.storage) {
        const tokenStr = JSON.stringify(credentials);
        await this.storage.setItem(this.tokenSectionName, tokenStr);
      }
      this.credentials = credentials;
    } else {
      if (this.storage) {
        await this.storage.removeItem(this.tokenSectionName);
      }
      this.credentials = null;
    }
  }
  async getCredentials() {
    return this.singlePromise.run("getCredentials", async () => {
      if (isCredentialsExpired(this.credentials)) {
        this.credentials = await this.getStorageCredentials();
      }
      return this.credentials;
    });
  }
  async getStorageCredentials() {
    return this.singlePromise.run("_getStorageCredentials", async () => {
      let credentials = null;
      const tokenStr = await this.storage.getItem(this.tokenSectionName);
      if (tokenStr !== void 0 && tokenStr !== null) {
        try {
          credentials = JSON.parse(tokenStr);
          if (credentials == null ? void 0 : credentials.expires_at) {
            credentials.expires_at = new Date(credentials.expires_at);
          }
        } catch (error) {
          await this.storage.removeItem(this.tokenSectionName);
          credentials = null;
        }
      }
      return credentials;
    });
  }
}
class OAuth2Client {
  constructor(options) {
    this.singlePromise = null;
    if (!options.clientSecret) {
      options.clientSecret = "";
    }
    if (!options.clientId && options.env) {
      options.clientId = options.env;
    }
    this.apiOrigin = options.apiOrigin;
    this.clientId = options.clientId;
    this.singlePromise = new SinglePromise({ clientId: this.clientId });
    this.retry = this.formatRetry(options.retry, OAuth2Client.defaultRetry);
    if (options.baseRequest) {
      this.baseRequest = options.baseRequest;
    } else {
      this.baseRequest = defaultRequest;
    }
    this.tokenInURL = options.tokenInURL;
    this.headers = options.headers;
    this.storage = options.storage || defaultStorage;
    this.localCredentials = new LocalCredentials({
      tokenSectionName: `credentials_${options.clientId}`,
      storage: this.storage,
      clientId: options.clientId
    });
    this.clientSecret = options.clientSecret;
    if (options.clientId) {
      this.basicAuth = `Basic ${weBtoa(`${options.clientId}:${this.clientSecret}`)}`;
    }
    this.wxCloud = options.wxCloud;
    try {
      if (isMatch() && this.wxCloud === void 0 && options.env) {
        wx$1.cloud.init({ env: options.env });
        this.wxCloud = wx$1.cloud;
      }
    } catch (error) {
    }
    this.refreshTokenFunc = options.refreshTokenFunc || this.defaultRefreshTokenFunc;
    this.anonymousSignInFunc = options.anonymousSignInFunc;
  }
  setCredentials(credentials) {
    return this.localCredentials.setCredentials(credentials);
  }
  async getAccessToken() {
    const credentials = await this.getCredentials();
    if (credentials == null ? void 0 : credentials.access_token) {
      return Promise.resolve(credentials.access_token);
    }
    const respErr = { error: ErrorType.UNAUTHENTICATED };
    return Promise.reject(respErr);
  }
  async request(url, options) {
    if (!options) {
      options = {};
    }
    const retry = this.formatRetry(options.retry, this.retry);
    options.headers = options.headers || {};
    if (this.headers) {
      options.headers = {
        ...this.headers,
        ...options.headers
      };
    }
    if (!options.headers[RequestIdHeaderName]) {
      options.headers[RequestIdHeaderName] = generateRequestId$1();
    }
    if (!options.headers[DeviceIdHeaderName]) {
      const deviceId2 = await this.getDeviceId();
      options.headers[DeviceIdHeaderName] = deviceId2;
    }
    if ((options == null ? void 0 : options.withBasicAuth) && this.basicAuth) {
      options.headers.Authorization = this.basicAuth;
    }
    if (options == null ? void 0 : options.withCredentials) {
      const credentials = await this.getCredentials();
      if (credentials) {
        if (this.tokenInURL) {
          if (url.indexOf("?") < 0) {
            url += "?";
          }
          url += `access_token=${credentials.access_token}`;
        } else {
          options.headers.Authorization = `${credentials.token_type} ${credentials.access_token}`;
        }
      }
    } else {
      if (this.clientId && url.indexOf("client_id") < 0) {
        url += url.indexOf("?") < 0 ? "?" : "&";
        url += `client_id=${this.clientId}`;
      }
    }
    if (url.startsWith("/")) {
      url = this.apiOrigin + url;
    }
    let response = null;
    const maxRequestTimes = retry + 1;
    for (let requestTime = 0; requestTime < maxRequestTimes; requestTime++) {
      try {
        if (options.useWxCloud) {
          response = await this.wxCloudCallFunction(url, options);
        } else {
          response = await this.baseRequest(url, options);
        }
        break;
      } catch (responseError) {
        if (options.withCredentials && responseError && responseError.error === ErrorType.UNAUTHENTICATED) {
          await this.setCredentials(null);
          return Promise.reject(responseError);
        }
        if (requestTime === retry || !responseError || responseError.error !== "unreachable") {
          return Promise.reject(responseError);
        }
      }
      await this.sleep(OAuth2Client.retryInterval);
    }
    return response;
  }
  async wxCloudCallFunction(url, options) {
    var _a2;
    let result = null;
    let responseError = null;
    try {
      let userAgent = "";
      try {
        userAgent = await wx$1.getRendererUserAgent();
      } catch (error) {
      }
      const { result: responseResult } = await this.wxCloud.callFunction({
        name: "httpOverCallFunction",
        data: {
          url,
          method: options.method,
          headers: {
            origin: "https://servicewechat.com",
            "User-Agent": userAgent,
            ...options.headers
          },
          body: options.body
        }
      });
      if ((_a2 = responseResult == null ? void 0 : responseResult.body) == null ? void 0 : _a2.error_code) {
        responseError = responseResult == null ? void 0 : responseResult.body;
        responseError.error_uri = getPathName(url);
      } else {
        result = responseResult == null ? void 0 : responseResult.body;
      }
    } catch (error) {
      responseError = {
        error: ErrorType.UNREACHABLE,
        error_description: error.message,
        error_uri: getPathName(url)
      };
    }
    if (responseError) {
      throw responseError;
    } else {
      return result;
    }
  }
  async getCredentials() {
    let credentials = await this.localCredentials.getCredentials();
    if (!credentials) {
      return this.unAuthenticatedError("credentials not found");
    }
    if (isCredentialsExpired(credentials)) {
      if (credentials && credentials.scope === "anonymous") {
        if (this.anonymousSignInFunc) {
          const c2 = await this.anonymousSignInFunc(credentials);
          credentials = c2 || await this.localCredentials.getCredentials();
        } else {
          credentials = await this.anonymousSignIn(credentials);
        }
      } else {
        credentials = await this.refreshToken(credentials);
      }
    }
    return credentials;
  }
  getCredentialsSync() {
    const credentials = this.localCredentials.getStorageCredentialsSync();
    return credentials;
  }
  getCredentialsAsync() {
    return this.getCredentials();
  }
  async getScope() {
    const credentials = await this.localCredentials.getCredentials();
    if (!credentials) {
      return this.unAuthenticatedError("credentials not found");
    }
    return credentials.scope;
  }
  async getGroups() {
    const credentials = await this.localCredentials.getCredentials();
    if (!credentials) {
      return this.unAuthenticatedError("credentials not found");
    }
    return credentials.groups;
  }
  async refreshToken(credentials) {
    return this.singlePromise.run("_refreshToken", async () => {
      if (!credentials || !credentials.refresh_token) {
        return this.unAuthenticatedError("no refresh token found in credentials");
      }
      try {
        const newCredentials = await this.refreshTokenFunc(credentials.refresh_token, credentials);
        await this.localCredentials.setCredentials(newCredentials);
        return newCredentials;
      } catch (error) {
        if (error.error === ErrorType.INVALID_GRANT) {
          await this.localCredentials.setCredentials(null);
          return this.unAuthenticatedError(error.error_description);
        }
        return Promise.reject(error);
      }
    });
  }
  checkRetry(retry) {
    let responseError = null;
    if (typeof retry !== "number" || retry < OAuth2Client.minRetry || retry > OAuth2Client.maxRetry) {
      responseError = {
        error: ErrorType.UNREACHABLE,
        error_description: "wrong options param: retry"
      };
    }
    if (responseError) {
      throw responseError;
    }
    return retry;
  }
  formatRetry(retry, defaultVale) {
    if (typeof retry === "undefined") {
      return defaultVale;
    }
    return this.checkRetry(retry);
  }
  async sleep(ms) {
    return new Promise((resolve2) => {
      setTimeout(() => {
        resolve2();
      }, ms);
    });
  }
  async anonymousSignIn(credentials) {
    return this.singlePromise.run("_anonymous", async () => {
      if (!credentials || credentials.scope !== "anonymous") {
        return this.unAuthenticatedError("no anonymous in credentials");
      }
      try {
        const newCredentials = await this.request(ApiUrls.AUTH_SIGN_IN_ANONYMOUSLY_URL, {
          method: "POST",
          withBasicAuth: true,
          body: {}
        });
        await this.localCredentials.setCredentials(newCredentials);
        return newCredentials;
      } catch (error) {
        if (error.error === ErrorType.INVALID_GRANT) {
          await this.localCredentials.setCredentials(null);
          return this.unAuthenticatedError(error.error_description);
        }
        return Promise.reject(error);
      }
    });
  }
  async defaultRefreshTokenFunc(refreshToken, credentials) {
    if (refreshToken === void 0 || refreshToken === "") {
      return this.unAuthenticatedError("refresh token not found");
    }
    let url = ApiUrls.AUTH_TOKEN_URL;
    if ((credentials == null ? void 0 : credentials.version) === "v2") {
      url = ApiUrlsV2.AUTH_TOKEN_URL;
    }
    const newCredentials = await this.request(url, {
      method: "POST",
      body: {
        client_id: this.clientId,
        client_secret: this.clientSecret,
        grant_type: "refresh_token",
        refresh_token: refreshToken
      }
    });
    return { ...newCredentials, version: (credentials == null ? void 0 : credentials.version) || "v1" };
  }
  async getDeviceId() {
    if (this.deviceID) {
      return this.deviceID;
    }
    let deviceId2 = await this.storage.getItem(DeviceIdSectionName);
    if (!(typeof deviceId2 === "string" && deviceId2.length >= 16 && deviceId2.length <= 48)) {
      deviceId2 = uuidv4();
      await this.storage.setItem(DeviceIdSectionName, deviceId2);
    }
    this.deviceID = deviceId2;
    return deviceId2;
  }
  unAuthenticatedError(err) {
    const respErr = {
      error: ErrorType.UNAUTHENTICATED,
      error_description: err
    };
    return Promise.reject(respErr);
  }
}
OAuth2Client.defaultRetry = 2;
OAuth2Client.minRetry = 0;
OAuth2Client.maxRetry = 5;
OAuth2Client.retryInterval = 1e3;
function isMp() {
  const { wx: wx2 } = globalThis;
  if (typeof wx2 === "undefined") {
    return false;
  }
  if (globalThis.Page === void 0) {
    return false;
  }
  if (!wx2.getSystemInfoSync) {
    return false;
  }
  if (!wx2.getStorageSync) {
    return false;
  }
  if (!wx2.setStorageSync) {
    return false;
  }
  if (!wx2.connectSocket) {
    return false;
  }
  if (!wx2.request) {
    return false;
  }
  try {
    if (!wx2.getSystemInfoSync()) {
      return false;
    }
    if (wx2.getSystemInfoSync().AppPlatform === "qq") {
      return false;
    }
  } catch (e2) {
    return false;
  }
  return true;
}
let IS_IN_MP_WEBVIEW = false;
function ready() {
  IS_IN_MP_WEBVIEW = IS_IN_MP_WEBVIEW || typeof window !== void 0 && window.__wxjs_environment === "miniprogram";
}
try {
  if (!isMp()) {
    IS_IN_MP_WEBVIEW = IS_IN_MP_WEBVIEW || !!navigator.userAgent.match(/miniprogram/i) || window.__wxjs_environment === "miniprogram";
    if (window && window.WeixinJSBridge && window.WeixinJSBridge.invoke) {
      ready();
    } else if (typeof document !== "undefined") {
      document.addEventListener("WeixinJSBridgeReady", ready, false);
    }
  }
} catch (e2) {
}
function isInMpWebView() {
  return IS_IN_MP_WEBVIEW;
}
class MyURLSearchParams {
  constructor(init) {
    this.params = {};
    if (typeof init === "string") {
      this.parse(init);
    } else if (init && typeof init === "object") {
      for (const key in init) {
        if (Object.prototype.hasOwnProperty.call(init, key)) {
          this.append(key, init[key]);
        }
      }
    }
  }
  parse(str) {
    const params = str.split("&");
    params.forEach((param) => {
      const [key, value] = param.split("=").map(decodeURIComponent);
      this.append(key, value);
    });
  }
  append(key, value) {
    if (this.params[key]) {
      this.params[key] = this.params[key].concat([value]);
    } else {
      this.params[key] = [value];
    }
  }
  get(key) {
    return this.params[key] ? this.params[key][0] : null;
  }
  getAll(key) {
    return this.params[key] || [];
  }
  delete(key) {
    delete this.params[key];
  }
  has(key) {
    return Object.prototype.hasOwnProperty.call(this.params, key);
  }
  set(key, value) {
    this.params[key] = [value];
  }
  toString() {
    const items = [];
    for (const key in this.params) {
      if (Object.prototype.hasOwnProperty.call(this.params, key)) {
        this.params[key].forEach((value) => {
          items.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
        });
      }
    }
    return items.join("&");
  }
}
class Captcha {
  constructor(opts) {
    if (!opts.openURIWithCallback) {
      opts.openURIWithCallback = this.getDefaultOpenURIWithCallback();
    }
    if (!opts.storage) {
      opts.storage = defaultStorage;
    }
    this.config = opts;
    this.tokenSectionName = `captcha_${opts.clientId}`;
  }
  async request(url, options) {
    if (!options) {
      options = {};
    }
    if (!options.method) {
      options.method = "GET";
    }
    const state = `${options.method}:${url}`;
    let reqURL = url;
    if (options.withCaptcha) {
      reqURL = await this.appendCaptchaTokenToURL(url, state, false);
    }
    let resp;
    try {
      resp = await this.config.request(reqURL, options);
    } catch (err) {
      if (err.error === ErrorType.CAPTCHA_REQUIRED || err.error === ErrorType.CAPTCHA_INVALID) {
        url = await this.appendCaptchaTokenToURL(url, state, err.error === ErrorType.CAPTCHA_INVALID);
        return this.config.request(url, options);
      }
      return Promise.reject(err);
    }
    return resp;
  }
  getDefaultOpenURIWithCallback() {
    if (!isMp() && !isInMpWebView()) {
      if (window.location.search.indexOf("__captcha") > 0) {
        document.body.style.display = "none";
      }
      if (document.getElementById("captcha_panel_wrap") === null) {
        const elementDiv = document.createElement("div");
        elementDiv.style.cssText = "background-color: rgba(0, 0, 0, 0.7);position: fixed;left: 0px;right: 0px;top: 0px;bottom: 0px;padding: 9vw 0 0 0;display: none;z-index:100;";
        elementDiv.setAttribute("id", "captcha_panel_wrap");
        setTimeout(() => {
          document.body.appendChild(elementDiv);
        }, 0);
      }
    }
    return this.defaultOpenURIWithCallback;
  }
  async defaultOpenURIWithCallback(url, opts) {
    const { width = "355px", height = "355px" } = opts || {};
    const matched = url.match(/^(data:.*)$/);
    if (matched) {
      return Promise.reject({
        error: ErrorType.UNIMPLEMENTED,
        error_description: "need to impl captcha data"
      });
    }
    const target = document.getElementById("captcha_panel_wrap");
    const iframe = document.createElement("iframe");
    target.innerHTML = "";
    iframe.setAttribute("src", url);
    iframe.setAttribute("id", "review-panel-iframe");
    iframe.style.cssText = `min-width:${width};display:block;height:${height};margin:0 auto;background-color: rgb(255, 255, 255);border: none;`;
    target.appendChild(iframe);
    target.style.display = "block";
    return new Promise((resolve2, reject) => {
      iframe.onload = function() {
        try {
          const windowLocation = window.location;
          const iframeLocation = iframe.contentWindow.location;
          if (iframeLocation.host + iframeLocation.pathname === windowLocation.host + windowLocation.pathname) {
            target.style.display = "none";
            const iframeUrlParams = new MyURLSearchParams(iframeLocation.search);
            const captchToken = iframeUrlParams.get("captcha_token");
            if (captchToken) {
              return resolve2({
                captcha_token: captchToken,
                expires_in: Number(iframeUrlParams.get("expires_in"))
              });
            }
            return reject({
              error: iframeUrlParams.get("error"),
              error_description: iframeUrlParams.get("error_description")
            });
          }
          target.style.display = "block";
        } catch (error) {
          target.style.display = "block";
        }
      };
    });
  }
  async getCaptchaToken(forceNewToken, state) {
    if (!forceNewToken) {
      const captchaToken2 = await this.findCaptchaToken();
      if (captchaToken2) {
        return captchaToken2;
      }
    }
    let captchaTokenResp;
    if (!isMp() && !isInMpWebView()) {
      const redirect_uri = `${window.location.origin + window.location.pathname}?__captcha=on`;
      captchaTokenResp = await this.config.request(ApiUrls.GET_CAPTCHA_URL, {
        method: "POST",
        body: {
          client_id: this.config.clientId,
          redirect_uri,
          state
        },
        withCredentials: false
      });
      if (captchaTokenResp.captcha_token) {
        const captchaToken2 = {
          captcha_token: captchaTokenResp.captcha_token,
          expires_in: captchaTokenResp.expires_in
        };
        this.saveCaptchaToken(captchaToken2);
        return captchaTokenResp.captcha_token;
      }
    } else {
      const captchaDataResp = await this.config.request(ApiUrls.CAPTCHA_DATA_URL, {
        method: "POST",
        body: {
          state,
          redirect_uri: ""
        },
        withCredentials: false
      });
      captchaTokenResp = {
        url: `${captchaDataResp.data}?state=${encodeURIComponent(state)}&token=${encodeURIComponent(captchaDataResp.token)}`
      };
    }
    const captchaToken = await this.config.openURIWithCallback(captchaTokenResp.url);
    this.saveCaptchaToken(captchaToken);
    return captchaToken.captcha_token;
  }
  async appendCaptchaTokenToURL(url, state, forceNewToken) {
    const captchaToken = await this.getCaptchaToken(forceNewToken, state);
    if (url.indexOf("?") > 0) {
      url += `&captcha_token=${captchaToken}`;
    } else {
      url += `?captcha_token=${captchaToken}`;
    }
    return url;
  }
  async saveCaptchaToken(token) {
    token.expires_at = new Date(Date.now() + (token.expires_in - 10) * 1e3);
    const tokenStr = JSON.stringify(token);
    await this.config.storage.setItem(this.tokenSectionName, tokenStr);
  }
  async findCaptchaToken() {
    const tokenStr = await this.config.storage.getItem(this.tokenSectionName);
    if (tokenStr !== void 0 && tokenStr !== null) {
      try {
        const captchaToken = JSON.parse(tokenStr);
        if (captchaToken == null ? void 0 : captchaToken.expires_at) {
          captchaToken.expires_at = new Date(captchaToken.expires_at);
        }
        const isExpired = captchaToken.expires_at < /* @__PURE__ */ new Date();
        if (isExpired) {
          return null;
        }
        return captchaToken.captcha_token;
      } catch (error) {
        await this.config.storage.removeItem(this.tokenSectionName);
        return null;
      }
    }
    return null;
  }
}
function getEncryptUtils(isEncrypt) {
  if (globalThis.IS_MP_BUILD) {
    return;
  }
  if (isEncrypt) {
    const utils2 = require("../utils/encrypt");
    return utils2;
  }
}
let Auth$1 = class Auth {
  static parseParamsToSearch(params) {
    Object.keys(params).forEach((key) => {
      if (!params[key]) {
        delete params[key];
      }
    });
    const searchParams = new MyURLSearchParams(params);
    return searchParams.toString();
  }
  constructor(opts) {
    let { request } = opts;
    let oAuth2Client = opts.credentialsClient;
    if (!oAuth2Client) {
      const initOptions = {
        apiOrigin: opts.apiOrigin,
        clientId: opts.clientId,
        storage: opts.storage,
        env: opts.env,
        baseRequest: opts.baseRequest,
        anonymousSignInFunc: opts.anonymousSignInFunc,
        wxCloud: opts.wxCloud
      };
      oAuth2Client = new OAuth2Client(initOptions);
    }
    if (!request) {
      const baseRequest = oAuth2Client.request.bind(oAuth2Client);
      const captcha = new Captcha({
        clientId: opts.clientId,
        request: baseRequest,
        storage: opts.storage,
        ...opts.captchaOptions
      });
      request = captcha.request.bind(captcha);
    }
    this.config = {
      env: opts.env,
      apiOrigin: opts.apiOrigin,
      clientId: opts.clientId,
      request,
      credentialsClient: oAuth2Client,
      storage: opts.storage || defaultStorage
    };
  }
  getParamsByVersion(params, key) {
    var _a2;
    const paramsTemp = deepClone(params);
    const url = ((_a2 = { v2: ApiUrlsV2 }[paramsTemp == null ? void 0 : paramsTemp.version]) == null ? void 0 : _a2[key]) || ApiUrls[key];
    if (paramsTemp) {
      delete paramsTemp.version;
    }
    return { params: paramsTemp, url };
  }
  async signIn(params) {
    const version2 = params.version || "v1";
    const res = this.getParamsByVersion(params, "AUTH_SIGN_IN_URL");
    if (res.params.query) {
      delete res.params.query;
    }
    const body = await this.getEncryptParams(res.params);
    const credentials = await this.config.request(res.url, {
      method: "POST",
      body
    });
    await this.config.credentialsClient.setCredentials({
      ...credentials,
      version: version2
    });
    return Promise.resolve(credentials);
  }
  async signInAnonymously(data = {}, useWxCloud = false) {
    const credentials = await this.config.request(ApiUrls.AUTH_SIGN_IN_ANONYMOUSLY_URL, {
      method: "POST",
      body: data,
      useWxCloud
    });
    await this.config.credentialsClient.setCredentials(credentials);
    return Promise.resolve(credentials);
  }
  async signUp(params) {
    const data = await this.config.request(ApiUrls.AUTH_SIGN_UP_URL, {
      method: "POST",
      body: params
    });
    await this.config.credentialsClient.setCredentials(data);
    return Promise.resolve(data);
  }
  async signOut(params) {
    let resp = {};
    if (params) {
      try {
        resp = await this.config.request(ApiUrls.AUTH_SIGNOUT_URL, {
          method: "POST",
          withCredentials: true,
          body: params
        });
      } catch (err) {
        if (err.error !== ErrorType.UNAUTHENTICATED) {
          console.log("sign_out_error", err);
        }
      }
      await this.config.credentialsClient.setCredentials();
      return resp;
    }
    const accessToken = await this.config.credentialsClient.getAccessToken();
    const data = await this.config.request(ApiUrls.AUTH_REVOKE_URL, {
      method: "POST",
      body: {
        token: accessToken
      }
    });
    await this.config.credentialsClient.setCredentials();
    return Promise.resolve(data);
  }
  async revokeAllDevices() {
    await this.config.request(ApiUrls.AUTH_REVOKE_ALL_URL, {
      method: "DELETE",
      withCredentials: true
    });
  }
  async revokeDevice(params) {
    await this.config.request(ApiUrls.AUTHORIZED_DEVICES_DELETE_URL + params.device_id, {
      method: "DELETE",
      withCredentials: true
    });
  }
  async getVerification(params, options) {
    let withCredentials = false;
    if (params.target === "CUR_USER") {
      withCredentials = true;
    } else {
      const hasLogin = await this.hasLoginState();
      if (hasLogin) {
        withCredentials = true;
      }
    }
    return this.config.request(ApiUrls.VERIFICATION_URL, {
      method: "POST",
      body: params,
      withCaptcha: (options == null ? void 0 : options.withCaptcha) || false,
      withCredentials
    });
  }
  async verify(params) {
    const res = this.getParamsByVersion(params, "VERIFY_URL");
    const data = await this.config.request(res.url, {
      method: "POST",
      body: res.params
    });
    if ((params == null ? void 0 : params.version) === "v2") {
      await this.config.credentialsClient.setCredentials({
        ...data,
        version: "v2"
      });
    }
    return data;
  }
  async genProviderRedirectUri(params) {
    const { provider_redirect_uri: redirect_uri, other_params: otherParams = {}, ...restParams } = params;
    if (redirect_uri && !restParams.redirect_uri) {
      restParams.redirect_uri = redirect_uri;
    }
    let url = `${ApiUrls.PROVIDER_URI_URL}?${Auth.parseParamsToSearch(restParams)}`;
    Object.keys(otherParams).forEach((key) => {
      const value = otherParams[key];
      if (key === "sign_out_uri" && !((value == null ? void 0 : value.length) > 0)) {
        return;
      }
      url += `&other_params[${key}]=${encodeURIComponent(value)}`;
    });
    return this.config.request(url, {
      method: "GET"
    });
  }
  async grantProviderToken(params, useWxCloud = false) {
    return this.config.request(ApiUrls.PROVIDER_TOKEN_URL, {
      method: "POST",
      body: params,
      useWxCloud
    });
  }
  async patchProviderToken(params) {
    return this.config.request(ApiUrls.PROVIDER_TOKEN_URL, {
      method: "PATCH",
      body: params
    });
  }
  async signInWithProvider(params, useWxCloud = false) {
    const res = this.getParamsByVersion(params, "AUTH_SIGN_IN_WITH_PROVIDER_URL");
    const credentials = await this.config.request(res.url, {
      method: "POST",
      body: res.params,
      useWxCloud
    });
    await this.config.credentialsClient.setCredentials({
      ...credentials,
      version: (params == null ? void 0 : params.version) || "v1"
    });
    return Promise.resolve(credentials);
  }
  async signInCustom(params) {
    const credentials = await this.config.request(ApiUrls.AUTH_SIGN_IN_CUSTOM, {
      method: "POST",
      body: params
    });
    await this.config.credentialsClient.setCredentials(credentials);
    return Promise.resolve(credentials);
  }
  async signInWithWechat(params = {}) {
    const credentials = await this.config.request(ApiUrls.AUTH_SIGN_IN_WITH_WECHAT_URL, {
      method: "POST",
      body: params
    });
    await this.config.credentialsClient.setCredentials(credentials);
    return Promise.resolve(credentials);
  }
  async bindWithProvider(params) {
    return this.config.request(ApiUrls.PROVIDER_BIND_URL, {
      method: "POST",
      body: params,
      withCredentials: true
    });
  }
  async getUserProfile(params) {
    return this.getUserInfo(params);
  }
  async getUserInfo(params = {}) {
    var _a2;
    const res = this.getParamsByVersion(params, "USER_ME_URL");
    if ((_a2 = res.params) == null ? void 0 : _a2.query) {
      const searchParams = new MyURLSearchParams(res.params.query);
      res.url += `?${searchParams.toString()}`;
    }
    const userInfo = await this.config.request(res.url, {
      method: "GET",
      withCredentials: true
    });
    if (userInfo.sub) {
      userInfo.uid = userInfo.sub;
    }
    return userInfo;
  }
  async getWedaUserInfo() {
    const userInfo = await this.config.request(ApiUrls.WEDA_USER_URL, {
      method: "GET",
      withCredentials: true
    });
    return userInfo;
  }
  async deleteMe(params) {
    const res = this.getParamsByVersion(params, "USER_ME_URL");
    const url = `${res.url}?${Auth.parseParamsToSearch(res.params)}`;
    return this.config.request(url, {
      method: "DELETE",
      withCredentials: true
    });
  }
  async hasLoginState() {
    try {
      await this.config.credentialsClient.getAccessToken();
      return true;
    } catch (error) {
      return false;
    }
  }
  hasLoginStateSync() {
    const credentials = this.config.credentialsClient.getCredentialsSync();
    return credentials;
  }
  async getLoginState() {
    return this.config.credentialsClient.getCredentialsAsync();
  }
  async transByProvider(params) {
    return this.config.request(ApiUrls.USER_TRANS_BY_PROVIDER_URL, {
      method: "PATCH",
      body: params,
      withCredentials: true
    });
  }
  async grantToken(params) {
    const res = this.getParamsByVersion(params, "AUTH_TOKEN_URL");
    return this.config.request(res.url, {
      method: "POST",
      body: res.params
    });
  }
  async getProviders() {
    return this.config.request(ApiUrls.PROVIDER_LIST, {
      method: "GET",
      withCredentials: true
    });
  }
  async unbindProvider(params) {
    return this.config.request(`${ApiUrls.PROVIDER_UNBIND_URL}/${params.provider_id}`, {
      method: "DELETE",
      withCredentials: true
    });
  }
  async checkPassword(params) {
    return this.config.request(`${ApiUrls.CHECK_PWD_URL}`, {
      method: "POST",
      withCredentials: true,
      body: params
    });
  }
  async editContact(params) {
    return this.config.request(`${ApiUrls.BIND_CONTACT_URL}`, {
      method: "PATCH",
      withCredentials: true,
      body: params
    });
  }
  async setPassword(params) {
    return this.config.request(`${ApiUrls.AUTH_SET_PASSWORD}`, {
      method: "PATCH",
      withCredentials: true,
      body: params
    });
  }
  async updatePasswordByOld(params) {
    const sudoToken = await this.sudo({ password: params.old_password });
    return this.setPassword({
      sudo_token: sudoToken.sudo_token,
      new_password: params.new_password
    });
  }
  async sudo(params) {
    return this.config.request(`${ApiUrls.SUDO_URL}`, {
      method: "POST",
      withCredentials: true,
      body: params
    });
  }
  async sendVerificationCodeToCurrentUser(params) {
    params.target = "CUR_USER";
    return this.config.request(ApiUrls.VERIFICATION_URL, {
      method: "POST",
      body: params,
      withCredentials: true,
      withCaptcha: true
    });
  }
  async changeBoundProvider(params) {
    return this.config.request(`${ApiUrls.PROVIDER_LIST}/${params.provider_id}/trans`, {
      method: "POST",
      body: {
        provider_trans_token: params.trans_token
      },
      withCredentials: true
    });
  }
  async setUserProfile(params) {
    return this.config.request(ApiUrls.USER_PRIFILE_URL, {
      method: "PATCH",
      body: params,
      withCredentials: true
    });
  }
  async updateUserBasicInfo(params) {
    return this.config.request(ApiUrls.USER_BASIC_EDIT_URL, {
      method: "POST",
      withCredentials: true,
      body: params
    });
  }
  async queryUserProfile(params) {
    const searchParams = new MyURLSearchParams(params);
    return this.config.request(`${ApiUrls.USER_QUERY_URL}?${searchParams.toString()}`, {
      method: "GET",
      withCredentials: true
    });
  }
  setCustomSignFunc(getTickFn) {
    this.getCustomSignTicketFn = getTickFn;
  }
  async signInWithCustomTicket() {
    const customSignTicketFn = this.getCustomSignTicketFn;
    if (!customSignTicketFn) {
      return Promise.reject({
        error: "failed_precondition",
        error_description: "please use setCustomSignFunc to set custom sign function"
      });
    }
    const customTicket = await customSignTicketFn();
    return this.signInCustom({
      provider_id: "custom",
      ticket: customTicket
    });
  }
  async resetPassword(params) {
    return this.config.request(ApiUrls.AUTH_RESET_PASSWORD, {
      method: "POST",
      body: params
    });
  }
  async authorize(params) {
    return this.config.request(ApiUrls.AUTHORIZE_URL, {
      method: "POST",
      withCredentials: true,
      body: params
    });
  }
  async authorizeDevice(params) {
    return this.config.request(ApiUrls.AUTHORIZE_DEVICE_URL, {
      method: "POST",
      withCredentials: true,
      body: params
    });
  }
  async deviceAuthorize(params) {
    return this.config.request(ApiUrls.AUTH_GET_DEVICE_CODE, {
      method: "POST",
      body: params,
      withCredentials: true
    });
  }
  async authorizeInfo(params) {
    const url = `${ApiUrls.AUTHORIZE_INFO_URL}?${Auth.parseParamsToSearch(params)}`;
    let withBasicAuth = true;
    let withCredentials = false;
    const hasLogin = await this.hasLoginState();
    if (hasLogin) {
      withCredentials = true;
      withBasicAuth = false;
    }
    return this.config.request(url, {
      method: "GET",
      withBasicAuth,
      withCredentials
    });
  }
  async checkUsername(params) {
    return this.config.request(ApiUrls.CHECK_USERNAME, {
      method: "GET",
      body: params,
      withCredentials: true
    });
  }
  async checkIfUserExist(params) {
    const searchParams = new MyURLSearchParams(params);
    return this.config.request(`${ApiUrls.CHECK_IF_USER_EXIST}?${searchParams.toString()}`, {
      method: "GET"
    });
  }
  async loginScope() {
    return this.config.credentialsClient.getScope();
  }
  async loginGroups() {
    return this.config.credentialsClient.getGroups();
  }
  async refreshTokenForce(params) {
    const credentials = await this.config.credentialsClient.getCredentials();
    return await this.config.credentialsClient.refreshToken({
      ...credentials,
      version: (params == null ? void 0 : params.version) || "v1"
    });
  }
  async getCredentials() {
    return this.config.credentialsClient.getCredentials();
  }
  async getPublicKey() {
    return this.config.request(ApiUrlsV2.AUTH_PUBLIC_KEY, {
      method: "POST",
      body: {}
    });
  }
  async getEncryptParams(params) {
    const { isEncrypt } = params;
    delete params.isEncrypt;
    const payload = deepClone(params);
    const encryptUtils = getEncryptUtils(isEncrypt);
    if (!encryptUtils) {
      return params;
    }
    let publicKey = "";
    let public_key_thumbprint = "";
    try {
      const res = await this.getPublicKey();
      publicKey = res.public_key;
      public_key_thumbprint = res.public_key_thumbprint;
      if (!publicKey || !public_key_thumbprint) {
        throw res;
      }
    } catch (error) {
      throw error;
    }
    return {
      params: encryptUtils.getEncryptInfo({ publicKey, payload }),
      public_key_thumbprint
    };
  }
  async getProviderSubType() {
    return this.config.request(ApiUrls.GET_PROVIDER_TYPE, {
      method: "POST",
      body: {
        provider_id: "weda"
      }
    });
  }
  async verifyCaptchaData({ token, key }) {
    return this.config.request(ApiUrls.VERIFY_CAPTCHA_DATA_URL, {
      method: "POST",
      body: { token, key },
      withCredentials: false
    });
  }
  async createCaptchaData({ state, redirect_uri = void 0 }) {
    return this.config.request(ApiUrls.CAPTCHA_DATA_URL, {
      method: "POST",
      body: { state, redirect_uri },
      withCredentials: false
    });
  }
  async getMiniProgramCode(params) {
    return this.config.request(ApiUrls.GET_MINIPROGRAM_QRCODE, {
      method: "POST",
      body: params
    });
  }
  async getMiniProgramQrCodeStatus(params) {
    return this.config.request(ApiUrls.GET_MINIPROGRAM_QRCODE_STATUS, {
      method: "POST",
      body: params
    });
  }
  async getUserBehaviorLog(params) {
    const action = { LOGIN: "query[action]=USER_LOGIN", MODIFY: "ne_query[action]=USER_LOGIN" };
    const url = `${ApiUrls.GET_USER_BEHAVIOR_LOG}?${action[params.type]}&limit=${params.limit}${params.page_token ? `&page_token=${params.page_token}` : ""}`;
    return this.config.request(url, {
      method: "GET",
      withCredentials: true
    });
  }
  async modifyPassword(params) {
    let publicKey = "";
    let public_key_thumbprint = "";
    const encryptUtils = getEncryptUtils(true);
    if (!encryptUtils) {
      throw new Error("do not support encrypt, a encrypt util required.");
    }
    try {
      const res = await this.getPublicKey();
      publicKey = res.public_key;
      public_key_thumbprint = res.public_key_thumbprint;
      if (!publicKey || !public_key_thumbprint) {
        throw res;
      }
    } catch (error) {
      throw error;
    }
    const encrypt_password = params.password ? encryptUtils.getEncryptInfo({ publicKey, payload: params.password }) : "";
    const encrypt_new_password = encryptUtils.getEncryptInfo({ publicKey, payload: params.new_password });
    return this.config.request(ApiUrls.USER_BASIC_EDIT_URL, {
      method: "POST",
      withCredentials: true,
      body: {
        user_id: params.user_id,
        encrypt_password,
        encrypt_new_password,
        public_key_thumbprint
      }
    });
  }
  async modifyPasswordWithoutLogin(params) {
    let publicKey = "";
    let public_key_thumbprint = "";
    const encryptUtils = getEncryptUtils(true);
    if (!encryptUtils) {
      throw new Error("do not support encrypt, a encrypt util required.");
    }
    try {
      const res = await this.getPublicKey();
      publicKey = res.public_key;
      public_key_thumbprint = res.public_key_thumbprint;
      if (!publicKey || !public_key_thumbprint) {
        throw res;
      }
    } catch (error) {
      throw error;
    }
    const encrypt_password = params.password ? encryptUtils.getEncryptInfo({ publicKey, payload: params.password }) : "";
    const encrypt_new_password = encryptUtils.getEncryptInfo({ publicKey, payload: params.new_password });
    return this.config.request(ApiUrlsV2.AUTH_RESET_PASSWORD, {
      method: "POST",
      body: {
        username: params.username,
        password: encrypt_password,
        new_password: encrypt_new_password,
        public_key_thumbprint
      }
    });
  }
};
class CloudbaseOAuth {
  constructor(authOptions) {
    const { apiOrigin, clientId, env, storage, request, baseRequest, anonymousSignInFunc, wxCloud } = authOptions;
    this.oauth2client = new OAuth2Client({
      apiOrigin,
      clientId,
      env,
      storage,
      baseRequest: baseRequest || request,
      anonymousSignInFunc,
      wxCloud
    });
    this.authApi = new Auth$1({
      credentialsClient: this.oauth2client,
      ...authOptions,
      request: request ? this.oauth2client.request.bind(this.oauth2client) : void 0
    });
  }
}
var util = {};
var constants = {};
var common = {};
Object.defineProperty(common, "__esModule", { value: true });
common.COMMUNITY_SITE_URL = common.IS_DEBUG_MODE = common.getProtocol = common.setProtocol = common.getSdkName = common.setSdkName = void 0;
var sdkName = "@cloudbase/js-sdk";
function setSdkName(name2) {
  sdkName = name2;
}
common.setSdkName = setSdkName;
function getSdkName$2() {
  return sdkName;
}
common.getSdkName = getSdkName$2;
var PROTOCOL = "https:";
function setProtocol(protocol) {
  PROTOCOL = protocol;
}
common.setProtocol = setProtocol;
function getProtocol() {
  return PROTOCOL;
}
common.getProtocol = getProtocol;
common.IS_DEBUG_MODE = true;
common.COMMUNITY_SITE_URL = "https://support.qq.com/products/148793";
var errors = {};
Object.defineProperty(errors, "__esModule", { value: true });
errors.ERRORS = void 0;
errors.ERRORS = {
  INVALID_PARAMS: "INVALID_PARAMS",
  INVALID_SYNTAX: "INVALID_SYNTAX",
  INVALID_OPERATION: "INVALID_OPERATION",
  OPERATION_FAIL: "OPERATION_FAIL",
  NETWORK_ERROR: "NETWORK_ERROR",
  UNKOWN_ERROR: "UNKOWN_ERROR"
};
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.OATUH_LOGINTYPE = void 0;
  __exportStar(common, exports2);
  __exportStar(errors, exports2);
  exports2.OATUH_LOGINTYPE = "constants";
})(constants);
Object.defineProperty(util, "__esModule", { value: true });
util.transformPhone = util.sleep = util.printGroupLog = throwError_1 = util.throwError = util.printInfo = util.printError = printWarn_1 = util.printWarn = util.execCallback = util.createPromiseCallback = util.removeParam = util.getHash = util.getQuery = util.toQueryString = util.formatUrl = util.generateRequestId = util.genSeqId = util.isFormData = util.isInstanceOf = util.isNull = util.isPalinObject = util.isUndefined = util.isString = util.isArray = void 0;
var constants_1$2 = constants;
function isArray$4(val) {
  return Object.prototype.toString.call(val) === "[object Array]";
}
util.isArray = isArray$4;
function isString$2(val) {
  return typeof val === "string";
}
util.isString = isString$2;
function isUndefined(val) {
  return typeof val === "undefined";
}
util.isUndefined = isUndefined;
function isPalinObject$1(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
util.isPalinObject = isPalinObject$1;
function isNull(val) {
  return Object.prototype.toString.call(val) === "[object Null]";
}
util.isNull = isNull;
function isInstanceOf(instance, construct) {
  return instance instanceof construct;
}
util.isInstanceOf = isInstanceOf;
function isFormData(val) {
  return Object.prototype.toString.call(val) === "[object FormData]";
}
util.isFormData = isFormData;
function genSeqId() {
  return Math.random().toString(16).slice(2);
}
util.genSeqId = genSeqId;
function generateRequestId() {
  var d2 = (/* @__PURE__ */ new Date()).getTime();
  var d22 = (performance === null || performance === void 0 ? void 0 : performance.now) && performance.now() * 1e3 || 0;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
    var r2 = Math.random() * 16;
    if (d2 > 0) {
      r2 = (d2 + r2) % 16 | 0;
      d2 = Math.floor(d2 / 16);
    } else {
      r2 = (d22 + r2) % 16 | 0;
      d22 = Math.floor(d22 / 16);
    }
    return (c2 === "x" ? r2 : r2 & 7 | 8).toString(16);
  });
}
util.generateRequestId = generateRequestId;
function formatUrl(PROTOCOL2, url, query) {
  if (query === void 0) {
    query = {};
  }
  var urlHasQuery = /\?/.test(url);
  var queryString = "";
  Object.keys(query).forEach(function(key) {
    if (queryString === "") {
      !urlHasQuery && (url += "?");
    } else {
      queryString += "&";
    }
    queryString += "".concat(key, "=").concat(encodeURIComponent(query[key]));
  });
  url += queryString;
  if (/^http(s)?:\/\//.test(url)) {
    return url;
  }
  return "".concat(PROTOCOL2).concat(url);
}
util.formatUrl = formatUrl;
function toQueryString(query) {
  if (query === void 0) {
    query = {};
  }
  var queryString = [];
  Object.keys(query).forEach(function(key) {
    queryString.push("".concat(key, "=").concat(encodeURIComponent(query[key])));
  });
  return queryString.join("&");
}
util.toQueryString = toQueryString;
function getQuery(name2, url) {
  if (typeof window === "undefined") {
    return false;
  }
  var u2 = url || window.location.search;
  var reg = new RegExp("(^|&)".concat(name2, "=([^&]*)(&|$)"));
  var r2 = u2.substr(u2.indexOf("?") + 1).match(reg);
  return r2 !== null && r2 !== void 0 ? r2[2] : "";
}
util.getQuery = getQuery;
var getHash = function(name2) {
  if (typeof window === "undefined") {
    return "";
  }
  var matches = window.location.hash.match(new RegExp("[#?&/]".concat(name2, "=([^&#]*)")));
  return matches ? matches[1] : "";
};
util.getHash = getHash;
function removeParam(key, sourceURL) {
  var rtn = sourceURL.split("?")[0];
  var param;
  var params = [];
  var queryString = sourceURL.indexOf("?") !== -1 ? sourceURL.split("?")[1] : "";
  if (queryString !== "") {
    params = queryString.split("&");
    for (var i = params.length - 1; i >= 0; i -= 1) {
      param = params[i].split("=")[0];
      if (param === key) {
        params.splice(i, 1);
      }
    }
    rtn = "".concat(rtn, "?").concat(params.join("&"));
  }
  return rtn;
}
util.removeParam = removeParam;
function createPromiseCallback$1() {
  var cb;
  if (!Promise) {
    cb = function() {
    };
    cb.promise = {};
    var throwPromiseNotDefined = function() {
      throw new Error('Your Node runtime does support ES6 Promises. Set "global.Promise" to your preferred implementation of promises.');
    };
    Object.defineProperty(cb.promise, "then", { get: throwPromiseNotDefined });
    Object.defineProperty(cb.promise, "catch", { get: throwPromiseNotDefined });
    return cb;
  }
  var promise = new Promise(function(resolve2, reject) {
    cb = function(err, data) {
      if (err)
        return reject(err);
      return resolve2(data);
    };
  });
  cb.promise = promise;
  return cb;
}
util.createPromiseCallback = createPromiseCallback$1;
function execCallback$2(fn, err, data) {
  if (data === void 0) {
    data = null;
  }
  if (fn && typeof fn === "function") {
    return fn(err, data);
  }
  if (err) {
    throw err;
  }
  return data;
}
util.execCallback = execCallback$2;
function printWarn(error, msg) {
  console.warn("[".concat((0, constants_1$2.getSdkName)(), "][").concat(error, "]:").concat(msg));
}
var printWarn_1 = util.printWarn = printWarn;
function printError(error, msg) {
  console.error({
    code: error,
    msg: "[".concat((0, constants_1$2.getSdkName)(), "][").concat(error, "]:").concat(msg)
  });
}
util.printError = printError;
function printInfo(error, msg) {
  console.log("[".concat((0, constants_1$2.getSdkName)(), "][").concat(error, "]:").concat(msg));
}
util.printInfo = printInfo;
function throwError(error, msg) {
  throw new Error(JSON.stringify({
    code: error,
    msg: "[".concat((0, constants_1$2.getSdkName)(), "][").concat(error, "]:").concat(msg)
  }));
}
var throwError_1 = util.throwError = throwError;
function printGroupLog(options) {
  var title = options.title, _a2 = options.subtitle, subtitle = _a2 === void 0 ? "" : _a2, _b = options.content, content = _b === void 0 ? [] : _b, _c = options.printTrace, printTrace = _c === void 0 ? false : _c, _d = options.collapsed, collapsed = _d === void 0 ? false : _d;
  if (collapsed) {
    console.groupCollapsed(title, subtitle);
  } else {
    console.group(title, subtitle);
  }
  for (var _i = 0, content_1 = content; _i < content_1.length; _i++) {
    var tip = content_1[_i];
    var type = tip.type, body = tip.body;
    switch (type) {
      case "info":
        console.log(body);
        break;
      case "warn":
        console.warn(body);
        break;
      case "error":
        console.error(body);
        break;
    }
  }
  if (printTrace) {
    console.trace("stack trace:");
  }
  console.groupEnd();
}
util.printGroupLog = printGroupLog;
var sleep$1 = function(ms) {
  if (ms === void 0) {
    ms = 0;
  }
  return new Promise(function(r2) {
    return setTimeout(r2, ms);
  });
};
util.sleep = sleep$1;
function transformPhone(phoneNumber) {
  return "+86".concat(phoneNumber);
}
util.transformPhone = transformPhone;
var helpers = {};
var decorators = {};
var __awaiter$u = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$u = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(decorators, "__esModule", { value: true });
decorators.catchErrorsDecorator = void 0;
var util_1$3 = util;
var constants_1$1 = constants;
var isFirefox = false;
if (typeof navigator !== "undefined" && navigator.userAgent) {
  isFirefox = navigator.userAgent.indexOf("Firefox") !== -1;
}
var REG_STACK_DECORATE = isFirefox ? /(\.js\/)?__decorate(\$\d+)?<@.*\d$/ : /(\/\w+\.js\.)?__decorate(\$\d+)?\s*\(.*\)$/;
var REG_STACK_LINK = /https?:\/\/.+:\d*\/.*\.js:\d+:\d+/;
function catchErrorsDecorator$3(options) {
  var _a2 = options.mode, mode = _a2 === void 0 ? "async" : _a2, _b = options.customInfo, customInfo = _b === void 0 ? {} : _b, title = options.title, _c = options.messages, messages = _c === void 0 ? [] : _c;
  return function(target, methodName, descriptor) {
    if (!constants_1$1.IS_DEBUG_MODE) {
      return;
    }
    var className = customInfo.className || target.constructor.name;
    var fnName = customInfo.methodName || methodName;
    var fn = descriptor.value;
    var sourceLink = getSourceLink(new Error());
    if (mode === "sync") {
      descriptor.value = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var innerErr = getRewritedError({
          err: new Error(),
          className,
          methodName: fnName,
          sourceLink
        });
        try {
          return fn.apply(this, args);
        } catch (err) {
          var failErr = err;
          var errMsg = err.message, error = err.error, errorDescription = err.error_description;
          var logs = {
            title: title || "".concat(className, ".").concat(fnName, " failed"),
            content: [{
              type: "error",
              body: err
            }]
          };
          if (errMsg && /^\{.*\}$/.test(errMsg)) {
            var msg = JSON.parse(errMsg);
            logs.subtitle = errMsg;
            if (msg.code) {
              if (innerErr) {
                innerErr.code = msg.code;
                innerErr.msg = msg.msg;
              } else {
                err.code = msg.code;
                err.message = msg.msg;
              }
              failErr = innerErr || err;
              logs.content = messages.map(function(msg2) {
                return {
                  type: "info",
                  body: msg2
                };
              });
            }
          }
          if (error && errorDescription) {
            logs.subtitle = errorDescription;
            if (innerErr) {
              innerErr.code = error;
              innerErr.msg = errorDescription;
            } else {
              err.code = error;
              err.message = errorDescription;
            }
            failErr = innerErr || err;
            logs.content = messages.map(function(msg2) {
              return {
                type: "info",
                body: msg2
              };
            });
          }
          (0, util_1$3.printGroupLog)(logs);
          throw failErr;
        }
      };
    } else {
      descriptor.value = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter$u(this, void 0, void 0, function() {
          var innerErr, err_1, failErr, errMsg, error, errorDescription, logs, msg;
          return __generator$u(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                innerErr = getRewritedError({
                  err: new Error(),
                  className,
                  methodName: fnName,
                  sourceLink
                });
                _a3.label = 1;
              case 1:
                _a3.trys.push([1, 3, , 4]);
                return [4, fn.apply(this, args)];
              case 2:
                return [2, _a3.sent()];
              case 3:
                err_1 = _a3.sent();
                failErr = err_1;
                errMsg = err_1.message, error = err_1.error, errorDescription = err_1.error_description;
                logs = {
                  title: title || "".concat(className, ".").concat(fnName, " failed"),
                  content: [{
                    type: "error",
                    body: err_1
                  }]
                };
                if (errMsg && /^\{.*\}$/.test(errMsg)) {
                  msg = JSON.parse(errMsg);
                  logs.subtitle = msg;
                  if (msg.code) {
                    if (innerErr) {
                      innerErr.code = msg.code;
                      innerErr.message = msg.msg;
                    } else {
                      err_1.code = msg.code;
                      err_1.message = msg.msg;
                    }
                    failErr = innerErr || err_1;
                    logs.content = messages.map(function(msg2) {
                      return {
                        type: "info",
                        body: msg2
                      };
                    });
                  }
                }
                if (error && errorDescription) {
                  logs.subtitle = errorDescription;
                  if (innerErr) {
                    innerErr.code = error;
                    innerErr.msg = errorDescription;
                  } else {
                    err_1.code = error;
                    err_1.message = errorDescription;
                  }
                  failErr = innerErr || err_1;
                  logs.content = messages.map(function(msg2) {
                    return {
                      type: "info",
                      body: msg2
                    };
                  });
                }
                (0, util_1$3.printGroupLog)(logs);
                throw failErr;
              case 4:
                return [2];
            }
          });
        });
      };
    }
  };
}
decorators.catchErrorsDecorator = catchErrorsDecorator$3;
function getSourceLink(err) {
  var sourceLink = "";
  var outterErrStacks = err.stack.split("\n");
  var indexOfDecorator = outterErrStacks.findIndex(function(str) {
    return REG_STACK_DECORATE.test(str);
  });
  if (indexOfDecorator !== -1) {
    var match = REG_STACK_LINK.exec(outterErrStacks[indexOfDecorator + 1] || "");
    sourceLink = match ? match[0] : "";
  }
  return sourceLink;
}
function getRewritedError(options) {
  var err = options.err, className = options.className, methodName = options.methodName, sourceLink = options.sourceLink;
  if (!sourceLink) {
    return null;
  }
  var innerErrStack = err.stack.split("\n");
  var REG_STACK_INNER_METHOD = isFirefox ? /^catchErrorsDecorator\/<\/descriptor.value@.*\d$/ : new RegExp("".concat(className, "\\.descriptor.value\\s*\\[as\\s").concat(methodName, "\\]\\s*\\(.*\\)$"));
  var REG_STACK_INNER_METHOD_WITHOUT_LINK = isFirefox ? /^catchErrorsDecorator\/<\/descriptor.value/ : new RegExp("".concat(className, "\\.descriptor.value\\s*\\[as\\s").concat(methodName, "\\]"));
  var indexOfSource = innerErrStack.findIndex(function(str) {
    return REG_STACK_INNER_METHOD.test(str);
  });
  var innerErr;
  if (indexOfSource !== -1) {
    var realErrStack = innerErrStack.filter(function(v2, i) {
      return i > indexOfSource;
    });
    realErrStack.unshift(innerErrStack[indexOfSource].replace(REG_STACK_INNER_METHOD_WITHOUT_LINK, "".concat(className, ".").concat(methodName)).replace(REG_STACK_LINK, sourceLink));
    innerErr = new Error();
    innerErr.stack = "".concat(isFirefox ? "@debugger" : "Error", "\n").concat(realErrStack.join("\n"));
  }
  return innerErr;
}
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(decorators, exports2);
})(helpers);
var events = {};
var __extends$a = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __spreadArray$2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar2; i < l2; i++) {
      if (ar2 || !(i in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i);
        ar2[i] = from[i];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
Object.defineProperty(events, "__esModule", { value: true });
events.removeEventListener = events.activateEvent = events.addEventListener = CloudbaseEventEmitter_1 = events.CloudbaseEventEmitter = events.IErrorEvent = events.CloudbaseEvent = void 0;
var util_1$2 = util;
function customeAddEventListener(name2, listener, listeners) {
  listeners[name2] = listeners[name2] || [];
  listeners[name2].push(listener);
}
function customRemoveEventListener(name2, listener, listeners) {
  if (listeners === null || listeners === void 0 ? void 0 : listeners[name2]) {
    var index2 = listeners[name2].indexOf(listener);
    if (index2 !== -1) {
      listeners[name2].splice(index2, 1);
    }
  }
}
var CloudbaseEvent = /* @__PURE__ */ function() {
  function CloudbaseEvent2(name2, data) {
    this.data = data || null;
    this.name = name2;
  }
  return CloudbaseEvent2;
}();
events.CloudbaseEvent = CloudbaseEvent;
var IErrorEvent = function(_super) {
  __extends$a(IErrorEvent2, _super);
  function IErrorEvent2(error, data) {
    var _this = _super.call(this, "error", { error, data }) || this;
    _this.error = error;
    return _this;
  }
  return IErrorEvent2;
}(CloudbaseEvent);
events.IErrorEvent = IErrorEvent;
var CloudbaseEventEmitter$1 = function() {
  function CloudbaseEventEmitter2() {
    this.listeners = {};
  }
  CloudbaseEventEmitter2.prototype.on = function(name2, listener) {
    customeAddEventListener(name2, listener, this.listeners);
    return this;
  };
  CloudbaseEventEmitter2.prototype.off = function(name2, listener) {
    customRemoveEventListener(name2, listener, this.listeners);
    return this;
  };
  CloudbaseEventEmitter2.prototype.fire = function(event, data) {
    if ((0, util_1$2.isInstanceOf)(event, IErrorEvent)) {
      console.error(event.error);
      return this;
    }
    var ev = (0, util_1$2.isString)(event) ? new CloudbaseEvent(event, data || {}) : event;
    var name2 = ev.name;
    if (this.listens(name2)) {
      ev.target = this;
      var handlers = this.listeners[name2] ? __spreadArray$2([], this.listeners[name2], true) : [];
      for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
        var fn = handlers_1[_i];
        fn.call(this, ev);
      }
    }
    return this;
  };
  CloudbaseEventEmitter2.prototype.listens = function(name2) {
    return this.listeners[name2] && this.listeners[name2].length > 0;
  };
  return CloudbaseEventEmitter2;
}();
var CloudbaseEventEmitter_1 = events.CloudbaseEventEmitter = CloudbaseEventEmitter$1;
var eventEmitter = new CloudbaseEventEmitter$1();
function addEventListener(event, callback) {
  eventEmitter.on(event, callback);
}
events.addEventListener = addEventListener;
function activateEvent(event, data) {
  if (data === void 0) {
    data = {};
  }
  eventEmitter.fire(event, data);
}
events.activateEvent = activateEvent;
function removeEventListener(event, callback) {
  eventEmitter.off(event, callback);
}
events.removeEventListener = removeEventListener;
var cache = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(esm);
var __extends$9 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __awaiter$t = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$t = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(cache, "__esModule", { value: true });
var CloudbaseCache_1 = cache.CloudbaseCache = void 0;
var adapter_interface_1$1 = require$$0;
var util_1$1 = util;
var constants_1 = constants;
var TcbCacheObject = function(_super) {
  __extends$9(TcbCacheObject2, _super);
  function TcbCacheObject2(root2) {
    var _this = _super.call(this) || this;
    _this.root = root2;
    if (!root2.tcbCacheObject) {
      root2.tcbCacheObject = {};
    }
    return _this;
  }
  TcbCacheObject2.prototype.setItem = function(key, value) {
    this.root.tcbCacheObject[key] = value;
  };
  TcbCacheObject2.prototype.getItem = function(key) {
    return this.root.tcbCacheObject[key];
  };
  TcbCacheObject2.prototype.removeItem = function(key) {
    delete this.root.tcbCacheObject[key];
  };
  TcbCacheObject2.prototype.clear = function() {
    delete this.root.tcbCacheObject;
  };
  return TcbCacheObject2;
}(adapter_interface_1$1.AbstractStorage);
function createStorage(persistence, adapter2) {
  switch (persistence) {
    case "local":
      if (!adapter2.localStorage) {
        (0, util_1$1.printWarn)(constants_1.ERRORS.INVALID_PARAMS, "localStorage is not supported on current platform");
        return new TcbCacheObject(adapter2.root);
      }
      return adapter2.localStorage;
    case "none":
      return new TcbCacheObject(adapter2.root);
    default:
      if (!adapter2.localStorage) {
        (0, util_1$1.printWarn)(constants_1.ERRORS.INVALID_PARAMS, "localStorage is not supported on current platform");
        return new TcbCacheObject(adapter2.root);
      }
      return adapter2.localStorage;
  }
}
var CloudbaseCache = function() {
  function CloudbaseCache2(config) {
    this.keys = {};
    var persistence = config.persistence, _a2 = config.platformInfo, platformInfo = _a2 === void 0 ? {} : _a2, _b = config.keys, keys = _b === void 0 ? {} : _b;
    this.platformInfo = platformInfo;
    if (!this.storage) {
      this.persistenceTag = this.platformInfo.adapter.primaryStorage || persistence;
      this.storage = createStorage(this.persistenceTag, this.platformInfo.adapter);
      this.keys = keys;
    }
  }
  Object.defineProperty(CloudbaseCache2.prototype, "mode", {
    get: function() {
      return this.storage.mode || "sync";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CloudbaseCache2.prototype, "persistence", {
    get: function() {
      return this.persistenceTag;
    },
    enumerable: false,
    configurable: true
  });
  CloudbaseCache2.prototype.setStore = function(key, value, version2) {
    if (this.mode === "async") {
      (0, util_1$1.printWarn)(constants_1.ERRORS.INVALID_OPERATION, "current platform's storage is asynchronous, please use setStoreAsync insteed");
      return;
    }
    if (!this.storage) {
      return;
    }
    try {
      var val = {
        version: version2 || "localCachev1",
        content: value
      };
      this.storage.setItem(key, JSON.stringify(val));
    } catch (e2) {
      throw new Error(JSON.stringify({
        code: constants_1.ERRORS.OPERATION_FAIL,
        msg: "[".concat((0, constants_1.getSdkName)(), "][").concat(constants_1.ERRORS.OPERATION_FAIL, "]setStore failed"),
        info: e2
      }));
    }
    return;
  };
  CloudbaseCache2.prototype.setStoreAsync = function(key, value, version2) {
    return __awaiter$t(this, void 0, void 0, function() {
      var val;
      return __generator$t(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!this.storage) {
              return [2];
            }
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            val = {
              version: version2 || "localCachev1",
              content: value
            };
            return [4, this.storage.setItem(key, JSON.stringify(val))];
          case 2:
            _a2.sent();
            return [3, 4];
          case 3:
            _a2.sent();
            return [2];
          case 4:
            return [2];
        }
      });
    });
  };
  CloudbaseCache2.prototype.getStore = function(key, version2) {
    var _a2;
    if (this.mode === "async") {
      (0, util_1$1.printWarn)(constants_1.ERRORS.INVALID_OPERATION, "current platform's storage is asynchronous, please use getStoreAsync insteed");
      return;
    }
    try {
      if (typeof process !== "undefined" && ((_a2 = process.env) === null || _a2 === void 0 ? void 0 : _a2.tcb_token)) {
        return process.env.tcb_token;
      }
      if (!this.storage) {
        return "";
      }
    } catch (e2) {
      return "";
    }
    version2 = version2 || "localCachev1";
    var content = this.storage.getItem(key);
    if (!content) {
      return "";
    }
    if (content.indexOf(version2) >= 0) {
      var d2 = JSON.parse(content);
      return d2.content;
    }
    return "";
  };
  CloudbaseCache2.prototype.getStoreAsync = function(key, version2) {
    var _a2;
    return __awaiter$t(this, void 0, void 0, function() {
      var content, d2;
      return __generator$t(this, function(_b) {
        switch (_b.label) {
          case 0:
            try {
              if (typeof process !== "undefined" && ((_a2 = process.env) === null || _a2 === void 0 ? void 0 : _a2.tcb_token)) {
                return [2, process.env.tcb_token];
              }
              if (!this.storage) {
                return [2, ""];
              }
            } catch (e2) {
              return [2, ""];
            }
            version2 = version2 || "localCachev1";
            return [4, this.storage.getItem(key)];
          case 1:
            content = _b.sent();
            if (!content) {
              return [2, ""];
            }
            if (content.indexOf(version2) >= 0) {
              d2 = JSON.parse(content);
              return [2, d2.content];
            }
            return [2, ""];
        }
      });
    });
  };
  CloudbaseCache2.prototype.removeStore = function(key) {
    if (this.mode === "async") {
      (0, util_1$1.printWarn)(constants_1.ERRORS.INVALID_OPERATION, "current platform's storage is asynchronous, please use removeStoreAsync insteed");
      return;
    }
    this.storage.removeItem(key);
  };
  CloudbaseCache2.prototype.removeStoreAsync = function(key) {
    return __awaiter$t(this, void 0, void 0, function() {
      return __generator$t(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.storage.removeItem(key)];
          case 1:
            _a2.sent();
            return [2];
        }
      });
    });
  };
  return CloudbaseCache2;
}();
CloudbaseCache_1 = cache.CloudbaseCache = CloudbaseCache;
var adapters = {};
var web = {};
var __extends$8 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign$t = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$t = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$t.apply(this, arguments);
};
var __awaiter$s = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$s = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(web, "__esModule", { value: true });
web.WebRequest = web.genAdapter = void 0;
var adapter_interface_1 = require$$0;
var util_1 = util;
var common_1 = common;
var WebRequest = function(_super) {
  __extends$8(WebRequest2, _super);
  function WebRequest2(config) {
    var _this = _super.call(this) || this;
    var timeout = config.timeout, timeoutMsg = config.timeoutMsg, restrictedMethods = config.restrictedMethods;
    _this.timeout = timeout || 0;
    _this.timeoutMsg = timeoutMsg || "请求超时";
    _this.restrictedMethods = restrictedMethods || ["get", "post", "upload", "download"];
    return _this;
  }
  WebRequest2.prototype.get = function(options) {
    return this.request(__assign$t(__assign$t({}, options), { method: "get" }), this.restrictedMethods.includes("get"));
  };
  WebRequest2.prototype.post = function(options) {
    return this.request(__assign$t(__assign$t({}, options), { method: "post" }), this.restrictedMethods.includes("post"));
  };
  WebRequest2.prototype.put = function(options) {
    return this.request(__assign$t(__assign$t({}, options), { method: "put" }));
  };
  WebRequest2.prototype.upload = function(options) {
    var data = options.data, file = options.file, name2 = options.name, method = options.method, _a2 = options.headers, headers = _a2 === void 0 ? {} : _a2;
    var reqMethod = { post: "post", put: "put" }[method === null || method === void 0 ? void 0 : method.toLowerCase()] || "put";
    var formData = new FormData();
    if (reqMethod === "post") {
      Object.keys(data).forEach(function(key) {
        formData.append(key, data[key]);
      });
      formData.append("key", name2);
      formData.append("file", file);
      return this.request(__assign$t(__assign$t({}, options), { data: formData, method: reqMethod }), this.restrictedMethods.includes("upload"));
    }
    return this.request(__assign$t(__assign$t({}, options), { method: "put", headers, body: file }), this.restrictedMethods.includes("upload"));
  };
  WebRequest2.prototype.download = function(options) {
    return __awaiter$s(this, void 0, void 0, function() {
      var data, url, fileName, link;
      return __generator$s(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, this.get(__assign$t(__assign$t({}, options), { headers: {}, responseType: "blob" }))];
          case 1:
            data = _a2.sent().data;
            url = window.URL.createObjectURL(new Blob([data]));
            fileName = decodeURIComponent(new URL(options.url).pathname.split("/").pop() || "");
            link = document.createElement("a");
            link.href = url;
            link.setAttribute("download", fileName);
            link.style.display = "none";
            document.body.appendChild(link);
            link.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(link);
            return [3, 3];
          case 2:
            _a2.sent();
            return [3, 3];
          case 3:
            return [2, new Promise(function(resolve2) {
              resolve2({
                statusCode: 200,
                tempFilePath: options.url
              });
            })];
        }
      });
    });
  };
  WebRequest2.prototype.fetch = function(options) {
    var _a2;
    return __awaiter$s(this, void 0, void 0, function() {
      var abortController, url, _b, enableAbort, _c, stream, signal, timer, res;
      var _this = this;
      return __generator$s(this, function(_d) {
        switch (_d.label) {
          case 0:
            abortController = new AbortController();
            url = options.url, _b = options.enableAbort, enableAbort = _b === void 0 ? false : _b, _c = options.stream, stream = _c === void 0 ? false : _c, signal = options.signal;
            if (signal) {
              if (signal.aborted)
                abortController.abort();
              signal.addEventListener("abort", function() {
                return abortController.abort();
              });
            }
            timer = null;
            if (enableAbort && this.timeout) {
              timer = setTimeout(function() {
                console.warn(_this.timeoutMsg);
                abortController.abort(new Error(_this.timeoutMsg));
              }, this.timeout);
            }
            return [4, fetch(url, __assign$t(__assign$t({}, options), { signal: abortController.signal })).then(function(response) {
              return __awaiter$s(_this, void 0, void 0, function() {
                var _a3, _b2, _c2;
                return __generator$s(this, function(_d2) {
                  switch (_d2.label) {
                    case 0:
                      clearTimeout(timer);
                      if (!response.ok)
                        return [3, 1];
                      _a3 = response;
                      return [3, 3];
                    case 1:
                      _c2 = (_b2 = Promise).reject;
                      return [4, response.json()];
                    case 2:
                      _a3 = _c2.apply(_b2, [_d2.sent()]);
                      _d2.label = 3;
                    case 3:
                      return [2, _a3];
                  }
                });
              });
            }).catch(function(x2) {
              clearTimeout(timer);
              return Promise.reject(x2);
            })];
          case 1:
            res = _d.sent();
            return [2, {
              data: stream ? res.body : ((_a2 = res.headers.get("content-type")) === null || _a2 === void 0 ? void 0 : _a2.includes("application/json")) ? res.json() : res.text(),
              statusCode: res.status,
              header: res.headers
            }];
        }
      });
    });
  };
  WebRequest2.prototype.request = function(options, enableAbort) {
    var _this = this;
    if (enableAbort === void 0) {
      enableAbort = false;
    }
    var method = String(options.method).toLowerCase() || "get";
    return new Promise(function(resolve2) {
      var url = options.url, _a2 = options.headers, headers = _a2 === void 0 ? {} : _a2, data = options.data, responseType = options.responseType, withCredentials = options.withCredentials, body = options.body, onUploadProgress = options.onUploadProgress;
      var realUrl = (0, util_1.formatUrl)((0, common_1.getProtocol)(), url, method === "get" ? data : {});
      var ajax = new XMLHttpRequest();
      ajax.open(method, realUrl);
      responseType && (ajax.responseType = responseType);
      Object.keys(headers).forEach(function(key) {
        ajax.setRequestHeader(key, headers[key]);
      });
      var timer;
      if (onUploadProgress) {
        ajax.upload.addEventListener("progress", onUploadProgress);
      }
      ajax.onreadystatechange = function() {
        var result = {};
        if (ajax.readyState === 4) {
          var headers_1 = ajax.getAllResponseHeaders();
          var arr = headers_1.trim().split(/[\r\n]+/);
          var headerMap_1 = {};
          arr.forEach(function(line) {
            var parts = line.split(": ");
            var header = parts.shift().toLowerCase();
            var value = parts.join(": ");
            headerMap_1[header] = value;
          });
          result.header = headerMap_1;
          result.statusCode = ajax.status;
          try {
            result.data = responseType === "blob" ? ajax.response : JSON.parse(ajax.responseText);
          } catch (e2) {
            result.data = responseType === "blob" ? ajax.response : ajax.responseText;
          }
          clearTimeout(timer);
          resolve2(result);
        }
      };
      if (enableAbort && _this.timeout) {
        timer = setTimeout(function() {
          console.warn(_this.timeoutMsg);
          ajax.abort();
        }, _this.timeout);
      }
      var payload;
      if ((0, util_1.isFormData)(data)) {
        payload = data;
      } else if (headers["content-type"] === "application/x-www-form-urlencoded") {
        payload = (0, util_1.toQueryString)(data);
      } else if (body) {
        payload = body;
      } else {
        payload = data ? JSON.stringify(data) : void 0;
      }
      if (withCredentials) {
        ajax.withCredentials = true;
      }
      ajax.send(payload);
    });
  };
  return WebRequest2;
}(adapter_interface_1.AbstractSDKRequest);
web.WebRequest = WebRequest;
function genAdapter() {
  var adapter2 = {
    root: window,
    reqClass: WebRequest,
    wsClass: WebSocket,
    localStorage
  };
  return adapter2;
}
web.genAdapter = genAdapter;
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.useDefaultAdapter = exports2.useAdapters = exports2.RUNTIME = void 0;
  var Web = __importStar(web);
  var util_12 = util;
  var RUNTIME2;
  (function(RUNTIME3) {
    RUNTIME3["WEB"] = "web";
    RUNTIME3["WX_MP"] = "wx_mp";
  })(RUNTIME2 = exports2.RUNTIME || (exports2.RUNTIME = {}));
  function useAdapters2(adapters2) {
    var adapterList = (0, util_12.isArray)(adapters2) ? adapters2 : [adapters2];
    for (var _i = 0, adapterList_1 = adapterList; _i < adapterList_1.length; _i++) {
      var adapter2 = adapterList_1[_i];
      var isMatch2 = adapter2.isMatch, genAdapter2 = adapter2.genAdapter, runtime2 = adapter2.runtime;
      if (isMatch2()) {
        return {
          adapter: genAdapter2(),
          runtime: runtime2
        };
      }
    }
  }
  exports2.useAdapters = useAdapters2;
  function useDefaultAdapter2() {
    return {
      adapter: Web.genAdapter(),
      runtime: RUNTIME2.WEB
    };
  }
  exports2.useDefaultAdapter = useDefaultAdapter2;
})(adapters);
var __assign$s = function() {
  __assign$s = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$s.apply(this, arguments);
};
var __awaiter$r = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$r = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var OauthClientStorageBase = function() {
  function OauthClientStorageBase2(config) {
    this.localStorage = (config === null || config === void 0 ? void 0 : config.localStorage) || globalThis.localStorage;
  }
  OauthClientStorageBase2.prototype.getItem = function(key) {
    return __awaiter$r(this, void 0, void 0, function() {
      return __generator$r(this, function(_a2) {
        return [2, this.localStorage.getItem(key)];
      });
    });
  };
  OauthClientStorageBase2.prototype.removeItem = function(key) {
    return __awaiter$r(this, void 0, void 0, function() {
      return __generator$r(this, function(_a2) {
        this.localStorage.removeItem(key);
        return [2];
      });
    });
  };
  OauthClientStorageBase2.prototype.setItem = function(key, value) {
    return __awaiter$r(this, void 0, void 0, function() {
      return __generator$r(this, function(_a2) {
        this.localStorage.setItem(key, value);
        return [2];
      });
    });
  };
  OauthClientStorageBase2.prototype.getItemSync = function(key) {
    return this.localStorage.getItem(key);
  };
  OauthClientStorageBase2.prototype.setItemSync = function(key, value) {
    this.localStorage.setItem(key, value);
  };
  OauthClientStorageBase2.prototype.removeItemSync = function(key) {
    this.localStorage.removeItem(key);
  };
  return OauthClientStorageBase2;
}();
var URL_REG = /^[^:]+:\/\/[^/]+(\/[^?#]+)/;
function generateOauthClientRequest(reqClass) {
  return function(url, options) {
    var _a2;
    return __awaiter$r(this, void 0, void 0, function() {
      var requestId;
      return __generator$r(this, function(_b) {
        requestId = (_a2 = options === null || options === void 0 ? void 0 : options.headers) === null || _a2 === void 0 ? void 0 : _a2["x-request-id"];
        return [2, new Promise(function(resolve2, reject) {
          var copyOptions = Object.assign({}, options);
          if (copyOptions.body && typeof copyOptions.body !== "string") {
            copyOptions.body = JSON.stringify(copyOptions.body);
          }
          var task = wx$1.request({
            url,
            data: copyOptions.body,
            timeout: reqClass._timeout,
            method: copyOptions.method || "GET",
            header: copyOptions.headers,
            success: function(res) {
              var _a3, _b2;
              if (res.code || ((_a3 = res.data) === null || _a3 === void 0 ? void 0 : _a3.error_code)) {
                res = {
                  error: res.code || res.data.error,
                  error_description: res.data.error_description || res.message || res.code || res.data.error_code,
                  request_id: res.requestId,
                  error_code: (_b2 = res.data) === null || _b2 === void 0 ? void 0 : _b2.error_code
                };
              }
              if (!res.request_id) {
                res.request_id = res.request_id || requestId;
              }
              if (res.error) {
                res.error_uri = getUrlPath(url);
                reject(res);
              }
              resolve2(res.data || {});
            },
            fail: function(err) {
              reject({
                error: "unreachable",
                error_description: err.message
              });
            },
            complete: function(err) {
              if (!err || !err.errMsg) {
                return;
              }
              if (!reqClass._timeout || reqClass._restrictedMethods.indexOf("request") === -1) {
                return;
              }
              var errMsg = err.errMsg;
              if (errMsg === "request:fail timeout") {
                console.warn(reqClass._timeoutMsg);
                try {
                  task.abort();
                } catch (e2) {
                }
              }
            }
          });
        })];
      });
    });
  };
}
function getUrlPath(url) {
  return URL_REG.test(url) ? RegExp.$1 : url;
}
var useAuthAdapter = function(config) {
  if (!adapter.isMatch() || config.storage && config.baseRequest)
    return config;
  var authOptions = {};
  try {
    var _a2 = adapter.genAdapter(), localStorage_1 = _a2.localStorage, ReqClass = _a2.reqClass;
    if (localStorage_1) {
      authOptions.storage = new OauthClientStorageBase({ localStorage: localStorage_1 });
    }
    if (ReqClass) {
      var reqClass = new ReqClass({
        timeout: 1e4,
        restrictedMethods: ["get", "post", "upload", "download", "request"]
      });
      authOptions.request = generateOauthClientRequest(reqClass);
    }
    if (config.captchaOptions) {
      authOptions.baseRequest = authOptions.request;
      authOptions.request = void 0;
    }
    return __assign$s(__assign$s({}, config), authOptions);
  } catch (e2) {
    console.error("adapter generate fail:", e2);
  }
  return config;
};
var __assign$r = function() {
  __assign$r = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$r.apply(this, arguments);
};
var __decorate$3 = function(decorators2, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators2, target, key, desc);
  else
    for (var i = decorators2.length - 1; i >= 0; i--)
      if (d2 = decorators2[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata$3 = function(k2, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k2, v2);
};
var __awaiter$q = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$q = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var COMPONENT_NAME$7 = "auth";
var EVENTS = {
  LOGIN_STATE_CHANGED: "loginStateChanged"
};
var eventBus = new CloudbaseEventEmitter_1();
var User = function() {
  function User2(options) {
    var cache2 = options.cache, oauthInstance = options.oauthInstance;
    this.cache = cache2;
    this.oauthInstance = oauthInstance;
    this.setUserInfo();
  }
  User2.prototype.checkLocalInfo = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        this.uid = this.getLocalUserInfo("uid");
        this.gender = this.getLocalUserInfo("gender");
        this.picture = this.getLocalUserInfo("picture");
        this.email = this.getLocalUserInfo("email");
        this.emailVerified = this.getLocalUserInfo("email_verified");
        this.phoneNumber = this.getLocalUserInfo("phone_number");
        this.username = this.getLocalUserInfo("username");
        this.name = this.getLocalUserInfo("name");
        this.birthdate = this.getLocalUserInfo("birthdate");
        this.zoneinfo = this.getLocalUserInfo("zoneinfo");
        this.locale = this.getLocalUserInfo("locale");
        this.sub = this.getLocalUserInfo("sub");
        this.createdFrom = this.getLocalUserInfo("created_from");
        this.providers = this.getLocalUserInfo("providers");
        return [2];
      });
    });
  };
  User2.prototype.checkLocalInfoAsync = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      var _a2, _b, _c, _d;
      return __generator$q(this, function(_e2) {
        switch (_e2.label) {
          case 0:
            _a2 = this;
            return [4, this.getLocalUserInfoAsync("uid")];
          case 1:
            _a2.uid = _e2.sent();
            _b = this;
            return [4, this.getLocalUserInfoAsync("gender")];
          case 2:
            _b.gender = _e2.sent();
            this.picture = this.getLocalUserInfo("picture");
            _c = this;
            return [4, this.getLocalUserInfoAsync("email")];
          case 3:
            _c.email = _e2.sent();
            this.emailVerified = this.getLocalUserInfo("email_verified");
            this.phoneNumber = this.getLocalUserInfo("phone_number");
            _d = this;
            return [4, this.getLocalUserInfoAsync("username")];
          case 4:
            _d.username = _e2.sent();
            this.name = this.getLocalUserInfo("name");
            this.birthdate = this.getLocalUserInfo("birthdate");
            this.zoneinfo = this.getLocalUserInfo("zoneinfo");
            this.locale = this.getLocalUserInfo("locale");
            this.sub = this.getLocalUserInfo("sub");
            this.createdFrom = this.getLocalUserInfo("created_from");
            this.providers = this.getLocalUserInfo("providers");
            return [2];
        }
      });
    });
  };
  User2.prototype.update = function(userInfo) {
    return __awaiter$q(this, void 0, void 0, function() {
      var newUserInfo;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.setUserProfile(__assign$r({}, userInfo))];
          case 1:
            newUserInfo = _a2.sent();
            this.setLocalUserInfo(newUserInfo);
            return [2];
        }
      });
    });
  };
  User2.prototype.updateUserBasicInfo = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.updateUserBasicInfo(__assign$r({}, params))];
          case 1:
            _a2.sent();
            this.setLocalUserInfo({ username: params.username });
            return [2];
        }
      });
    });
  };
  User2.prototype.updatePassword = function(newPassword, oldPassword) {
    return this.oauthInstance.authApi.updatePasswordByOld({
      old_password: oldPassword,
      new_password: newPassword
    });
  };
  User2.prototype.updateUsername = function(username) {
    if (typeof username !== "string") {
      throwError_1(constants.ERRORS.INVALID_PARAMS, "username must be a string");
    }
    return this.update({
      username
    });
  };
  User2.prototype.refresh = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      var newUserInfo;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.getUserInfo(params)];
          case 1:
            newUserInfo = _a2.sent();
            this.setLocalUserInfo(newUserInfo);
            return [2, newUserInfo];
        }
      });
    });
  };
  User2.prototype.getLocalUserInfo = function(key) {
    var userInfoKey = this.cache.keys.userInfoKey;
    var userInfo = this.cache.getStore(userInfoKey);
    return userInfo[key];
  };
  User2.prototype.getLocalUserInfoAsync = function(key) {
    return __awaiter$q(this, void 0, void 0, function() {
      var userInfoKey, userInfo;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            userInfoKey = this.cache.keys.userInfoKey;
            return [4, this.cache.getStoreAsync(userInfoKey)];
          case 1:
            userInfo = _a2.sent();
            return [2, userInfo[key]];
        }
      });
    });
  };
  User2.prototype.setUserInfo = function() {
    var _this = this;
    var userInfoKey = this.cache.keys.userInfoKey;
    var userInfo = this.cache.getStore(userInfoKey);
    [
      "uid",
      "email",
      "name",
      "gender",
      "picture",
      "email_verified",
      "phone_number",
      "birthdate",
      "zoneinfo",
      "locale",
      "sub",
      "created_from",
      "providers",
      "username"
    ].forEach(function(infoKey) {
      _this[infoKey] = userInfo[infoKey];
    });
  };
  User2.prototype.setLocalUserInfo = function(userInfo) {
    var userInfoKey = this.cache.keys.userInfoKey;
    this.cache.setStore(userInfoKey, userInfo);
    this.setUserInfo();
  };
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "更新用户信息失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 User.update() 的语法或参数是否正确",
        "  2 - 用户信息中是否包含非法值",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], User2.prototype, "update", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "更新密码失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 User.updatePassword() 的语法或参数是否正确",
        "  3 - 新密码中是否包含非法字符",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [String, String]),
    __metadata$3("design:returntype", void 0)
  ], User2.prototype, "updatePassword", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "更新用户名失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 User.updateUsername() 的语法或参数是否正确",
        "  2 - 当前环境是否开通了用户名密码登录",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [String]),
    __metadata$3("design:returntype", void 0)
  ], User2.prototype, "updateUsername", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "刷新本地用户信息失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 User.refresh() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], User2.prototype, "refresh", null);
  return User2;
}();
var LoginState = function() {
  function LoginState2(options) {
    var envId = options.envId, cache2 = options.cache, oauthInstance = options.oauthInstance;
    if (!envId) {
      throwError_1(constants.ERRORS.INVALID_PARAMS, "envId is not defined");
    }
    this.cache = cache2;
    this.oauthInstance = oauthInstance;
    this.user = new User({
      cache: this.cache,
      oauthInstance
    });
  }
  LoginState2.prototype.checkLocalState = function() {
    var _a2;
    this.oauthLoginState = (_a2 = this.oauthInstance) === null || _a2 === void 0 ? void 0 : _a2.authApi.hasLoginStateSync();
    this.user.checkLocalInfo();
  };
  LoginState2.prototype.checkLocalStateAsync = function() {
    var _a2;
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_b) {
        switch (_b.label) {
          case 0:
            return [4, (_a2 = this.oauthInstance) === null || _a2 === void 0 ? void 0 : _a2.authApi.getLoginState()];
          case 1:
            _b.sent();
            return [4, this.user.checkLocalInfoAsync()];
          case 2:
            _b.sent();
            return [2];
        }
      });
    });
  };
  return LoginState2;
}();
var Auth2 = function() {
  function Auth3(config) {
    this.config = config;
    this.cache = config.cache;
    this.oauthInstance = config.oauthInstance;
  }
  Auth3.prototype.bindPhoneNumber = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.editContact(params)];
      });
    });
  };
  Auth3.prototype.unbindProvider = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.unbindProvider(params)];
      });
    });
  };
  Auth3.prototype.bindEmail = function(params) {
    return this.oauthInstance.authApi.editContact(params);
  };
  Auth3.prototype.verify = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.verify(params)];
      });
    });
  };
  Auth3.prototype.getVerification = function(params, options) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.getVerification(params, options)];
      });
    });
  };
  Object.defineProperty(Auth3.prototype, "currentUser", {
    get: function() {
      if (this.cache.mode === "async") {
        printWarn_1(constants.ERRORS.INVALID_OPERATION, "current platform's storage is asynchronous, please use getCurrentUser insteed");
        return;
      }
      var loginState = this.hasLoginState();
      if (loginState) {
        return loginState.user || null;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Auth3.prototype.getCurrentUser = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      var loginState;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getLoginState()];
          case 1:
            loginState = _a2.sent();
            if (!loginState)
              return [3, 3];
            return [4, loginState.user.checkLocalInfoAsync()];
          case 2:
            _a2.sent();
            return [2, loginState.user || null];
          case 3:
            return [2, null];
        }
      });
    });
  };
  Auth3.prototype.signInAnonymously = function(data) {
    if (data === void 0) {
      data = {};
    }
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.signInAnonymously(data)];
          case 1:
            _a2.sent();
            return [2, this.createLoginState()];
        }
      });
    });
  };
  Auth3.prototype.signInAnonymouslyInWx = function(_a2) {
    var _b = _a2 === void 0 ? {} : _a2, useWxCloud = _b.useWxCloud;
    return __awaiter$q(this, void 0, void 0, function() {
      var wxInfo, mainFunc;
      var _this = this;
      return __generator$q(this, function(_c) {
        switch (_c.label) {
          case 0:
            if (!adapter.isMatch()) {
              throw Error("wx api undefined");
            }
            wxInfo = wx$1.getAccountInfoSync().miniProgram;
            mainFunc = function(code2) {
              return __awaiter$q(_this, void 0, void 0, function() {
                var result, credentials, error_1;
                return __generator$q(this, function(_a3) {
                  switch (_a3.label) {
                    case 0:
                      result = void 0;
                      credentials = void 0;
                      _a3.label = 1;
                    case 1:
                      _a3.trys.push([1, 4, , 5]);
                      return [4, this.oauthInstance.authApi.grantProviderToken({
                        provider_id: wxInfo === null || wxInfo === void 0 ? void 0 : wxInfo.appId,
                        provider_code: code2,
                        provider_params: {
                          provider_code_type: "open_id",
                          appid: wxInfo === null || wxInfo === void 0 ? void 0 : wxInfo.appId
                        }
                      }, useWxCloud)];
                    case 2:
                      result = _a3.sent();
                      if ((result === null || result === void 0 ? void 0 : result.error_code) || !result.provider_token) {
                        throw result;
                      }
                      return [4, this.oauthInstance.authApi.signInAnonymously({ provider_token: result.provider_token }, useWxCloud)];
                    case 3:
                      credentials = _a3.sent();
                      if (credentials === null || credentials === void 0 ? void 0 : credentials.error_code) {
                        throw credentials;
                      }
                      return [3, 5];
                    case 4:
                      error_1 = _a3.sent();
                      throw error_1;
                    case 5:
                      return [2];
                  }
                });
              });
            };
            return [4, new Promise(function(resolve2, reject) {
              wx$1.login({
                success: function(res) {
                  return __awaiter$q(_this, void 0, void 0, function() {
                    var error_2;
                    return __generator$q(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          _a3.trys.push([0, 2, , 3]);
                          return [4, mainFunc(res.code)];
                        case 1:
                          _a3.sent();
                          resolve2(true);
                          return [3, 3];
                        case 2:
                          error_2 = _a3.sent();
                          reject(error_2);
                          return [3, 3];
                        case 3:
                          return [2];
                      }
                    });
                  });
                },
                fail: function(res) {
                  var error = new Error(res === null || res === void 0 ? void 0 : res.errMsg);
                  error.code = res === null || res === void 0 ? void 0 : res.errno;
                  reject(error);
                }
              });
            })];
          case 1:
            _c.sent();
            return [2, this.createLoginState(void 0, { asyncRefreshUser: true })];
        }
      });
    });
  };
  Auth3.prototype.bindOpenId = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      var wxInfo, mainFunc;
      var _this = this;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!adapter.isMatch()) {
              throw Error("wx api undefined");
            }
            wxInfo = wx$1.getAccountInfoSync().miniProgram;
            mainFunc = function(code2) {
              return __awaiter$q(_this, void 0, void 0, function() {
                var result, error_3;
                return __generator$q(this, function(_a3) {
                  switch (_a3.label) {
                    case 0:
                      result = void 0;
                      _a3.label = 1;
                    case 1:
                      _a3.trys.push([1, 4, , 5]);
                      return [4, this.oauthInstance.authApi.grantProviderToken({
                        provider_id: wxInfo === null || wxInfo === void 0 ? void 0 : wxInfo.appId,
                        provider_code: code2,
                        provider_params: {
                          provider_code_type: "open_id",
                          appid: wxInfo === null || wxInfo === void 0 ? void 0 : wxInfo.appId
                        }
                      })];
                    case 2:
                      result = _a3.sent();
                      if ((result === null || result === void 0 ? void 0 : result.error_code) || !result.provider_token) {
                        throw result;
                      }
                      return [4, this.oauthInstance.authApi.bindWithProvider({ provider_token: result.provider_token })];
                    case 3:
                      _a3.sent();
                      return [3, 5];
                    case 4:
                      error_3 = _a3.sent();
                      throw error_3;
                    case 5:
                      return [2];
                  }
                });
              });
            };
            return [4, new Promise(function(resolve2, reject) {
              wx$1.login({
                success: function(res) {
                  return __awaiter$q(_this, void 0, void 0, function() {
                    var error_4;
                    return __generator$q(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          _a3.trys.push([0, 2, , 3]);
                          return [4, mainFunc(res.code)];
                        case 1:
                          _a3.sent();
                          resolve2(true);
                          return [3, 3];
                        case 2:
                          error_4 = _a3.sent();
                          reject(error_4);
                          return [3, 3];
                        case 3:
                          return [2];
                      }
                    });
                  });
                },
                fail: function(res) {
                  var error = new Error(res === null || res === void 0 ? void 0 : res.errMsg);
                  error.code = res === null || res === void 0 ? void 0 : res.errno;
                  reject(error);
                }
              });
            })];
          case 1:
            _a2.sent();
            return [2];
        }
      });
    });
  };
  Auth3.prototype.signInWithOpenId = function(_a2) {
    var _b = _a2 === void 0 ? {} : _a2, _c = _b.useWxCloud, useWxCloud = _c === void 0 ? true : _c;
    return __awaiter$q(this, void 0, void 0, function() {
      var wxInfo, mainFunc;
      var _this = this;
      return __generator$q(this, function(_d) {
        switch (_d.label) {
          case 0:
            if (!adapter.isMatch()) {
              throw Error("wx api undefined");
            }
            wxInfo = wx$1.getAccountInfoSync().miniProgram;
            mainFunc = function(code2) {
              return __awaiter$q(_this, void 0, void 0, function() {
                var result, credentials, error_5;
                return __generator$q(this, function(_a3) {
                  switch (_a3.label) {
                    case 0:
                      result = void 0;
                      credentials = void 0;
                      _a3.label = 1;
                    case 1:
                      _a3.trys.push([1, 4, , 5]);
                      return [4, this.oauthInstance.authApi.grantProviderToken({
                        provider_id: wxInfo === null || wxInfo === void 0 ? void 0 : wxInfo.appId,
                        provider_code: code2,
                        provider_params: {
                          provider_code_type: "open_id",
                          appid: wxInfo === null || wxInfo === void 0 ? void 0 : wxInfo.appId
                        }
                      }, useWxCloud)];
                    case 2:
                      result = _a3.sent();
                      if ((result === null || result === void 0 ? void 0 : result.error_code) || !result.provider_token) {
                        throw result;
                      }
                      return [4, this.oauthInstance.authApi.signInWithProvider({ provider_token: result.provider_token }, useWxCloud)];
                    case 3:
                      credentials = _a3.sent();
                      if (credentials === null || credentials === void 0 ? void 0 : credentials.error_code) {
                        throw credentials;
                      }
                      return [3, 5];
                    case 4:
                      error_5 = _a3.sent();
                      throw error_5;
                    case 5:
                      return [4, this.oauthInstance.oauth2client.setCredentials(credentials)];
                    case 6:
                      _a3.sent();
                      return [2];
                  }
                });
              });
            };
            return [4, new Promise(function(resolve2, reject) {
              wx$1.login({
                success: function(res) {
                  return __awaiter$q(_this, void 0, void 0, function() {
                    var error_6;
                    return __generator$q(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          _a3.trys.push([0, 2, , 3]);
                          return [4, mainFunc(res.code)];
                        case 1:
                          _a3.sent();
                          resolve2(true);
                          return [3, 3];
                        case 2:
                          error_6 = _a3.sent();
                          reject(error_6);
                          return [3, 3];
                        case 3:
                          return [2];
                      }
                    });
                  });
                },
                fail: function(res) {
                  var error = new Error(res === null || res === void 0 ? void 0 : res.errMsg);
                  error.code = res === null || res === void 0 ? void 0 : res.errno;
                  reject(error);
                }
              });
            })];
          case 1:
            _d.sent();
            return [2, this.createLoginState()];
        }
      });
    });
  };
  Auth3.prototype.signInWithUnionId = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      var error_7;
      var _this = this;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!adapter.isMatch()) {
              throw Error("wx api undefined");
            }
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, new Promise(function(resolve2, reject) {
              var wxInfo = wx$1.getAccountInfoSync().miniProgram;
              wx$1.login({
                success: function(res) {
                  return __awaiter$q(_this, void 0, void 0, function() {
                    var providerId, result, providerToken, signInRes, error_8;
                    return __generator$q(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          providerId = wxInfo === null || wxInfo === void 0 ? void 0 : wxInfo.appId;
                          _a3.label = 1;
                        case 1:
                          _a3.trys.push([1, 4, , 5]);
                          return [4, this.oauthInstance.authApi.grantProviderToken({
                            provider_code: res.code,
                            provider_id: providerId,
                            provider_params: {
                              provider_code_type: "union_id",
                              appid: wxInfo === null || wxInfo === void 0 ? void 0 : wxInfo.appId
                            }
                          })];
                        case 2:
                          result = _a3.sent();
                          providerToken = result.provider_token;
                          if (!providerToken) {
                            reject(result);
                            return [2];
                          }
                          return [4, this.oauthInstance.authApi.signInWithProvider({
                            provider_id: providerId,
                            provider_token: providerToken
                          })];
                        case 3:
                          signInRes = _a3.sent();
                          if (signInRes === null || signInRes === void 0 ? void 0 : signInRes.error_code) {
                            reject(signInRes);
                            return [2];
                          }
                          resolve2(true);
                          return [3, 5];
                        case 4:
                          error_8 = _a3.sent();
                          reject(error_8);
                          return [3, 5];
                        case 5:
                          return [2];
                      }
                    });
                  });
                },
                fail: function(res) {
                  var error = new Error(res === null || res === void 0 ? void 0 : res.errMsg);
                  error.code = res === null || res === void 0 ? void 0 : res.errno;
                  reject(error);
                }
              });
            })];
          case 2:
            _a2.sent();
            return [3, 4];
          case 3:
            error_7 = _a2.sent();
            throw error_7;
          case 4:
            return [2, this.createLoginState()];
        }
      });
    });
  };
  Auth3.prototype.signInWithPhoneAuth = function(_a2) {
    var _b = _a2.phoneCode, phoneCode = _b === void 0 ? "" : _b;
    return __awaiter$q(this, void 0, void 0, function() {
      var wxInfo, providerInfo, code2, providerToken, signInRes, error_9;
      return __generator$q(this, function(_c) {
        switch (_c.label) {
          case 0:
            if (!adapter.isMatch()) {
              throw Error("wx api undefined");
            }
            wxInfo = wx$1.getAccountInfoSync().miniProgram;
            providerInfo = {
              provider_params: { provider_code_type: "phone" },
              provider_id: wxInfo.appId
            };
            return [4, wx$1.login()];
          case 1:
            code2 = _c.sent().code;
            providerInfo.provider_code = code2;
            _c.label = 2;
          case 2:
            _c.trys.push([2, 6, , 7]);
            return [4, this.oauthInstance.authApi.grantProviderToken(providerInfo)];
          case 3:
            providerToken = _c.sent();
            if (providerToken.error_code) {
              throw providerToken;
            }
            return [4, this.oauthInstance.authApi.patchProviderToken({
              provider_token: providerToken.provider_token,
              provider_id: wxInfo.appId,
              provider_params: {
                code: phoneCode,
                provider_code_type: "phone"
              }
            })];
          case 4:
            providerToken = _c.sent();
            if (providerToken.error_code) {
              throw providerToken;
            }
            return [4, this.oauthInstance.authApi.signInWithProvider({
              provider_token: providerToken.provider_token
            })];
          case 5:
            signInRes = _c.sent();
            if (signInRes === null || signInRes === void 0 ? void 0 : signInRes.error_code) {
              throw signInRes;
            }
            return [3, 7];
          case 6:
            error_9 = _c.sent();
            throw error_9;
          case 7:
            return [2, this.createLoginState()];
        }
      });
    });
  };
  Auth3.prototype.signInWithSms = function(_a2) {
    var _b = _a2.verificationInfo, verificationInfo = _b === void 0 ? { verification_id: "", is_user: false } : _b, _c = _a2.verificationCode, verificationCode = _c === void 0 ? "" : _c, _d = _a2.phoneNum, phoneNum = _d === void 0 ? "" : _d, _e2 = _a2.bindInfo, bindInfo = _e2 === void 0 ? void 0 : _e2;
    return __awaiter$q(this, void 0, void 0, function() {
      var verifyRes, verification_token, signInRes, bindRes, signUpRes, error_10;
      return __generator$q(this, function(_f) {
        switch (_f.label) {
          case 0:
            _f.trys.push([0, 8, , 9]);
            return [4, this.oauthInstance.authApi.verify({
              verification_id: verificationInfo.verification_id,
              verification_code: verificationCode
            })];
          case 1:
            verifyRes = _f.sent();
            if (verifyRes === null || verifyRes === void 0 ? void 0 : verifyRes.error_code) {
              throw verifyRes;
            }
            verification_token = verifyRes.verification_token;
            if (!verificationInfo.is_user)
              return [3, 5];
            return [4, this.oauthInstance.authApi.signIn({
              username: "+86 ".concat(phoneNum),
              verification_token
            })];
          case 2:
            signInRes = _f.sent();
            if (signInRes === null || signInRes === void 0 ? void 0 : signInRes.error_code) {
              throw signInRes;
            }
            if (!bindInfo)
              return [3, 4];
            return [4, this.oauthInstance.authApi.bindWithProvider({
              provider_token: bindInfo === null || bindInfo === void 0 ? void 0 : bindInfo.providerToken
            })];
          case 3:
            bindRes = _f.sent();
            if (bindRes === null || bindRes === void 0 ? void 0 : bindRes.error_code) {
              throw bindRes;
            }
            _f.label = 4;
          case 4:
            return [3, 7];
          case 5:
            return [4, this.oauthInstance.authApi.signUp({
              phone_number: "+86 ".concat(phoneNum),
              verification_token,
              provider_token: bindInfo === null || bindInfo === void 0 ? void 0 : bindInfo.providerId
            })];
          case 6:
            signUpRes = _f.sent();
            if (signUpRes === null || signUpRes === void 0 ? void 0 : signUpRes.error_code) {
              throw signUpRes;
            }
            _f.label = 7;
          case 7:
            return [2, this.createLoginState()];
          case 8:
            error_10 = _f.sent();
            throw error_10;
          case 9:
            return [2];
        }
      });
    });
  };
  Auth3.prototype.setCustomSignFunc = function(getTickFn) {
    this.oauthInstance.authApi.setCustomSignFunc(getTickFn);
  };
  Auth3.prototype.signInWithCustomTicket = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.signInWithCustomTicket()];
          case 1:
            _a2.sent();
            return [2, this.createLoginState()];
        }
      });
    });
  };
  Auth3.prototype.signIn = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.signIn(params)];
          case 1:
            _a2.sent();
            return [2, this.createLoginState(params)];
        }
      });
    });
  };
  Auth3.prototype.signUp = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.signUp(params)];
          case 1:
            _a2.sent();
            return [2, this.createLoginState()];
        }
      });
    });
  };
  Auth3.prototype.setPassword = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.setPassword(params)];
      });
    });
  };
  Auth3.prototype.isUsernameRegistered = function(username) {
    return __awaiter$q(this, void 0, void 0, function() {
      var exist;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (typeof username !== "string") {
              throwError_1(constants.ERRORS.INVALID_PARAMS, "username must be a string");
            }
            return [4, this.oauthInstance.authApi.checkIfUserExist({ username })];
          case 1:
            exist = _a2.sent().exist;
            return [2, exist];
        }
      });
    });
  };
  Auth3.prototype.signOut = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      var userInfoKey, res;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            userInfoKey = this.cache.keys.userInfoKey;
            return [4, this.oauthInstance.authApi.signOut(params)];
          case 1:
            res = _a2.sent();
            return [4, this.cache.removeStoreAsync(userInfoKey)];
          case 2:
            _a2.sent();
            eventBus.fire(EVENTS.LOGIN_STATE_CHANGED);
            return [2, res];
        }
      });
    });
  };
  Auth3.prototype.hasLoginState = function() {
    var _a2;
    if (this.cache.mode === "async") {
      printWarn_1(constants.ERRORS.INVALID_OPERATION, "current platform's storage is asynchronous, please use getLoginState insteed");
      return;
    }
    var oauthLoginState = (_a2 = this.oauthInstance) === null || _a2 === void 0 ? void 0 : _a2.authApi.hasLoginStateSync();
    if (oauthLoginState) {
      var loginState = new LoginState({
        envId: this.config.env,
        cache: this.cache,
        oauthInstance: this.oauthInstance
      });
      return loginState;
    }
    return null;
  };
  Auth3.prototype.getLoginState = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      var oauthLoginState, loginState;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.getLoginState()];
          case 1:
            oauthLoginState = _a2.sent();
            if (oauthLoginState) {
              loginState = new LoginState({
                envId: this.config.env,
                cache: this.cache,
                oauthInstance: this.oauthInstance
              });
              return [2, loginState];
            }
            return [2, null];
        }
      });
    });
  };
  Auth3.prototype.getUserInfo = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.getUserInfo(params)];
      });
    });
  };
  Auth3.prototype.getWedaUserInfo = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.getWedaUserInfo()];
      });
    });
  };
  Auth3.prototype.updateUserBasicInfo = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      var loginState;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getLoginState()];
          case 1:
            loginState = _a2.sent();
            if (!loginState)
              return [3, 3];
            return [4, loginState.user.updateUserBasicInfo(params)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  };
  Auth3.prototype.getAuthHeader = function() {
    console.error("Auth.getAuthHeader API 已废弃");
    return {};
  };
  Auth3.prototype.bindWithProvider = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.bindWithProvider(params)];
      });
    });
  };
  Auth3.prototype.queryUser = function(queryObj) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.queryUserProfile(queryObj)];
      });
    });
  };
  Auth3.prototype.getAccessToken = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      var oauthAccessTokenRes;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.oauth2client.getAccessToken()];
          case 1:
            oauthAccessTokenRes = _a2.sent();
            return [2, {
              accessToken: oauthAccessTokenRes,
              env: this.config.env
            }];
        }
      });
    });
  };
  Auth3.prototype.grantProviderToken = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.grantProviderToken(params)];
      });
    });
  };
  Auth3.prototype.patchProviderToken = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.patchProviderToken(params)];
      });
    });
  };
  Auth3.prototype.signInWithProvider = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.signInWithProvider(params)];
          case 1:
            _a2.sent();
            return [2, this.createLoginState(params)];
        }
      });
    });
  };
  Auth3.prototype.signInWithWechat = function(params) {
    if (params === void 0) {
      params = {};
    }
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.signInWithWechat(params)];
          case 1:
            _a2.sent();
            return [2, this.createLoginState(params)];
        }
      });
    });
  };
  Auth3.prototype.grantToken = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.authApi.grantToken(params)];
          case 1:
            _a2.sent();
            return [2, this.createLoginState()];
        }
      });
    });
  };
  Auth3.prototype.genProviderRedirectUri = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.genProviderRedirectUri(params)];
      });
    });
  };
  Auth3.prototype.resetPassword = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.resetPassword(params)];
      });
    });
  };
  Auth3.prototype.deviceAuthorize = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.deviceAuthorize(params)];
      });
    });
  };
  Auth3.prototype.sudo = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.sudo(params)];
      });
    });
  };
  Auth3.prototype.deleteMe = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.deleteMe(params)];
      });
    });
  };
  Auth3.prototype.getProviders = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.getProviders()];
      });
    });
  };
  Auth3.prototype.loginScope = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.loginScope()];
      });
    });
  };
  Auth3.prototype.loginGroups = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.loginGroups()];
      });
    });
  };
  Auth3.prototype.onLoginStateChanged = function(callback) {
    return __awaiter$q(this, void 0, void 0, function() {
      var loginState;
      var _this = this;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            eventBus.on(EVENTS.LOGIN_STATE_CHANGED, function() {
              return __awaiter$q(_this, void 0, void 0, function() {
                var loginState2;
                return __generator$q(this, function(_a3) {
                  switch (_a3.label) {
                    case 0:
                      return [4, this.getLoginState()];
                    case 1:
                      loginState2 = _a3.sent();
                      callback.call(this, loginState2);
                      return [2];
                  }
                });
              });
            });
            return [4, this.getLoginState()];
          case 1:
            loginState = _a2.sent();
            callback.call(this, loginState);
            return [2];
        }
      });
    });
  };
  Auth3.prototype.refreshTokenForce = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.refreshTokenForce(params)];
      });
    });
  };
  Auth3.prototype.getCredentials = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.getCredentials()];
      });
    });
  };
  Auth3.prototype.setCredentials = function(credentials) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.oauthInstance.oauth2client.setCredentials(credentials)];
          case 1:
            _a2.sent();
            return [2];
        }
      });
    });
  };
  Auth3.prototype.getProviderSubType = function() {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.getProviderSubType()];
      });
    });
  };
  Auth3.prototype.createCaptchaData = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.createCaptchaData(params)];
      });
    });
  };
  Auth3.prototype.verifyCaptchaData = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.verifyCaptchaData(params)];
      });
    });
  };
  Auth3.prototype.getMiniProgramQrCode = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.getMiniProgramCode(params)];
      });
    });
  };
  Auth3.prototype.getMiniProgramQrCodeStatus = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.getMiniProgramQrCodeStatus(params)];
      });
    });
  };
  Auth3.prototype.modifyPassword = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.modifyPassword(params)];
      });
    });
  };
  Auth3.prototype.modifyPasswordWithoutLogin = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.modifyPasswordWithoutLogin(params)];
      });
    });
  };
  Auth3.prototype.getUserBehaviorLog = function(params) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator$q(this, function(_a2) {
        return [2, this.oauthInstance.authApi.getUserBehaviorLog(params)];
      });
    });
  };
  Auth3.prototype.createLoginState = function(params, options) {
    return __awaiter$q(this, void 0, void 0, function() {
      var loginState;
      return __generator$q(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            loginState = new LoginState({
              envId: this.config.env,
              cache: this.cache,
              oauthInstance: this.oauthInstance
            });
            return [4, loginState.checkLocalStateAsync()];
          case 1:
            _a2.sent();
            if (!(options === null || options === void 0 ? void 0 : options.asyncRefreshUser))
              return [3, 2];
            loginState.user.refresh(params);
            return [3, 4];
          case 2:
            return [4, loginState.user.refresh(params)];
          case 3:
            _a2.sent();
            _a2.label = 4;
          case 4:
            eventBus.fire(EVENTS.LOGIN_STATE_CHANGED);
            return [2, loginState];
        }
      });
    });
  };
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "绑定手机号失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().bindPhoneNumber() 的语法或参数是否正确",
        "  2 - 当前环境是否开通了短信验证码登录",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "bindPhoneNumber", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "解除三方绑定失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().unbindProvider() 的语法或参数是否正确",
        "  2 - 当前账户是否已经与此登录方式解绑",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "unbindProvider", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "绑定邮箱地址失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().bindEmail() 的语法或参数是否正确",
        "  2 - 当前环境是否开通了邮箱密码登录",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", void 0)
  ], Auth3.prototype, "bindEmail", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "验证码验证失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().verify() 的语法或参数是否正确",
        "  2 - 当前环境是否开通了手机验证码/邮箱登录",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "verify", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "获取验证码失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().getVerification() 的语法或参数是否正确",
        "  2 - 当前环境是否开通了手机验证码/邮箱登录",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object, Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "getVerification", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "获取用户信息失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().getCurrentUser() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", []),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "getCurrentUser", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "匿名登录失败",
      messages: [
        "请确认以下各项：",
        "  1 - 当前环境是否开启了匿名登录",
        "  2 - 调用 auth().signInAnonymously() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "signInAnonymously", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "小程序匿名登录失败",
      messages: [
        "请确认以下各项：",
        "  1 - 当前环境是否开启了匿名登录",
        "  2 - 调用 auth().signInAnonymouslyInWx() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "signInAnonymouslyInWx", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "小程序绑定OpenID失败",
      messages: [
        "请确认以下各项：",
        "  1 - 当前环境是否开启了小程序openId静默登录",
        "  2 - 调用 auth().bindOpenId() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", []),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "bindOpenId", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "小程序openId静默登录失败",
      messages: [
        "请确认以下各项：",
        "  1 - 当前环境是否开启了小程序openId静默登录",
        "  2 - 调用 auth().signInWithOpenId() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "signInWithOpenId", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "小程序unionId静默登录失败",
      messages: [
        "请确认以下各项：",
        "  1 - 当前环境是否开启了小程序unionId静默登录",
        "  2 - 调用 auth().signInWithUnionId() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", []),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "signInWithUnionId", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "小程序手机号授权登录失败",
      messages: [
        "请确认以下各项：",
        "  1 - 当前环境是否开启了小程序手机号授权登录",
        "  2 - 调用 auth().signInWithPhoneAuth() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "signInWithPhoneAuth", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "短信验证码登陆",
      messages: [
        "请确认以下各项：",
        "  1 - 当前环境是否开启了小程序短信验证码登陆",
        "  2 - 调用 auth().signInWithSms() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "signInWithSms", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "自定义登录失败",
      messages: [
        "请确认以下各项：",
        "  1 - 当前环境是否开启了自定义登录",
        "  2 - 调用 auth().signInWithCustomTicket() 的语法或参数是否正确",
        "  3 - ticket 是否归属于当前环境",
        "  4 - 创建 ticket 的自定义登录私钥是否过期",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", []),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "signInWithCustomTicket", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "注册失败",
      messages: [
        "请确认以下各项：",
        "  1 - 当前环境是否开启了指定登录方式",
        "  2 - 调用 auth().signUp() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "signUp", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "获取用户是否被占用失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().isUsernameRegistered() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [String]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "isUsernameRegistered", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "用户登出失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().signOut() 的语法或参数是否正确",
        "  2 - 当前用户是否为匿名登录（匿名登录不支持signOut）",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "signOut", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "获取本地登录态失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().getLoginState() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", []),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "getLoginState", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "获取用户信息失败",
      messages: [
        "请确认以下各项：",
        "  1 - 是否已登录",
        "  2 - 调用 auth().getUserInfo() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "getUserInfo", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "获取微搭插件用户信息失败",
      messages: [
        "请确认以下各项：",
        "  1 - 是否已登录",
        "  2 - 调用 auth().getWedaUserInfo() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", []),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "getWedaUserInfo", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "绑定第三方登录方式失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().bindWithProvider() 的语法或参数是否正确",
        "  2 - 此账户是否已经绑定此第三方",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "bindWithProvider", null);
  __decorate$3([
    helpers.catchErrorsDecorator({
      title: "获取身份源类型",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 auth().getProviderSubType() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(constants.COMMUNITY_SITE_URL)
      ]
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", []),
    __metadata$3("design:returntype", Promise)
  ], Auth3.prototype, "getProviderSubType", null);
  return Auth3;
}();
function generateAuthInstance(config, options) {
  var _a2 = config.region, region = _a2 === void 0 ? "ap-shanghai" : _a2;
  var platform2 = (options === null || options === void 0 ? void 0 : options.platform) || adapters.useDefaultAdapter();
  var runtime2 = platform2.runtime;
  var _b = options || {}, env = _b.env, clientId = _b.clientId, debug = _b.debug, cache2 = _b.cache, cloudbase2 = _b.app;
  var apiOrigin = (options || {}).apiOrigin;
  if (!apiOrigin) {
    apiOrigin = "https://".concat(env, ".").concat(region, ".tcb-api.tencentcloudapi.com");
  }
  var oauthInstance = new CloudbaseOAuth(useAuthAdapter({
    env,
    clientId,
    apiOrigin,
    storage: config === null || config === void 0 ? void 0 : config.storage,
    baseRequest: config === null || config === void 0 ? void 0 : config.baseRequest,
    request: config === null || config === void 0 ? void 0 : config.request,
    anonymousSignInFunc: config === null || config === void 0 ? void 0 : config.anonymousSignInFunc,
    captchaOptions: config === null || config === void 0 ? void 0 : config.captchaOptions,
    wxCloud: config === null || config === void 0 ? void 0 : config.wxCloud
  }));
  var authInstance = new Auth2({
    env,
    region,
    persistence: config.persistence,
    debug,
    cache: cache2 || new CloudbaseCache_1({
      persistence: config.persistence,
      keys: { userInfoKey: "user_info_".concat(env) },
      platformInfo: platform2
    }),
    runtime: runtime2 || "web",
    _fromApp: cloudbase2,
    oauthInstance
  });
  return { authInstance, oauthInstance };
}
var component$8 = {
  name: COMPONENT_NAME$7,
  namespace: "auth",
  entity: function(config) {
    if (config === void 0) {
      config = {
        region: "",
        persistence: "local"
      };
    }
    if (this.authInstance) {
      printWarn_1(constants.ERRORS.INVALID_OPERATION, "every cloudbase instance should has only one auth object");
      return this.authInstance;
    }
    var adapter2 = this.platform.adapter;
    var newPersistence = config.persistence || adapter2.primaryStorage;
    if (newPersistence && newPersistence !== this.config.persistence) {
      this.updateConfig({ persistence: newPersistence });
    }
    var _a2 = generateAuthInstance(__assign$r(__assign$r({ wxCloud: this.config.wxCloud, storage: this.config.storage }, config), { persistence: this.config.persistence }), {
      env: this.config.env,
      clientId: this.config.clientId,
      apiOrigin: this.request.getBaseEndPoint(),
      platform: this.platform,
      cache: this.cache,
      app: this,
      debug: this.config.debug
    }), authInstance = _a2.authInstance, oauthInstance = _a2.oauthInstance;
    this.oauthInstance = oauthInstance;
    this.authInstance = authInstance;
    return this.authInstance;
  }
};
try {
  cloudbase.registerComponent(component$8);
} catch (e2) {
}
function registerAuth(app) {
  try {
    app.registerComponent(component$8);
  } catch (e2) {
    console.warn(e2);
  }
}
var __assign$q = function() {
  __assign$q = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$q.apply(this, arguments);
};
var __awaiter$p = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$p = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var ERRORS$4 = ERRORS$8;
var COMPONENT_NAME$6 = "cloudrun";
var CloudbaseRun = function() {
  function CloudbaseRun2() {
  }
  CloudbaseRun2.prototype.callContainer = function(options) {
    return __awaiter$p(this, void 0, void 0, function() {
      var name2, data, jsonData;
      return __generator$p(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            name2 = options.name, data = options.data;
            if (!name2) {
              throw new Error(JSON.stringify({
                code: ERRORS$4.INVALID_PARAMS,
                msg: "[".concat(COMPONENT_NAME$6, ".callContainer] invalid name")
              }));
            }
            try {
              jsonData = data ? JSON.stringify(data) : "";
            } catch (e2) {
              throw new Error(JSON.stringify({
                code: ERRORS$4.INVALID_PARAMS,
                msg: "[".concat(COMPONENT_NAME$6, ".callContainer] invalid data")
              }));
            }
            return [4, requestContainer.call(this, __assign$q(__assign$q({}, options), { data: jsonData }))];
          case 1:
            return [2, _a2.sent()];
        }
      });
    });
  };
  return CloudbaseRun2;
}();
function requestContainer(options) {
  return __awaiter$p(this, void 0, void 0, function() {
    var name2, data, _a2, path, method, _b, header, endpoint, reqPath, response;
    return __generator$p(this, function(_c) {
      switch (_c.label) {
        case 0:
          name2 = options.name, data = options.data, _a2 = options.path, path = _a2 === void 0 ? "" : _a2, method = options.method, _b = options.header, header = _b === void 0 ? {} : _b;
          endpoint = "https://".concat(this.config.env, ".api.tcloudbasegateway.com/v1/cloudrun/").concat(name2);
          reqPath = path.startsWith("/") ? path : "/".concat(path);
          return [4, this.request.fetch({
            method: method || "POST",
            headers: Object.assign({}, {
              "Content-Type": "application/json; charset=utf-8"
            }, header),
            body: data,
            url: "".concat(endpoint).concat(reqPath)
          })];
        case 1:
          response = _c.sent();
          return [4, response.data];
        case 2:
          return [2, _c.sent()];
      }
    });
  });
}
var cloudbaseRun = new CloudbaseRun();
var component$7 = {
  name: COMPONENT_NAME$6,
  entity: {
    callContainer: cloudbaseRun.callContainer
  }
};
try {
  cloudbase.registerComponent(component$7);
} catch (e2) {
}
var __assign$p = function() {
  __assign$p = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$p.apply(this, arguments);
};
var __decorate$2 = function(decorators2, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators2, target, key, desc);
  else
    for (var i = decorators2.length - 1; i >= 0; i--)
      if (d2 = decorators2[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata$2 = function(k2, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k2, v2);
};
var __awaiter$o = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$o = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var getSdkName$1 = getSdkName$4, ERRORS$3 = ERRORS$8, COMMUNITY_SITE_URL$2 = COMMUNITY_SITE_URL$4;
var execCallback$1 = execCallback$3;
var catchErrorsDecorator$2 = catchErrorsDecorator$5;
var COMPONENT_NAME$5 = "functions";
var CloudbaseFunctions = function() {
  function CloudbaseFunctions2() {
  }
  CloudbaseFunctions2.prototype.callFunction = function(options, callback) {
    var _a2, _b;
    return __awaiter$o(this, void 0, void 0, function() {
      var name2, data, query, parse, search, type, _c, path, method, _d, header, jsonData, requestId, result, action, params, request, res, result, e_1;
      return __generator$o(this, function(_e2) {
        switch (_e2.label) {
          case 0:
            name2 = options.name, data = options.data, query = options.query, parse = options.parse, search = options.search, type = options.type, _c = options.path, path = _c === void 0 ? "" : _c, method = options.method, _d = options.header, header = _d === void 0 ? {} : _d;
            if (!name2) {
              throw new Error(JSON.stringify({
                code: ERRORS$3.INVALID_PARAMS,
                msg: "[".concat(COMPONENT_NAME$5, ".callFunction] invalid function name")
              }));
            }
            try {
              jsonData = data ? JSON.stringify(data) : "";
            } catch (e2) {
              throw new Error(JSON.stringify({
                code: ERRORS$3.INVALID_PARAMS,
                msg: "[".concat(COMPONENT_NAME$5, ".callFunction] invalid data")
              }));
            }
            if (!(type === "cloudrun"))
              return [3, 2];
            requestId = generateRequestId$2();
            return [4, requestContainer.call(this, {
              name: name2,
              data: jsonData,
              path,
              method,
              header: __assign$p(__assign$p({}, header), { "X-Request-Id": requestId })
            })];
          case 1:
            result = _e2.sent();
            return [2, {
              result,
              requestId
            }];
          case 2:
            action = "functions.invokeFunction";
            params = {
              inQuery: query,
              parse,
              search,
              function_name: name2,
              request_data: jsonData
            };
            request = this.request;
            _e2.label = 3;
          case 3:
            _e2.trys.push([3, 5, , 6]);
            return [4, request.send(action, params, {
              defaultQuery: ((_a2 = data === null || data === void 0 ? void 0 : data.params) === null || _a2 === void 0 ? void 0 : _a2.action) ? { action: (_b = data === null || data === void 0 ? void 0 : data.params) === null || _b === void 0 ? void 0 : _b.action } : {}
            })];
          case 4:
            res = _e2.sent();
            if (res.code) {
              return [2, execCallback$1(callback, null, res)];
            }
            result = res.data.response_data;
            if (parse) {
              return [2, execCallback$1(callback, null, {
                result,
                requestId: res.requestId
              })];
            }
            try {
              result = JSON.parse(res.data.response_data);
              return [2, execCallback$1(callback, null, {
                result,
                requestId: res.requestId
              })];
            } catch (e2) {
              execCallback$1(callback, new Error("[".concat(getSdkName$1(), "][").concat(ERRORS$3.INVALID_PARAMS, "][").concat(COMPONENT_NAME$5, ".callFunction] response data must be json")));
            }
            return [3, 6];
          case 5:
            e_1 = _e2.sent();
            execCallback$1(callback, e_1);
            return [3, 6];
          case 6:
            return [2];
        }
      });
    });
  };
  __decorate$2([
    catchErrorsDecorator$2({
      customInfo: {
        className: "Cloudbase",
        methodName: "callFunction"
      },
      title: "函数调用失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 callFunction() 的语法或参数是否正确",
        "  2 - 当前环境下是否存在此函数",
        "  3 - 函数安全规则是否限制了当前登录状态访问",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(COMMUNITY_SITE_URL$2)
      ]
    }),
    __metadata$2("design:type", Function),
    __metadata$2("design:paramtypes", [Object, Function]),
    __metadata$2("design:returntype", Promise)
  ], CloudbaseFunctions2.prototype, "callFunction", null);
  return CloudbaseFunctions2;
}();
var cloudbaseFunctions = new CloudbaseFunctions();
var component$6 = {
  name: COMPONENT_NAME$5,
  entity: {
    callFunction: cloudbaseFunctions.callFunction
  }
};
try {
  cloudbase.registerComponent(component$6);
} catch (e2) {
}
function registerFunctions(app) {
  try {
    app.registerComponent(component$6);
  } catch (e2) {
    console.warn(e2);
  }
}
var __assign$o = function() {
  __assign$o = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$o.apply(this, arguments);
};
var __decorate$1 = function(decorators2, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators2, target, key, desc);
  else
    for (var i = decorators2.length - 1; i >= 0; i--)
      if (d2 = decorators2[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata$1 = function(k2, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k2, v2);
};
var __awaiter$n = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$n = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var EUploadMethod;
(function(EUploadMethod2) {
  EUploadMethod2["put"] = "put";
  EUploadMethod2["post"] = "post";
})(EUploadMethod || (EUploadMethod = {}));
var getSdkName = getSdkName$4, ERRORS$2 = ERRORS$8, COMMUNITY_SITE_URL$1 = COMMUNITY_SITE_URL$4;
var isArray$3 = isArray$5, isString$1 = isString$3, isPalinObject = isPalinObject$2, execCallback = execCallback$3;
var catchErrorsDecorator$1 = catchErrorsDecorator$5;
var COMPONENT_NAME$4 = "storage";
var CloudbaseStorage = function() {
  function CloudbaseStorage2() {
  }
  CloudbaseStorage2.prototype.uploadFile = function(params, callback) {
    return __awaiter$n(this, void 0, void 0, function() {
      var cloudPath, filePath, onUploadProgress, _a2, method, _b, headers, uploadMethod, action, request, metaDataParam, metaData, _c, url, authorization, token, fileId, cosFileId, downloadUrl, requestId, commonParams, putParams, postParams, uploadConfig, res;
      var _d;
      return __generator$n(this, function(_e2) {
        switch (_e2.label) {
          case 0:
            cloudPath = params.cloudPath, filePath = params.filePath, onUploadProgress = params.onUploadProgress, _a2 = params.method, method = _a2 === void 0 ? "put" : _a2, _b = params.headers, headers = _b === void 0 ? {} : _b;
            if (!isString$1(cloudPath) || !filePath) {
              throw new Error(JSON.stringify({
                code: ERRORS$2.INVALID_PARAMS,
                msg: "[".concat(COMPONENT_NAME$4, ".uploadFile] invalid params")
              }));
            }
            uploadMethod = { put: EUploadMethod.put, post: EUploadMethod.post }[method.toLocaleLowerCase()] || EUploadMethod.put;
            action = "storage.getUploadMetadata";
            request = this.request;
            metaDataParam = {
              path: cloudPath,
              method: uploadMethod
            };
            if (uploadMethod === EUploadMethod.put) {
              metaDataParam["headers"] = headers;
            }
            return [4, request.send(action, metaDataParam)];
          case 1:
            metaData = _e2.sent();
            _c = metaData.data, url = _c.url, authorization = _c.authorization, token = _c.token, fileId = _c.fileId, cosFileId = _c.cosFileId, downloadUrl = _c.download_url, requestId = metaData.requestId;
            commonParams = {
              url,
              file: filePath,
              name: cloudPath,
              onUploadProgress
            };
            putParams = __assign$o(__assign$o({}, commonParams), { method: EUploadMethod.put, headers: __assign$o(__assign$o({}, headers), { authorization, "x-cos-meta-fileid": cosFileId, "x-cos-security-token": token }) });
            postParams = __assign$o(__assign$o({}, commonParams), { method: EUploadMethod.post, data: {
              key: cloudPath,
              signature: authorization,
              "x-cos-meta-fileid": cosFileId,
              success_action_status: "201",
              "x-cos-security-token": token
            } });
            uploadConfig = (_d = {}, _d[EUploadMethod.put] = {
              params: putParams,
              isSuccess: function(code2) {
                return code2 >= 200 && code2 < 300;
              }
            }, _d[EUploadMethod.post] = {
              params: postParams,
              isSuccess: function(code2) {
                return code2 === 201;
              }
            }, _d);
            return [4, request.upload(uploadConfig[uploadMethod].params)];
          case 2:
            res = _e2.sent();
            if (uploadConfig[uploadMethod].isSuccess(res.statusCode)) {
              return [2, execCallback(callback, null, {
                fileID: fileId,
                download_url: downloadUrl,
                requestId
              })];
            }
            return [2, execCallback(callback, new Error("[".concat(getSdkName(), "][").concat(ERRORS$2.OPERATION_FAIL, "][").concat(COMPONENT_NAME$4, "]:").concat(res.data)))];
        }
      });
    });
  };
  CloudbaseStorage2.prototype.getUploadMetadata = function(params, callback) {
    return __awaiter$n(this, void 0, void 0, function() {
      var cloudPath, request, action, metaData, err_1;
      return __generator$n(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            cloudPath = params.cloudPath;
            if (!isString$1(cloudPath)) {
              throw new Error(JSON.stringify({
                code: ERRORS$2.INVALID_PARAMS,
                msg: "[".concat(COMPONENT_NAME$4, ".getUploadMetadata] invalid cloudPath")
              }));
            }
            request = this.request;
            action = "storage.getUploadMetadata";
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, request.send(action, {
              path: cloudPath
            })];
          case 2:
            metaData = _a2.sent();
            return [2, execCallback(callback, null, metaData)];
          case 3:
            err_1 = _a2.sent();
            return [2, execCallback(callback, err_1)];
          case 4:
            return [2];
        }
      });
    });
  };
  CloudbaseStorage2.prototype.deleteFile = function(params, callback) {
    return __awaiter$n(this, void 0, void 0, function() {
      var fileList, _i, fileList_1, fileId, action, request, res, data;
      return __generator$n(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            fileList = params.fileList;
            if (!fileList || !isArray$3(fileList) || fileList.length === 0) {
              throw new Error(JSON.stringify({
                code: ERRORS$2.INVALID_PARAMS,
                msg: "[".concat(COMPONENT_NAME$4, ".deleteFile] fileList must not be empty")
              }));
            }
            for (_i = 0, fileList_1 = fileList; _i < fileList_1.length; _i++) {
              fileId = fileList_1[_i];
              if (!fileId || !isString$1(fileId)) {
                throw new Error(JSON.stringify({
                  code: ERRORS$2.INVALID_PARAMS,
                  msg: "[".concat(COMPONENT_NAME$4, ".deleteFile] fileID must be string")
                }));
              }
            }
            action = "storage.batchDeleteFile";
            request = this.request;
            return [4, request.send(action, {
              fileid_list: fileList
            })];
          case 1:
            res = _a2.sent();
            if (res.code) {
              return [2, execCallback(callback, null, res)];
            }
            data = {
              fileList: res.data.delete_list,
              requestId: res.requestId
            };
            return [2, execCallback(callback, null, data)];
        }
      });
    });
  };
  CloudbaseStorage2.prototype.getTempFileURL = function(params, callback) {
    return __awaiter$n(this, void 0, void 0, function() {
      var fileList, convertedFileList, _i, fileList_2, file, action, request, res;
      return __generator$n(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            fileList = params.fileList;
            if (!fileList || !isArray$3(fileList) || fileList.length === 0) {
              throw new Error(JSON.stringify({
                code: ERRORS$2.INVALID_PARAMS,
                msg: "[".concat(COMPONENT_NAME$4, ".getTempFileURL] fileList must not be empty")
              }));
            }
            convertedFileList = [];
            for (_i = 0, fileList_2 = fileList; _i < fileList_2.length; _i++) {
              file = fileList_2[_i];
              if (isPalinObject(file)) {
                if (!Object.prototype.hasOwnProperty.call(file, "fileID") || !Object.prototype.hasOwnProperty.call(file, "maxAge")) {
                  throw new Error(JSON.stringify({
                    code: ERRORS$2.INVALID_PARAMS,
                    msg: "[".concat(COMPONENT_NAME$4, ".getTempFileURL] file info must include fileID and maxAge")
                  }));
                }
                convertedFileList.push({
                  fileid: file.fileID,
                  max_age: file.maxAge
                });
              } else if (isString$1(file)) {
                convertedFileList.push({
                  fileid: file
                });
              } else {
                throw new Error(JSON.stringify({
                  code: ERRORS$2.INVALID_PARAMS,
                  msg: "[".concat(COMPONENT_NAME$4, ".getTempFileURL] invalid fileList")
                }));
              }
            }
            action = "storage.batchGetDownloadUrl";
            request = this.request;
            return [4, request.send(action, { file_list: convertedFileList })];
          case 1:
            res = _a2.sent();
            if (res.code) {
              return [2, execCallback(callback, null, res)];
            }
            return [2, execCallback(callback, null, {
              fileList: res.data.download_list,
              requestId: res.requestId
            })];
        }
      });
    });
  };
  CloudbaseStorage2.prototype.downloadFile = function(params, callback) {
    return __awaiter$n(this, void 0, void 0, function() {
      var fileID, tmpUrlRes, res, request, tmpUrl, result;
      return __generator$n(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            fileID = params.fileID;
            if (!isString$1(fileID)) {
              throw new Error(JSON.stringify({
                code: ERRORS$2.INVALID_PARAMS,
                msg: "[".concat(COMPONENT_NAME$4, ".getTempFileURL] fileID must be string")
              }));
            }
            return [4, this.getTempFileURL.call(this, {
              fileList: [{
                fileID,
                maxAge: 600
              }]
            })];
          case 1:
            tmpUrlRes = _a2.sent();
            res = tmpUrlRes.fileList[0];
            if (res.code !== "SUCCESS") {
              return [2, execCallback(callback, res)];
            }
            request = this.request;
            tmpUrl = encodeURI(res.download_url);
            return [4, request.download({ url: tmpUrl })];
          case 2:
            result = _a2.sent();
            return [2, execCallback(callback, null, result)];
        }
      });
    });
  };
  __decorate$1([
    catchErrorsDecorator$1({
      customInfo: {
        className: "Cloudbase",
        methodName: "uploadFile"
      },
      title: "上传文件失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 uploadFile() 的语法或参数是否正确",
        "  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety",
        "  3 - 云存储安全规则是否限制了当前登录状态访问",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(COMMUNITY_SITE_URL$1)
      ]
    }),
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Function]),
    __metadata$1("design:returntype", Promise)
  ], CloudbaseStorage2.prototype, "uploadFile", null);
  __decorate$1([
    catchErrorsDecorator$1({
      customInfo: {
        className: "Cloudbase",
        methodName: "getUploadMetadata"
      },
      title: "获取上传元信息失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 getUploadMetadata() 的语法或参数是否正确",
        "  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety",
        "  3 - 云存储安全规则是否限制了当前登录状态访问",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(COMMUNITY_SITE_URL$1)
      ]
    }),
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Function]),
    __metadata$1("design:returntype", Promise)
  ], CloudbaseStorage2.prototype, "getUploadMetadata", null);
  __decorate$1([
    catchErrorsDecorator$1({
      customInfo: {
        className: "Cloudbase",
        methodName: "deleteFile"
      },
      title: "删除文件失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 deleteFile() 的语法或参数是否正确",
        "  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety",
        "  3 - 云存储安全规则是否限制了当前登录状态访问",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(COMMUNITY_SITE_URL$1)
      ]
    }),
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Function]),
    __metadata$1("design:returntype", Promise)
  ], CloudbaseStorage2.prototype, "deleteFile", null);
  __decorate$1([
    catchErrorsDecorator$1({
      customInfo: {
        className: "Cloudbase",
        methodName: "getTempFileURL"
      },
      title: "获取文件下载链接",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 getTempFileURL() 的语法或参数是否正确",
        "  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety",
        "  3 - 云存储安全规则是否限制了当前登录状态访问",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(COMMUNITY_SITE_URL$1)
      ]
    }),
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Function]),
    __metadata$1("design:returntype", Promise)
  ], CloudbaseStorage2.prototype, "getTempFileURL", null);
  __decorate$1([
    catchErrorsDecorator$1({
      customInfo: {
        className: "Cloudbase",
        methodName: "downloadFile"
      },
      title: "下载文件失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 downloadFile() 的语法或参数是否正确",
        "  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety",
        "  3 - 云存储安全规则是否限制了当前登录状态访问",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(COMMUNITY_SITE_URL$1)
      ]
    }),
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Function]),
    __metadata$1("design:returntype", Promise)
  ], CloudbaseStorage2.prototype, "downloadFile", null);
  return CloudbaseStorage2;
}();
var cloudbaseStorage = new CloudbaseStorage();
var component$5 = {
  name: COMPONENT_NAME$4,
  entity: {
    uploadFile: cloudbaseStorage.uploadFile,
    deleteFile: cloudbaseStorage.deleteFile,
    getTempFileURL: cloudbaseStorage.getTempFileURL,
    downloadFile: cloudbaseStorage.downloadFile,
    getUploadMetadata: cloudbaseStorage.getUploadMetadata
  }
};
try {
  cloudbase.registerComponent(component$5);
} catch (e2) {
}
function registerStorage(app) {
  try {
    app.registerComponent(component$5);
  } catch (e2) {
    console.warn(e2);
  }
}
var FUNC_ERROR_TEXT$1 = "Expected a function";
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var INFINITY$1 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
var funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", symbolTag$1 = "[object Symbol]";
var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp$1 = /^\w*$/, reLeadingDot$1 = /^\./, rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar$1 = /\\(\\)?/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal$1 || freeSelf$1 || Function("return this")();
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject$1(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e2) {
    }
  }
  return result;
}
var arrayProto$1 = Array.prototype, funcProto$1 = Function.prototype, objectProto$1 = Object.prototype;
var coreJsData$1 = root$1["__core-js_shared__"];
var maskSrcKey$1 = function() {
  var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
var objectToString$1 = objectProto$1.toString;
var reIsNative$1 = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
var Symbol$2 = root$1.Symbol, splice$1 = arrayProto$1.splice;
var Map$2 = getNative$1(root$1, "Map"), nativeCreate$1 = getNative$1(Object, "create");
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : void 0;
function Hash$1(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function hashClear$1() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
}
function hashDelete$1(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
}
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
}
function hashSet$1(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
Hash$1.prototype.clear = hashClear$1;
Hash$1.prototype["delete"] = hashDelete$1;
Hash$1.prototype.get = hashGet$1;
Hash$1.prototype.has = hashHas$1;
Hash$1.prototype.set = hashSet$1;
function ListCache$1(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear$1() {
  this.__data__ = [];
}
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index2, 1);
  }
  return true;
}
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
ListCache$1.prototype.clear = listCacheClear$1;
ListCache$1.prototype["delete"] = listCacheDelete$1;
ListCache$1.prototype.get = listCacheGet$1;
ListCache$1.prototype.has = listCacheHas$1;
ListCache$1.prototype.set = listCacheSet$1;
function MapCache$1(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear$1() {
  this.__data__ = {
    "hash": new Hash$1(),
    "map": new (Map$2 || ListCache$1)(),
    "string": new Hash$1()
  };
}
function mapCacheDelete$1(key) {
  return getMapData$1(this, key)["delete"](key);
}
function mapCacheGet$1(key) {
  return getMapData$1(this, key).get(key);
}
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
function mapCacheSet$1(key, value) {
  getMapData$1(this, key).set(key, value);
  return this;
}
MapCache$1.prototype.clear = mapCacheClear$1;
MapCache$1.prototype["delete"] = mapCacheDelete$1;
MapCache$1.prototype.get = mapCacheGet$1;
MapCache$1.prototype.has = mapCacheHas$1;
MapCache$1.prototype.set = mapCacheSet$1;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$1.call(object, key) && eq$1(objValue, value)) || value === void 0 && !(key in object)) {
    object[key] = value;
  }
}
function assocIndexOf$1(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseIsNative$1(value) {
  if (!isObject$2(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$1(value) || isHostObject$1(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$1(value));
}
function baseSet(object, path, value, customizer) {
  if (!isObject$2(object)) {
    return object;
  }
  path = isKey$1(path, object) ? [path] : castPath$1(path);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key = toKey$1(path[index2]), newValue = value;
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol$1(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function castPath$1(value) {
  return isArray$2(value) ? value : stringToPath$1(value);
}
function getMapData$1(map2, key) {
  var data = map2.__data__;
  return isKeyable$1(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative$1(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative$1(value) ? value : void 0;
}
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isKey$1(value, object) {
  if (isArray$2(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
}
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var stringToPath$1 = memoize$1(function(string) {
  string = toString$1(string);
  var result = [];
  if (reLeadingDot$1.test(string)) {
    result.push("");
  }
  string.replace(rePropName$1, function(match, number, quote, string2) {
    result.push(quote ? string2.replace(reEscapeChar$1, "$1") : number || match);
  });
  return result;
});
function toKey$1(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result);
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache$1)();
  return memoized;
}
memoize$1.Cache = MapCache$1;
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}
var isArray$2 = Array.isArray;
function isFunction$1(value) {
  var tag = isObject$2(value) ? objectToString$1.call(value) : "";
  return tag == funcTag$1 || tag == genTag$1;
}
function isObject$2(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike$2(value) {
  return !!value && typeof value == "object";
}
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike$2(value) && objectToString$1.call(value) == symbolTag$1;
}
function toString$1(value) {
  return value == null ? "" : baseToString$1(value);
}
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}
var lodash_set = set;
const set$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_set);
var FUNC_ERROR_TEXT = "Expected a function";
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var INFINITY = 1 / 0;
var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", symbolTag = "[object Symbol]";
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e2) {
    }
  }
  return result;
}
var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
var Symbol$1 = root.Symbol, splice = arrayProto.splice;
var Map$1 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function Hash(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : void 0;
}
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
}
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear() {
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function mapCacheDelete(key) {
  return getMapData(this, key)["delete"](key);
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function baseSlice(array, start, end) {
  var index2 = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array[index2 + start];
  }
  return result;
}
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function baseUnset(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);
  object = parent(object, path);
  var key = toKey(last(path));
  return !(object != null && hasOwnProperty.call(object, key)) || delete object[key];
}
function castPath(value) {
  return isArray$1(value) ? value : stringToPath(value);
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
function parent(object, path) {
  return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
}
var stringToPath = memoize(function(string) {
  string = toString2(string);
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, string2) {
    result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : void 0;
}
function memoize(func, resolver) {
  if (typeof func != "function" || resolver && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var isArray$1 = Array.isArray;
function isFunction(value) {
  var tag = isObject$1(value) ? objectToString.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isObject$1(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike$1(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike$1(value) && objectToString.call(value) == symbolTag;
}
function toString2(value) {
  return value == null ? "" : baseToString(value);
}
function unset(object, path) {
  return object == null ? true : baseUnset(object, path);
}
var lodash_unset = unset;
const unset$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_unset);
var lodash_clonedeep = { exports: {} };
lodash_clonedeep.exports;
(function(module2, exports2) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag2] = cloneableTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map2, pair) {
    map2.set(pair[0], pair[1]);
    return map2;
  }
  function addSetEntry(set2, value) {
    set2.add(value);
    return set2;
  }
  function arrayEach(array, iteratee) {
    var index2 = -1, length = array ? array.length : 0;
    while (++index2 < length) {
      if (iteratee(array[index2], index2, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index2 = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index2];
    }
    while (++index2 < length) {
      accumulator = iteratee(accumulator, array[index2], index2, array);
    }
    return accumulator;
  }
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject2(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e2) {
      }
    }
    return result;
  }
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var maskSrcKey2 = function() {
    var uid2 = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var objectToString2 = objectProto2.toString;
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
  var dataViewCtorString = toSource2(DataView2), mapCtorString = toSource2(Map2), promiseCtorString = toSource2(Promise2), setCtorString = toSource2(Set2), weakMapCtorString = toSource2(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash2(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
  }
  function hashDelete2(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    return getMapData2(this, key)["delete"](key);
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    getMapData2(this, key).set(key, value);
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function Stack(entries) {
    this.__data__ = new ListCache2(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache2();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache2 = this.__data__;
    if (cache2 instanceof ListCache2) {
      var pairs = cache2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache2 = this.__data__ = new MapCache2(pairs);
    }
    cache2.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex2(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignValue2(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf2(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack2) {
    var result;
    if (customizer) {
      result = object ? customizer(value, key, object, stack2) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject2(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag2 || tag == genTag2;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        if (isHostObject2(value)) {
          return object ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    }
    stack2 || (stack2 = new Stack());
    var stacked = stack2.get(value);
    if (stacked) {
      return stacked;
    }
    stack2.set(value, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys(value);
    }
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue2(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack2));
    });
    return result;
  }
  function baseCreate(proto) {
    return isObject2(proto) ? objectCreate(proto) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    return objectToString2.call(value);
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function cloneBuffer(buffer2, isDeep) {
    if (isDeep) {
      return buffer2.slice();
    }
    var result = new buffer2.constructor(buffer2.length);
    buffer2.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
    return arrayReduce(array, addMapEntry, new map2.constructor());
  }
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  function cloneSet(set2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
    return arrayReduce(array, addSetEntry, new set2.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array) {
    var index2 = -1, length = source.length;
    array || (array = Array(length));
    while (++index2 < length) {
      array[index2] = source[index2];
    }
    return array;
  }
  function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      assignValue2(object, key, newValue === void 0 ? source[key] : newValue);
    }
    return object;
  }
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getMapData2(map2, key) {
    var data = map2.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = objectToString2.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag2:
        return cloneSymbol(object);
    }
  }
  function isIndex2(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable2(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  function cloneDeep2(value) {
    return baseClone(value, true, true);
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString2.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike2(value) && isArrayLike(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString2.call(value) : "";
    return tag == funcTag2 || tag == genTag2;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike2(value) {
    return !!value && typeof value == "object";
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module2.exports = cloneDeep2;
})(lodash_clonedeep, lodash_clonedeep.exports);
var lodash_clonedeepExports = lodash_clonedeep.exports;
const cloneDeep = /* @__PURE__ */ getDefaultExportFromCjs(lodash_clonedeepExports);
function genRequestId(prefix) {
  if (prefix === void 0) {
    prefix = "";
  }
  return "".concat(prefix ? "".concat(prefix, "_") : "").concat(+/* @__PURE__ */ new Date(), "_").concat(Math.random());
}
var RealtimeListener = /* @__PURE__ */ function() {
  function RealtimeListener2(options) {
    this.close = options.close;
    this.onChange = options.onChange;
    this.onError = options.onError;
    if (options.debug) {
      Object.defineProperty(this, "virtualClient", {
        get: function() {
          return options.virtualClient;
        }
      });
    }
  }
  return RealtimeListener2;
}();
var Snapshot = /* @__PURE__ */ function() {
  function Snapshot2(options) {
    var id = options.id, docChanges = options.docChanges, docs = options.docs, msgType = options.msgType, type = options.type;
    var cachedDocChanges;
    var cachedDocs;
    Object.defineProperties(this, {
      id: {
        get: function() {
          return id;
        },
        enumerable: true
      },
      docChanges: {
        get: function() {
          if (!cachedDocChanges) {
            cachedDocChanges = JSON.parse(JSON.stringify(docChanges));
          }
          return cachedDocChanges;
        },
        enumerable: true
      },
      docs: {
        get: function() {
          if (!cachedDocs) {
            cachedDocs = JSON.parse(JSON.stringify(docs));
          }
          return cachedDocs;
        },
        enumerable: true
      },
      msgType: {
        get: function() {
          return msgType;
        },
        enumerable: true
      },
      type: {
        get: function() {
          return type;
        },
        enumerable: true
      }
    });
  }
  return Snapshot2;
}();
var __extends$7 = /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var RealtimeErrorMessageError = function(_super) {
  __extends$7(RealtimeErrorMessageError2, _super);
  function RealtimeErrorMessageError2(serverErrorMsg) {
    var _this = _super.call(this, "Watch Error ".concat(JSON.stringify(serverErrorMsg.msgData), " (requestid: ").concat(serverErrorMsg.requestId, ")")) || this;
    _this.isRealtimeErrorMessageError = true;
    _this.payload = serverErrorMsg;
    return _this;
  }
  return RealtimeErrorMessageError2;
}(Error);
var isRealtimeErrorMessageError = function(e2) {
  return e2 === null || e2 === void 0 ? void 0 : e2.isRealtimeErrorMessageError;
};
var TimeoutError = function(_super) {
  __extends$7(TimeoutError2, _super);
  function TimeoutError2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "timeout";
    _this.payload = null;
    _this.generic = true;
    return _this;
  }
  return TimeoutError2;
}(Error);
var isTimeoutError = function(e2) {
  return e2.type === "timeout";
};
var CancelledError = function(_super) {
  __extends$7(CancelledError2, _super);
  function CancelledError2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cancelled";
    _this.payload = null;
    _this.generic = true;
    return _this;
  }
  return CancelledError2;
}(Error);
var isCancelledError = function(e2) {
  return e2.type === "cancelled";
};
var CloudSDKError = function(_super) {
  __extends$7(CloudSDKError2, _super);
  function CloudSDKError2(options) {
    var _this = _super.call(this, options.errMsg) || this;
    _this.errCode = "UNKNOWN_ERROR";
    Object.defineProperties(_this, {
      message: {
        get: function() {
          return "errCode: ".concat(this.errCode, " ").concat(ERR_CODE[this.errCode] || "", " | errMsg: ").concat(this.errMsg);
        },
        set: function(msg) {
          this.errMsg = msg;
        }
      }
    });
    _this.errCode = options.errCode || "UNKNOWN_ERROR";
    _this.errMsg = options.errMsg;
    return _this;
  }
  Object.defineProperty(CloudSDKError2.prototype, "message", {
    get: function() {
      return "errCode: ".concat(this.errCode, " | errMsg: ").concat(this.errMsg);
    },
    set: function(msg) {
      this.errMsg = msg;
    },
    enumerable: false,
    configurable: true
  });
  return CloudSDKError2;
}(Error);
var ERR_CODE = {
  UNKNOWN_ERROR: "UNKNOWN_ERROR",
  SDK_DATABASE_REALTIME_LISTENER_INIT_WATCH_FAIL: "SDK_DATABASE_REALTIME_LISTENER_INIT_WATCH_FAIL",
  SDK_DATABASE_REALTIME_LISTENER_RECONNECT_WATCH_FAIL: "SDK_DATABASE_REALTIME_LISTENER_RECONNECT_WATCH_FAIL",
  SDK_DATABASE_REALTIME_LISTENER_REBUILD_WATCH_FAIL: "SDK_DATABASE_REALTIME_LISTENER_REBUILD_WATCH_FAIL",
  SDK_DATABASE_REALTIME_LISTENER_CLOSE_WATCH_FAIL: "SDK_DATABASE_REALTIME_LISTENER_CLOSE_WATCH_FAIL",
  SDK_DATABASE_REALTIME_LISTENER_SERVER_ERROR_MSG: "SDK_DATABASE_REALTIME_LISTENER_SERVER_ERROR_MSG",
  SDK_DATABASE_REALTIME_LISTENER_RECEIVE_INVALID_SERVER_DATA: "SDK_DATABASE_REALTIME_LISTENER_RECEIVE_INVALID_SERVER_DATA",
  SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_ERROR: "SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_ERROR",
  SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_CLOSED: "SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_CLOSED",
  SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL: "SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL",
  SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR: "SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR"
};
var sleep = function(ms) {
  if (ms === void 0) {
    ms = 0;
  }
  return new Promise(function(r2) {
    return setTimeout(r2, ms);
  });
};
var __awaiter$m = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$m = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArray$1 = function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar2; i < l2; i++) {
      if (ar2 || !(i in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i);
        ar2[i] = from[i];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
var WatchStatus;
(function(WatchStatus2) {
  WatchStatus2["LOGGINGIN"] = "LOGGINGIN";
  WatchStatus2["INITING"] = "INITING";
  WatchStatus2["REBUILDING"] = "REBUILDING";
  WatchStatus2["ACTIVE"] = "ACTIVE";
  WatchStatus2["ERRORED"] = "ERRORED";
  WatchStatus2["CLOSING"] = "CLOSING";
  WatchStatus2["CLOSED"] = "CLOSED";
  WatchStatus2["PAUSED"] = "PAUSED";
  WatchStatus2["RESUMING"] = "RESUMING";
})(WatchStatus || (WatchStatus = {}));
var DEFAULT_WAIT_TIME_ON_UNKNOWN_ERROR = 100;
var DEFAULT_MAX_AUTO_RETRY_ON_ERROR = 2;
var DEFAULT_MAX_SEND_ACK_AUTO_RETRY_ON_ERROR = 2;
var DEFAULT_SEND_ACK_DEBOUNCE_TIMEOUT = 10 * 1e3;
var DEFAULT_INIT_WATCH_TIMEOUT = 10 * 1e3;
var DEFAULT_REBUILD_WATCH_TIMEOUT = 10 * 1e3;
var VirtualWebSocketClient = function() {
  function VirtualWebSocketClient2(options) {
    var _this = this;
    this.watchStatus = WatchStatus.INITING;
    this.wsLogin = function(envId, refresh) {
      return __awaiter$m(_this, void 0, void 0, function() {
        var loginResult;
        return __generator$m(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.watchStatus = WatchStatus.LOGGINGIN;
              return [4, this.login(envId, refresh)];
            case 1:
              loginResult = _a2.sent();
              if (!this.envId) {
                this.envId = loginResult.envId;
              }
              return [2, loginResult];
          }
        });
      });
    };
    this.initWatch = function(forceRefreshLogin) {
      return __awaiter$m(_this, void 0, void 0, function() {
        var success;
        var _this2 = this;
        return __generator$m(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this.initWatchPromise !== null && this.initWatchPromise !== void 0) {
                return [2, this.initWatchPromise];
              }
              this.initWatchPromise = new Promise(function(resolve2, reject) {
                void function() {
                  return __awaiter$m(_this2, void 0, void 0, function() {
                    var envId, initWatchMsg, initEventMsg, _a3, events2, currEvent, _i, events_1, e2, snapshot, e_1;
                    return __generator$m(this, function(_b) {
                      switch (_b.label) {
                        case 0:
                          _b.trys.push([0, 3, , 4]);
                          if (this.watchStatus === WatchStatus.PAUSED) {
                            console.log("[realtime] initWatch cancelled on pause");
                            return [2, resolve2()];
                          }
                          return [4, this.wsLogin(this.envId, forceRefreshLogin)];
                        case 1:
                          envId = _b.sent().envId;
                          if (this.watchStatus === WatchStatus.PAUSED) {
                            console.log("[realtime] initWatch cancelled on pause");
                            return [2, resolve2()];
                          }
                          this.watchStatus = WatchStatus.INITING;
                          initWatchMsg = {
                            watchId: this.watchId,
                            requestId: genRequestId(),
                            msgType: "INIT_WATCH",
                            msgData: {
                              envId,
                              collName: this.collectionName,
                              query: this.query,
                              limit: this.limit,
                              orderBy: this.orderBy
                            }
                          };
                          return [4, this.send({
                            msg: initWatchMsg,
                            waitResponse: true,
                            skipOnMessage: true,
                            timeout: DEFAULT_INIT_WATCH_TIMEOUT
                          })];
                        case 2:
                          initEventMsg = _b.sent();
                          _a3 = initEventMsg.msgData, events2 = _a3.events, currEvent = _a3.currEvent;
                          this.sessionInfo = {
                            queryID: initEventMsg.msgData.queryID,
                            currentEventId: currEvent - 1,
                            currentDocs: []
                          };
                          if (events2.length > 0) {
                            for (_i = 0, events_1 = events2; _i < events_1.length; _i++) {
                              e2 = events_1[_i];
                              e2.ID = currEvent;
                            }
                            this.handleServerEvents(initEventMsg);
                          } else {
                            this.sessionInfo.currentEventId = currEvent;
                            snapshot = new Snapshot({
                              id: currEvent,
                              docChanges: [],
                              docs: [],
                              type: "init"
                            });
                            this.listener.onChange(snapshot);
                            this.scheduleSendACK();
                          }
                          this.onWatchStart(this, this.sessionInfo.queryID);
                          this.watchStatus = WatchStatus.ACTIVE;
                          this.availableRetries.INIT_WATCH = DEFAULT_MAX_AUTO_RETRY_ON_ERROR;
                          resolve2();
                          return [3, 4];
                        case 3:
                          e_1 = _b.sent();
                          this.handleWatchEstablishmentError(e_1, {
                            operationName: "INIT_WATCH",
                            resolve: resolve2,
                            reject
                          });
                          return [3, 4];
                        case 4:
                          return [2];
                      }
                    });
                  });
                }();
              });
              success = false;
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, , 3, 4]);
              return [4, this.initWatchPromise];
            case 2:
              _a2.sent();
              success = true;
              return [3, 4];
            case 3:
              this.initWatchPromise = void 0;
              return [7];
            case 4:
              console.log("[realtime] initWatch ".concat(success ? "success" : "fail"));
              return [2];
          }
        });
      });
    };
    this.rebuildWatch = function(forceRefreshLogin) {
      return __awaiter$m(_this, void 0, void 0, function() {
        var success;
        var _this2 = this;
        return __generator$m(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this.rebuildWatchPromise !== null && this.rebuildWatchPromise !== void 0) {
                return [2, this.rebuildWatchPromise];
              }
              this.rebuildWatchPromise = new Promise(function(resolve2, reject) {
                void function() {
                  return __awaiter$m(_this2, void 0, void 0, function() {
                    var envId, rebuildWatchMsg, nextEventMsg, e_2;
                    return __generator$m(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          _a3.trys.push([0, 3, , 4]);
                          if (this.watchStatus === WatchStatus.PAUSED) {
                            console.log("[realtime] rebuildWatch cancelled on pause");
                            return [2, resolve2()];
                          }
                          return [4, this.wsLogin(this.envId, forceRefreshLogin)];
                        case 1:
                          envId = _a3.sent().envId;
                          if (!this.sessionInfo) {
                            throw new Error("can not rebuildWatch without a successful initWatch (lack of sessionInfo)");
                          }
                          if (this.watchStatus === WatchStatus.PAUSED) {
                            console.log("[realtime] rebuildWatch cancelled on pause");
                            return [2, resolve2()];
                          }
                          this.watchStatus = WatchStatus.REBUILDING;
                          rebuildWatchMsg = {
                            watchId: this.watchId,
                            requestId: genRequestId(),
                            msgType: "REBUILD_WATCH",
                            msgData: {
                              envId,
                              collName: this.collectionName,
                              queryID: this.sessionInfo.queryID,
                              eventID: this.sessionInfo.currentEventId
                            }
                          };
                          return [4, this.send({
                            msg: rebuildWatchMsg,
                            waitResponse: true,
                            skipOnMessage: false,
                            timeout: DEFAULT_REBUILD_WATCH_TIMEOUT
                          })];
                        case 2:
                          nextEventMsg = _a3.sent();
                          this.handleServerEvents(nextEventMsg);
                          this.watchStatus = WatchStatus.ACTIVE;
                          this.availableRetries.REBUILD_WATCH = DEFAULT_MAX_AUTO_RETRY_ON_ERROR;
                          resolve2();
                          return [3, 4];
                        case 3:
                          e_2 = _a3.sent();
                          this.handleWatchEstablishmentError(e_2, {
                            operationName: "REBUILD_WATCH",
                            resolve: resolve2,
                            reject
                          });
                          return [3, 4];
                        case 4:
                          return [2];
                      }
                    });
                  });
                }();
              });
              success = false;
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, , 3, 4]);
              return [4, this.rebuildWatchPromise];
            case 2:
              _a2.sent();
              success = true;
              return [3, 4];
            case 3:
              this.rebuildWatchPromise = void 0;
              return [7];
            case 4:
              console.log("[realtime] rebuildWatch ".concat(success ? "success" : "fail"));
              return [2];
          }
        });
      });
    };
    this.handleWatchEstablishmentError = function(e2, options2) {
      return __awaiter$m(_this, void 0, void 0, function() {
        var isInitWatch, abortWatch, retry;
        var _this2 = this;
        return __generator$m(this, function(_a2) {
          isInitWatch = options2.operationName === "INIT_WATCH";
          abortWatch = function() {
            _this2.closeWithError(new CloudSDKError({
              errCode: isInitWatch ? ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_INIT_WATCH_FAIL : ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_REBUILD_WATCH_FAIL,
              errMsg: e2
            }));
            options2.reject(e2);
          };
          retry = function(refreshLogin) {
            if (_this2.useRetryTicket(options2.operationName)) {
              if (isInitWatch) {
                _this2.initWatchPromise = void 0;
                options2.resolve(_this2.initWatch(refreshLogin));
              } else {
                _this2.rebuildWatchPromise = void 0;
                options2.resolve(_this2.rebuildWatch(refreshLogin));
              }
            } else {
              abortWatch();
            }
          };
          this.handleCommonError(e2, {
            onSignError: function() {
              return retry(true);
            },
            onTimeoutError: function() {
              return retry(false);
            },
            onNotRetryableError: abortWatch,
            onCancelledError: options2.reject,
            onUnknownError: function() {
              (function() {
                return __awaiter$m(_this2, void 0, void 0, function() {
                  var onWSDisconnected;
                  var _this3 = this;
                  return __generator$m(this, function(_a3) {
                    switch (_a3.label) {
                      case 0:
                        _a3.trys.push([0, 8, , 9]);
                        onWSDisconnected = function() {
                          return __awaiter$m(_this3, void 0, void 0, function() {
                            return __generator$m(this, function(_a4) {
                              switch (_a4.label) {
                                case 0:
                                  this.pause();
                                  return [4, this.onceWSConnected()];
                                case 1:
                                  _a4.sent();
                                  retry(true);
                                  return [2];
                              }
                            });
                          });
                        };
                        if (!!this.isWSConnected())
                          return [3, 2];
                        return [4, onWSDisconnected()];
                      case 1:
                        _a3.sent();
                        return [3, 7];
                      case 2:
                        return [4, sleep(DEFAULT_WAIT_TIME_ON_UNKNOWN_ERROR)];
                      case 3:
                        _a3.sent();
                        if (!(this.watchStatus === WatchStatus.PAUSED))
                          return [3, 4];
                        options2.reject(new CancelledError("".concat(options2.operationName, " cancelled due to pause after unknownError")));
                        return [3, 7];
                      case 4:
                        if (!!this.isWSConnected())
                          return [3, 6];
                        return [4, onWSDisconnected()];
                      case 5:
                        _a3.sent();
                        return [3, 7];
                      case 6:
                        retry(false);
                        _a3.label = 7;
                      case 7:
                        return [3, 9];
                      case 8:
                        _a3.sent();
                        retry(true);
                        return [3, 9];
                      case 9:
                        return [2];
                    }
                  });
                });
              })();
            }
          });
          return [2];
        });
      });
    };
    this.closeWatch = function() {
      return __awaiter$m(_this, void 0, void 0, function() {
        var queryId, closeWatchMsg, e_4;
        return __generator$m(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              queryId = this.sessionInfo ? this.sessionInfo.queryID : "";
              if (this.watchStatus !== WatchStatus.ACTIVE) {
                this.watchStatus = WatchStatus.CLOSED;
                this.onWatchClose(this, queryId);
                return [2];
              }
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, 4, 5]);
              this.watchStatus = WatchStatus.CLOSING;
              closeWatchMsg = {
                watchId: this.watchId,
                requestId: genRequestId(),
                msgType: "CLOSE_WATCH",
                msgData: null
              };
              return [4, this.send({
                msg: closeWatchMsg
              })];
            case 2:
              _a2.sent();
              this.sessionInfo = void 0;
              this.watchStatus = WatchStatus.CLOSED;
              return [3, 5];
            case 3:
              e_4 = _a2.sent();
              this.closeWithError(new CloudSDKError({
                errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CLOSE_WATCH_FAIL,
                errMsg: e_4
              }));
              return [3, 5];
            case 4:
              this.onWatchClose(this, queryId);
              return [7];
            case 5:
              return [2];
          }
        });
      });
    };
    this.scheduleSendACK = function() {
      _this.clearACKSchedule();
      _this.ackTimeoutId = setTimeout(function() {
        if (_this.waitExpectedTimeoutId) {
          _this.scheduleSendACK();
        } else {
          _this.sendACK();
        }
      }, DEFAULT_SEND_ACK_DEBOUNCE_TIMEOUT);
    };
    this.clearACKSchedule = function() {
      if (_this.ackTimeoutId) {
        clearTimeout(_this.ackTimeoutId);
      }
    };
    this.sendACK = function() {
      return __awaiter$m(_this, void 0, void 0, function() {
        var ackMsg, e_5, msg;
        return __generator$m(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 2, , 3]);
              if (this.watchStatus !== WatchStatus.ACTIVE) {
                this.scheduleSendACK();
                return [2];
              }
              if (!this.sessionInfo) {
                console.warn("[realtime listener] can not send ack without a successful initWatch (lack of sessionInfo)");
                return [2];
              }
              ackMsg = {
                watchId: this.watchId,
                requestId: genRequestId(),
                msgType: "CHECK_LAST",
                msgData: {
                  queryID: this.sessionInfo.queryID,
                  eventID: this.sessionInfo.currentEventId
                }
              };
              return [4, this.send({
                msg: ackMsg
              })];
            case 1:
              _a2.sent();
              this.scheduleSendACK();
              return [3, 3];
            case 2:
              e_5 = _a2.sent();
              if (isRealtimeErrorMessageError(e_5)) {
                msg = e_5.payload;
                switch (msg.msgData.code) {
                  case "CHECK_LOGIN_FAILED":
                  case "SIGN_EXPIRED_ERROR":
                  case "SIGN_INVALID_ERROR":
                  case "SIGN_PARAM_INVALID": {
                    this.rebuildWatch();
                    return [2];
                  }
                  case "QUERYID_INVALID_ERROR":
                  case "SYS_ERR":
                  case "INVALIID_ENV":
                  case "COLLECTION_PERMISSION_DENIED": {
                    this.closeWithError(new CloudSDKError({
                      errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,
                      errMsg: msg.msgData.code
                    }));
                    return [2];
                  }
                }
              }
              if (this.availableRetries.CHECK_LAST && this.availableRetries.CHECK_LAST > 0) {
                this.availableRetries.CHECK_LAST -= 1;
                this.scheduleSendACK();
              } else {
                this.closeWithError(new CloudSDKError({
                  errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,
                  errMsg: e_5
                }));
              }
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    };
    this.handleCommonError = function(e2, options2) {
      if (isRealtimeErrorMessageError(e2)) {
        var msg = e2.payload;
        switch (msg.msgData.code) {
          case "CHECK_LOGIN_FAILED":
          case "SIGN_EXPIRED_ERROR":
          case "SIGN_INVALID_ERROR":
          case "SIGN_PARAM_INVALID": {
            options2.onSignError(e2);
            return;
          }
          case "QUERYID_INVALID_ERROR":
          case "SYS_ERR":
          case "INVALIID_ENV":
          case "COLLECTION_PERMISSION_DENIED": {
            options2.onNotRetryableError(e2);
            return;
          }
          default: {
            options2.onNotRetryableError(e2);
            return;
          }
        }
      } else if (isTimeoutError(e2)) {
        options2.onTimeoutError(e2);
        return;
      } else if (isCancelledError(e2)) {
        options2.onCancelledError(e2);
        return;
      }
      options2.onUnknownError(e2);
    };
    this.watchId = "watchid_".concat(+/* @__PURE__ */ new Date(), "_").concat(Math.random());
    this.envId = options.envId;
    this.collectionName = options.collectionName;
    this.query = options.query;
    this.limit = options.limit;
    this.orderBy = options.orderBy;
    this.send = options.send;
    this.login = options.login;
    this.isWSConnected = options.isWSConnected;
    this.onceWSConnected = options.onceWSConnected;
    this.getWaitExpectedTimeoutLength = options.getWaitExpectedTimeoutLength;
    this.onWatchStart = options.onWatchStart;
    this.onWatchClose = options.onWatchClose;
    this.debug = options.debug;
    this.availableRetries = {
      INIT_WATCH: DEFAULT_MAX_AUTO_RETRY_ON_ERROR,
      REBUILD_WATCH: DEFAULT_MAX_AUTO_RETRY_ON_ERROR,
      CHECK_LAST: DEFAULT_MAX_SEND_ACK_AUTO_RETRY_ON_ERROR
    };
    this.listener = new RealtimeListener({
      close: function() {
        _this.closeWatch();
      },
      onChange: options.onChange,
      onError: options.onError,
      debug: this.debug,
      virtualClient: this
    });
    this.initWatch();
  }
  VirtualWebSocketClient2.prototype.onMessage = function(msg) {
    var _this = this;
    switch (this.watchStatus) {
      case WatchStatus.PAUSED: {
        if (msg.msgType !== "ERROR") {
          return;
        }
        break;
      }
      case WatchStatus.LOGGINGIN:
      case WatchStatus.INITING:
      case WatchStatus.REBUILDING: {
        console.warn("[realtime listener] internal non-fatal error: unexpected message received while ".concat(this.watchStatus));
        return;
      }
      case WatchStatus.CLOSED: {
        console.warn("[realtime listener] internal non-fatal error: unexpected message received when the watch has closed");
        return;
      }
      case WatchStatus.ERRORED: {
        console.warn("[realtime listener] internal non-fatal error: unexpected message received when the watch has ended with error");
        return;
      }
    }
    if (!this.sessionInfo) {
      console.warn("[realtime listener] internal non-fatal error: sessionInfo not found while message is received.");
      return;
    }
    this.scheduleSendACK();
    switch (msg.msgType) {
      case "NEXT_EVENT": {
        console.warn("nextevent ".concat(msg.msgData.currEvent, " ignored"), msg);
        this.handleServerEvents(msg);
        break;
      }
      case "CHECK_EVENT": {
        if (this.sessionInfo.currentEventId < msg.msgData.currEvent) {
          this.sessionInfo.expectEventId = msg.msgData.currEvent;
          this.clearWaitExpectedEvent();
          this.waitExpectedTimeoutId = setTimeout(function() {
            _this.rebuildWatch();
          }, this.getWaitExpectedTimeoutLength());
          console.log("[realtime] waitExpectedTimeoutLength ".concat(this.getWaitExpectedTimeoutLength()));
        }
        break;
      }
      case "ERROR": {
        this.closeWithError(new CloudSDKError({
          errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_SERVER_ERROR_MSG,
          errMsg: "".concat(msg.msgData.code, " - ").concat(msg.msgData.message)
        }));
        break;
      }
      default: {
        console.warn("[realtime listener] virtual client receive unexpected msg ".concat(msg.msgType, ": "), msg);
        break;
      }
    }
  };
  VirtualWebSocketClient2.prototype.closeWithError = function(error) {
    var _a2;
    this.watchStatus = WatchStatus.ERRORED;
    this.clearACKSchedule();
    this.listener.onError(error);
    this.onWatchClose(this, ((_a2 = this.sessionInfo) === null || _a2 === void 0 ? void 0 : _a2.queryID) || "");
    console.log("[realtime] client closed (".concat(this.collectionName, " ").concat(this.query, ") (watchId ").concat(this.watchId, ")"));
  };
  VirtualWebSocketClient2.prototype.pause = function() {
    this.watchStatus = WatchStatus.PAUSED;
    console.log("[realtime] client paused (".concat(this.collectionName, " ").concat(this.query, ") (watchId ").concat(this.watchId, ")"));
  };
  VirtualWebSocketClient2.prototype.resume = function() {
    return __awaiter$m(this, void 0, void 0, function() {
      var e_6;
      return __generator$m(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            this.watchStatus = WatchStatus.RESUMING;
            console.log("[realtime] client resuming with ".concat(this.sessionInfo ? "REBUILD_WATCH" : "INIT_WATCH", " (").concat(this.collectionName, " ").concat(this.query, ") (").concat(this.watchId, ")"));
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, this.sessionInfo ? this.rebuildWatch() : this.initWatch()];
          case 2:
            _a2.sent();
            console.log("[realtime] client successfully resumed (".concat(this.collectionName, " ").concat(this.query, ") (").concat(this.watchId, ")"));
            return [3, 4];
          case 3:
            e_6 = _a2.sent();
            console.error("[realtime] client resume failed (".concat(this.collectionName, " ").concat(this.query, ") (").concat(this.watchId, ")"), e_6);
            return [3, 4];
          case 4:
            return [2];
        }
      });
    });
  };
  VirtualWebSocketClient2.prototype.useRetryTicket = function(operationName) {
    if (this.availableRetries[operationName] && this.availableRetries[operationName] > 0) {
      this.availableRetries[operationName] -= 1;
      console.log("[realtime] ".concat(operationName, " use a retry ticket, now only ").concat(this.availableRetries[operationName], " retry left"));
      return true;
    }
    return false;
  };
  VirtualWebSocketClient2.prototype.handleServerEvents = function(msg) {
    return __awaiter$m(this, void 0, void 0, function() {
      var e_7;
      return __generator$m(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            this.scheduleSendACK();
            return [4, this.handleServerEventsInternel(msg)];
          case 1:
            _a2.sent();
            this.postHandleServerEventsValidityCheck(msg);
            return [3, 3];
          case 2:
            e_7 = _a2.sent();
            console.error("[realtime listener] internal non-fatal error: handle server events failed with error: ", e_7);
            throw e_7;
          case 3:
            return [2];
        }
      });
    });
  };
  VirtualWebSocketClient2.prototype.handleServerEventsInternel = function(msg) {
    return __awaiter$m(this, void 0, void 0, function() {
      var requestId, events2, msgType, sessionInfo, allChangeEvents, docs, initEncountered, _loop_1, this_1, i, len, state_1;
      return __generator$m(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            requestId = msg.requestId;
            events2 = msg.msgData.events;
            msgType = msg.msgType;
            if (!events2.length || !this.sessionInfo) {
              return [2];
            }
            sessionInfo = this.sessionInfo;
            try {
              allChangeEvents = events2.map(getPublicEvent);
            } catch (e2) {
              this.closeWithError(new CloudSDKError({
                errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_RECEIVE_INVALID_SERVER_DATA,
                errMsg: e2
              }));
              return [2];
            }
            docs = __spreadArray$1([], sessionInfo.currentDocs, true);
            initEncountered = false;
            _loop_1 = function(i2, len2) {
              var change, localDoc, doc_1, _i, _b, fieldPath, err, err, doc, doc, err, ind, ind, docsSnapshot, docChanges, snapshot;
              return __generator$m(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    change = allChangeEvents[i2];
                    if (!(sessionInfo.currentEventId >= change.id))
                      return [3, 1];
                    if (!allChangeEvents[i2 - 1] || change.id > allChangeEvents[i2 - 1].id) {
                      console.warn("[realtime] duplicate event received, cur ".concat(sessionInfo.currentEventId, " but got ").concat(change.id));
                    } else {
                      console.error("[realtime listener] server non-fatal error: events out of order (the latter event's id is smaller than that of the former) (requestId ".concat(requestId, ")"));
                    }
                    return [2, "continue"];
                  case 1:
                    if (!(sessionInfo.currentEventId === change.id - 1))
                      return [3, 2];
                    switch (change.dataType) {
                      case "update": {
                        if (!change.doc) {
                          switch (change.queueType) {
                            case "update":
                            case "dequeue": {
                              localDoc = docs.find(function(doc2) {
                                return doc2._id === change.docId;
                              });
                              if (localDoc) {
                                doc_1 = cloneDeep(localDoc);
                                if (change.updatedFields) {
                                  Object.keys(change.updatedFields).forEach(function(fieldPath2) {
                                    set$1(doc_1, fieldPath2, change.updatedFields[fieldPath2]);
                                  });
                                }
                                if (change.removedFields) {
                                  for (_i = 0, _b = change.removedFields; _i < _b.length; _i++) {
                                    fieldPath = _b[_i];
                                    unset$1(doc_1, fieldPath);
                                  }
                                }
                                change.doc = doc_1;
                              } else {
                                console.error("[realtime listener] internal non-fatal server error: unexpected update dataType event where no doc is associated.");
                              }
                              break;
                            }
                            case "enqueue": {
                              err = new CloudSDKError({
                                errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                                errMsg: 'HandleServerEvents: full doc is not provided with dataType="update" and queueType="enqueue" (requestId '.concat(msg.requestId, ")")
                              });
                              this_1.closeWithError(err);
                              throw err;
                            }
                          }
                        }
                        break;
                      }
                      case "replace": {
                        if (!change.doc) {
                          err = new CloudSDKError({
                            errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                            errMsg: 'HandleServerEvents: full doc is not provided with dataType="replace" (requestId '.concat(msg.requestId, ")")
                          });
                          this_1.closeWithError(err);
                          throw err;
                        }
                        break;
                      }
                      case "remove": {
                        doc = docs.find(function(doc2) {
                          return doc2._id === change.docId;
                        });
                        if (doc) {
                          change.doc = doc;
                        } else {
                          console.error("[realtime listener] internal non-fatal server error: unexpected remove event where no doc is associated.");
                        }
                        break;
                      }
                      case "limit": {
                        if (!change.doc) {
                          switch (change.queueType) {
                            case "dequeue": {
                              doc = docs.find(function(doc2) {
                                return doc2._id === change.docId;
                              });
                              if (doc) {
                                change.doc = doc;
                              } else {
                                console.error("[realtime listener] internal non-fatal server error: unexpected limit dataType event where no doc is associated.");
                              }
                              break;
                            }
                            case "enqueue": {
                              err = new CloudSDKError({
                                errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                                errMsg: 'HandleServerEvents: full doc is not provided with dataType="limit" and queueType="enqueue" (requestId '.concat(msg.requestId, ")")
                              });
                              this_1.closeWithError(err);
                              throw err;
                            }
                          }
                        }
                        break;
                      }
                    }
                    switch (change.queueType) {
                      case "init": {
                        if (!initEncountered) {
                          initEncountered = true;
                          docs = [change.doc];
                        } else {
                          docs.push(change.doc);
                        }
                        break;
                      }
                      case "enqueue": {
                        docs.push(change.doc);
                        break;
                      }
                      case "dequeue": {
                        ind = docs.findIndex(function(doc2) {
                          return doc2._id === change.docId;
                        });
                        if (ind > -1) {
                          docs.splice(ind, 1);
                        } else {
                          console.error("[realtime listener] internal non-fatal server error: unexpected dequeue event where no doc is associated.");
                        }
                        break;
                      }
                      case "update": {
                        ind = docs.findIndex(function(doc2) {
                          return doc2._id === change.docId;
                        });
                        if (ind > -1) {
                          docs[ind] = change.doc;
                        } else {
                          console.error("[realtime listener] internal non-fatal server error: unexpected queueType update event where no doc is associated.");
                        }
                        break;
                      }
                    }
                    if (i2 === len2 - 1 || allChangeEvents[i2 + 1] && allChangeEvents[i2 + 1].id !== change.id) {
                      docsSnapshot = __spreadArray$1([], docs, true);
                      docChanges = allChangeEvents.slice(0, i2 + 1).filter(function(c2) {
                        return c2.id === change.id;
                      });
                      this_1.sessionInfo.currentEventId = change.id;
                      this_1.sessionInfo.currentDocs = docs;
                      snapshot = new Snapshot({
                        id: change.id,
                        docChanges,
                        docs: docsSnapshot,
                        msgType
                      });
                      this_1.listener.onChange(snapshot);
                    }
                    return [3, 4];
                  case 2:
                    console.warn("[realtime listener] event received is out of order, cur ".concat(this_1.sessionInfo.currentEventId, " but got ").concat(change.id));
                    return [4, this_1.rebuildWatch()];
                  case 3:
                    _c.sent();
                    return [2, { value: void 0 }];
                  case 4:
                    return [2];
                }
              });
            };
            this_1 = this;
            i = 0, len = allChangeEvents.length;
            _a2.label = 1;
          case 1:
            if (!(i < len))
              return [3, 4];
            return [5, _loop_1(i, len)];
          case 2:
            state_1 = _a2.sent();
            if (typeof state_1 === "object")
              return [2, state_1.value];
            _a2.label = 3;
          case 3:
            i++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  };
  VirtualWebSocketClient2.prototype.postHandleServerEventsValidityCheck = function(msg) {
    if (!this.sessionInfo) {
      console.error("[realtime listener] internal non-fatal error: sessionInfo lost after server event handling, this should never occur");
      return;
    }
    if (this.sessionInfo.expectEventId && this.sessionInfo.currentEventId >= this.sessionInfo.expectEventId) {
      this.clearWaitExpectedEvent();
    }
    if (this.sessionInfo.currentEventId < msg.msgData.currEvent) {
      console.warn("[realtime listener] internal non-fatal error: client eventId does not match with server event id after server event handling");
      return;
    }
  };
  VirtualWebSocketClient2.prototype.clearWaitExpectedEvent = function() {
    if (this.waitExpectedTimeoutId) {
      clearTimeout(this.waitExpectedTimeoutId);
      this.waitExpectedTimeoutId = void 0;
    }
  };
  return VirtualWebSocketClient2;
}();
function getPublicEvent(event) {
  var e2 = {
    id: event.ID,
    dataType: event.DataType,
    queueType: event.QueueType,
    docId: event.DocID,
    doc: event.Doc && event.Doc !== "{}" ? JSON.parse(event.Doc) : void 0
  };
  if (event.DataType === "update") {
    if (event.UpdatedFields) {
      e2.updatedFields = JSON.parse(event.UpdatedFields);
    }
    if (event.removedFields || event.RemovedFields) {
      e2.removedFields = JSON.parse(event.removedFields);
    }
  }
  return e2;
}
var CLOSE_EVENT_CODE_INFO = {
  1e3: {
    code: 1e3,
    name: "Normal Closure",
    description: "Normal closure; the connection successfully completed whatever purpose for which it was created."
  },
  1001: {
    code: 1001,
    name: "Going Away",
    description: "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection."
  },
  1002: {
    code: 1002,
    name: "Protocol Error",
    description: "The endpoint is terminating the connection due to a protocol error."
  },
  1003: {
    code: 1003,
    name: "Unsupported Data",
    description: "The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data)."
  },
  1005: {
    code: 1005,
    name: "No Status Received",
    description: "Indicates that no status code was provided even though one was expected."
  },
  1006: {
    code: 1006,
    name: "Abnormal Closure",
    description: "Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected."
  },
  1007: {
    code: 1007,
    name: "Invalid frame payload data",
    description: "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message)."
  },
  1008: {
    code: 1008,
    name: "Policy Violation",
    description: "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable."
  },
  1009: {
    code: 1009,
    name: "Message too big",
    description: "The endpoint is terminating the connection because a data frame was received that is too large."
  },
  1010: {
    code: 1010,
    name: "Missing Extension",
    description: "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."
  },
  1011: {
    code: 1011,
    name: "Internal Error",
    description: "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."
  },
  1012: {
    code: 1012,
    name: "Service Restart",
    description: "The server is terminating the connection because it is restarting."
  },
  1013: {
    code: 1013,
    name: "Try Again Later",
    description: "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients."
  },
  1014: {
    code: 1014,
    name: "Bad Gateway",
    description: "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code."
  },
  1015: {
    code: 1015,
    name: "TLS Handshake",
    description: "Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."
  },
  3e3: {
    code: 3e3,
    name: "Reconnect WebSocket",
    description: "The client is terminating the connection because it wants to reconnect"
  },
  3001: {
    code: 3001,
    name: "No Realtime Listeners",
    description: "The client is terminating the connection because no more realtime listeners exist"
  },
  3002: {
    code: 3002,
    name: "Heartbeat Ping Error",
    description: "The client is terminating the connection due to its failure in sending heartbeat messages"
  },
  3003: {
    code: 3003,
    name: "Heartbeat Pong Timeout Error",
    description: "The client is terminating the connection because no heartbeat response is received from the server"
  },
  3050: {
    code: 3050,
    name: "Server Close",
    description: "The client is terminating the connection because no heartbeat response is received from the server"
  }
};
var CloseEventCode;
(function(CloseEventCode2) {
  CloseEventCode2[CloseEventCode2["NormalClosure"] = 1e3] = "NormalClosure";
  CloseEventCode2[CloseEventCode2["GoingAway"] = 1001] = "GoingAway";
  CloseEventCode2[CloseEventCode2["ProtocolError"] = 1002] = "ProtocolError";
  CloseEventCode2[CloseEventCode2["UnsupportedData"] = 1003] = "UnsupportedData";
  CloseEventCode2[CloseEventCode2["NoStatusReceived"] = 1005] = "NoStatusReceived";
  CloseEventCode2[CloseEventCode2["AbnormalClosure"] = 1006] = "AbnormalClosure";
  CloseEventCode2[CloseEventCode2["InvalidFramePayloadData"] = 1007] = "InvalidFramePayloadData";
  CloseEventCode2[CloseEventCode2["PolicyViolation"] = 1008] = "PolicyViolation";
  CloseEventCode2[CloseEventCode2["MessageTooBig"] = 1009] = "MessageTooBig";
  CloseEventCode2[CloseEventCode2["MissingExtension"] = 1010] = "MissingExtension";
  CloseEventCode2[CloseEventCode2["InternalError"] = 1011] = "InternalError";
  CloseEventCode2[CloseEventCode2["ServiceRestart"] = 1012] = "ServiceRestart";
  CloseEventCode2[CloseEventCode2["TryAgainLater"] = 1013] = "TryAgainLater";
  CloseEventCode2[CloseEventCode2["BadGateway"] = 1014] = "BadGateway";
  CloseEventCode2[CloseEventCode2["TLSHandshake"] = 1015] = "TLSHandshake";
  CloseEventCode2[CloseEventCode2["ReconnectWebSocket"] = 3e3] = "ReconnectWebSocket";
  CloseEventCode2[CloseEventCode2["NoRealtimeListeners"] = 3001] = "NoRealtimeListeners";
  CloseEventCode2[CloseEventCode2["HeartbeatPingError"] = 3002] = "HeartbeatPingError";
  CloseEventCode2[CloseEventCode2["HeartbeatPongTimeoutError"] = 3003] = "HeartbeatPongTimeoutError";
  CloseEventCode2[CloseEventCode2["NoAuthentication"] = 3050] = "NoAuthentication";
})(CloseEventCode || (CloseEventCode = {}));
var getWSCloseError = function(code2, reason) {
  var info = CLOSE_EVENT_CODE_INFO[code2];
  var errMsg = !info ? "code ".concat(code2) : "".concat(info.name, ", code ").concat(code2, ", reason ").concat(reason || info.description);
  return new CloudSDKError({
    errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_CLOSED,
    errMsg
  });
};
var wsClass = null;
var runtime = "web";
function getWsClass() {
  return wsClass;
}
function setWsClass(val) {
  wsClass = val;
}
function getRuntime() {
  return runtime;
}
function setRuntime(val) {
  runtime = val;
}
var __assign$n = function() {
  __assign$n = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$n.apply(this, arguments);
};
var __awaiter$l = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$l = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var WS_READY_STATE = {
  CONNECTING: 0,
  OPEN: 1,
  CLOSING: 2,
  CLOSED: 3
};
var MAX_RTT_OBSERVED = 3;
var DEFAULT_EXPECTED_EVENT_WAIT_TIME = 5e3;
var DEFAULT_UNTRUSTED_RTT_THRESHOLD = 1e4;
var DEFAULT_MAX_RECONNECT = 5;
var DEFAULT_WS_RECONNECT_INTERVAL = 1e4;
var DEFAULT_PING_FAIL_TOLERANCE = 2;
var DEFAULT_PONG_MISS_TOLERANCE = 2;
var DEFAULT_LOGIN_TIMEOUT = 5e3;
var RealtimeWebSocketClient = function() {
  function RealtimeWebSocketClient2(options) {
    var _this = this;
    this.virtualWSClient = /* @__PURE__ */ new Set();
    this.queryIdClientMap = /* @__PURE__ */ new Map();
    this.watchIdClientMap = /* @__PURE__ */ new Map();
    this.pingFailed = 0;
    this.pongMissed = 0;
    this.logins = /* @__PURE__ */ new Map();
    this.wsReadySubsribers = [];
    this.wsResponseWait = /* @__PURE__ */ new Map();
    this.rttObserved = [];
    this.send = function(opts) {
      return __awaiter$l(_this, void 0, void 0, function() {
        var _this2 = this;
        return __generator$l(this, function(_a2) {
          return [2, new Promise(function(_resolve, _reject) {
            void function() {
              return __awaiter$l(_this2, void 0, void 0, function() {
                var timeoutId, hasResolved, hasRejected, resolve2, reject, respWaitSpec, err_1, e_1;
                var _this3 = this;
                return __generator$l(this, function(_a3) {
                  switch (_a3.label) {
                    case 0:
                      hasResolved = false;
                      hasRejected = false;
                      resolve2 = function(value) {
                        hasResolved = true;
                        timeoutId && clearTimeout(timeoutId);
                        _resolve(value);
                      };
                      reject = function(error) {
                        hasRejected = true;
                        timeoutId && clearTimeout(timeoutId);
                        _reject(error);
                      };
                      if (opts.timeout) {
                        timeoutId = setTimeout(function() {
                          (function() {
                            return __awaiter$l(_this3, void 0, void 0, function() {
                              return __generator$l(this, function(_a4) {
                                switch (_a4.label) {
                                  case 0:
                                    if (!(!hasResolved || !hasRejected))
                                      return [3, 2];
                                    return [4, sleep(0)];
                                  case 1:
                                    _a4.sent();
                                    if (!hasResolved || !hasRejected) {
                                      reject(new TimeoutError("wsclient.send timedout"));
                                    }
                                    _a4.label = 2;
                                  case 2:
                                    return [2];
                                }
                              });
                            });
                          })();
                        }, opts.timeout);
                      }
                      _a3.label = 1;
                    case 1:
                      _a3.trys.push([1, 8, , 9]);
                      if (!(this.wsInitPromise !== void 0 || this.wsInitPromise !== null))
                        return [3, 3];
                      return [4, this.wsInitPromise];
                    case 2:
                      _a3.sent();
                      _a3.label = 3;
                    case 3:
                      if (!this.ws) {
                        reject(new Error("invalid state: ws connection not exists, can not send message"));
                        return [2];
                      }
                      if (this.ws.readyState !== WS_READY_STATE.OPEN) {
                        reject(new Error("ws readyState invalid: ".concat(this.ws.readyState, ", can not send message")));
                        return [2];
                      }
                      if (opts.waitResponse) {
                        respWaitSpec = {
                          resolve: resolve2,
                          reject,
                          skipOnMessage: opts.skipOnMessage
                        };
                        this.wsResponseWait.set(opts.msg.requestId, respWaitSpec);
                      }
                      _a3.label = 4;
                    case 4:
                      _a3.trys.push([4, 6, , 7]);
                      return [4, this.ws.send(JSON.stringify(opts.msg))];
                    case 5:
                      _a3.sent();
                      if (!opts.waitResponse) {
                        resolve2(void 0);
                      }
                      return [3, 7];
                    case 6:
                      err_1 = _a3.sent();
                      if (err_1) {
                        reject(err_1);
                        if (opts.waitResponse) {
                          this.wsResponseWait.delete(opts.msg.requestId);
                        }
                      }
                      return [3, 7];
                    case 7:
                      return [3, 9];
                    case 8:
                      e_1 = _a3.sent();
                      reject(e_1);
                      return [3, 9];
                    case 9:
                      return [2];
                  }
                });
              });
            }();
          })];
        });
      });
    };
    this.closeAllClients = function(error) {
      _this.virtualWSClient.forEach(function(client) {
        client.closeWithError(error);
      });
    };
    this.pauseClients = function(clients) {
      (clients || _this.virtualWSClient).forEach(function(client) {
        client.pause();
      });
    };
    this.resumeClients = function(clients) {
      (clients || _this.virtualWSClient).forEach(function(client) {
        client.resume();
      });
    };
    this.initWebSocketConnection = function(reconnect, availableRetries) {
      if (availableRetries === void 0) {
        availableRetries = _this.maxReconnect;
      }
      return __awaiter$l(_this, void 0, void 0, function() {
        var _this2 = this;
        return __generator$l(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (reconnect && this.reconnectState) {
                return [2];
              }
              if (reconnect) {
                this.reconnectState = true;
              }
              if (this.wsInitPromise !== void 0 && this.wsInitPromise !== null) {
                return [2, this.wsInitPromise];
              }
              if (reconnect) {
                this.pauseClients();
              }
              this.close(CloseEventCode.ReconnectWebSocket);
              this.wsInitPromise = new Promise(function(resolve2, reject) {
                (function() {
                  return __awaiter$l(_this2, void 0, void 0, function() {
                    var wsSign_1, e_3, isConnected;
                    var _this3 = this;
                    return __generator$l(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          _a3.trys.push([0, 6, , 11]);
                          return [4, this.getWsSign()];
                        case 1:
                          wsSign_1 = _a3.sent();
                          return [4, new Promise(function(success) {
                            var url = wsSign_1.wsUrl || "wss://tcb-ws.tencentcloudapi.com";
                            var wsClass2 = getWsClass();
                            _this3.ws = wsClass2 ? new wsClass2(url) : new WebSocket(url);
                            success(void 0);
                          })];
                        case 2:
                          _a3.sent();
                          if (!this.ws.connect)
                            return [3, 4];
                          return [4, this.ws.connect()];
                        case 3:
                          _a3.sent();
                          _a3.label = 4;
                        case 4:
                          return [4, this.initWebSocketEvent()];
                        case 5:
                          _a3.sent();
                          resolve2();
                          if (reconnect) {
                            this.resumeClients();
                            this.reconnectState = false;
                          }
                          return [3, 11];
                        case 6:
                          e_3 = _a3.sent();
                          console.error("[realtime] initWebSocketConnection connect fail", e_3);
                          if (!(availableRetries > 0))
                            return [3, 9];
                          isConnected = true;
                          this.wsInitPromise = void 0;
                          if (!isConnected)
                            return [3, 8];
                          return [4, sleep(this.reconnectInterval)];
                        case 7:
                          _a3.sent();
                          if (reconnect) {
                            this.reconnectState = false;
                          }
                          _a3.label = 8;
                        case 8:
                          resolve2(this.initWebSocketConnection(reconnect, availableRetries - 1));
                          return [3, 10];
                        case 9:
                          reject(e_3);
                          if (reconnect) {
                            this.closeAllClients(new CloudSDKError({
                              errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_RECONNECT_WATCH_FAIL,
                              errMsg: e_3
                            }));
                          }
                          _a3.label = 10;
                        case 10:
                          return [3, 11];
                        case 11:
                          return [2];
                      }
                    });
                  });
                })();
              });
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, 4, 5]);
              return [4, this.wsInitPromise];
            case 2:
              _a2.sent();
              this.wsReadySubsribers.forEach(function(_a3) {
                var resolve2 = _a3.resolve;
                return resolve2();
              });
              return [3, 5];
            case 3:
              _a2.sent();
              this.wsReadySubsribers.forEach(function(_a3) {
                var reject = _a3.reject;
                return reject();
              });
              return [3, 5];
            case 4:
              this.wsInitPromise = void 0;
              this.wsReadySubsribers = [];
              return [7];
            case 5:
              return [2];
          }
        });
      });
    };
    this.initWebSocketEvent = function() {
      return new Promise(function(resolve2, reject) {
        if (!_this.ws) {
          throw new Error("can not initWebSocketEvent, ws not exists");
        }
        var wsOpened = false;
        _this.ws.onopen = function(event) {
          console.warn("[realtime] ws event: open", event);
          wsOpened = true;
          resolve2();
        };
        _this.ws.onerror = function(event) {
          _this.logins = /* @__PURE__ */ new Map();
          if (!wsOpened) {
            console.error("[realtime] ws open failed with ws event: error", event);
            reject(event);
          } else {
            console.error("[realtime] ws event: error", event);
            _this.clearHeartbeat();
            _this.virtualWSClient.forEach(function(client) {
              return client.closeWithError(new CloudSDKError({
                errCode: ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_ERROR,
                errMsg: event
              }));
            });
          }
        };
        _this.ws.onclose = function(closeEvent) {
          console.warn("[realtime] ws event: close", closeEvent);
          _this.logins = /* @__PURE__ */ new Map();
          _this.clearHeartbeat();
          switch (closeEvent.code) {
            case CloseEventCode.ReconnectWebSocket: {
              break;
            }
            case CloseEventCode.NoRealtimeListeners: {
              break;
            }
            case CloseEventCode.HeartbeatPingError:
            case CloseEventCode.HeartbeatPongTimeoutError:
            case CloseEventCode.NormalClosure:
            case CloseEventCode.AbnormalClosure: {
              if (_this.maxReconnect > 0) {
                _this.initWebSocketConnection(true, _this.maxReconnect);
              } else {
                _this.closeAllClients(getWSCloseError(closeEvent.code));
              }
              break;
            }
            case CloseEventCode.NoAuthentication: {
              _this.closeAllClients(getWSCloseError(closeEvent.code, closeEvent.reason));
              break;
            }
            default: {
              if (_this.maxReconnect > 0) {
                _this.initWebSocketConnection(true, _this.maxReconnect);
              } else {
                _this.closeAllClients(getWSCloseError(closeEvent.code));
              }
            }
          }
        };
        _this.ws.onmessage = function(res) {
          var rawMsg = res.data;
          _this.heartbeat();
          var msg;
          try {
            msg = JSON.parse(rawMsg);
          } catch (e2) {
            throw new Error("[realtime] onMessage parse res.data error: ".concat(e2));
          }
          if (msg.msgType === "ERROR") {
            var virtualWatch_1 = null;
            _this.virtualWSClient.forEach(function(item) {
              if (item.watchId === msg.watchId) {
                virtualWatch_1 = item;
              }
            });
            if (virtualWatch_1) {
              virtualWatch_1.listener.onError(msg);
            }
          }
          var responseWaitSpec = _this.wsResponseWait.get(msg.requestId);
          if (responseWaitSpec) {
            try {
              if (msg.msgType === "ERROR") {
                responseWaitSpec.reject(new RealtimeErrorMessageError(msg));
              } else {
                responseWaitSpec.resolve(msg);
              }
            } catch (e2) {
              console.error("ws onMessage responseWaitSpec.resolve(msg) errored:", e2);
            } finally {
              _this.wsResponseWait.delete(msg.requestId);
            }
            if (responseWaitSpec.skipOnMessage) {
              return;
            }
          }
          if (msg.msgType === "PONG") {
            if (_this.lastPingSendTS) {
              var rtt = Date.now() - _this.lastPingSendTS;
              if (rtt > DEFAULT_UNTRUSTED_RTT_THRESHOLD) {
                console.warn("[realtime] untrusted rtt observed: ".concat(rtt));
                return;
              }
              if (_this.rttObserved.length >= MAX_RTT_OBSERVED) {
                _this.rttObserved.splice(0, _this.rttObserved.length - MAX_RTT_OBSERVED + 1);
              }
              _this.rttObserved.push(rtt);
            }
            return;
          }
          var client = msg.watchId && _this.watchIdClientMap.get(msg.watchId);
          if (client) {
            client.onMessage(msg);
          } else {
            console.error("[realtime] no realtime listener found responsible for watchId ".concat(msg.watchId, ": "), msg);
            switch (msg.msgType) {
              case "INIT_EVENT":
              case "NEXT_EVENT":
              case "CHECK_EVENT": {
                client = _this.queryIdClientMap.get(msg.msgData.queryID);
                if (client) {
                  client.onMessage(msg);
                }
                break;
              }
              default: {
                for (var _i = 0, _a2 = Array.from(_this.watchIdClientMap.entries()); _i < _a2.length; _i++) {
                  var _b = _a2[_i], client_1 = _b[1];
                  client_1.onMessage(msg);
                  break;
                }
              }
            }
          }
        };
        _this.heartbeat();
      });
    };
    this.isWSConnected = function() {
      return Boolean(_this.ws && _this.ws.readyState === WS_READY_STATE.OPEN);
    };
    this.onceWSConnected = function() {
      return __awaiter$l(_this, void 0, void 0, function() {
        var _this2 = this;
        return __generator$l(this, function(_a2) {
          if (this.isWSConnected()) {
            return [2];
          }
          if (this.wsInitPromise !== null && this.wsInitPromise !== void 0) {
            return [2, this.wsInitPromise];
          }
          return [2, new Promise(function(resolve2, reject) {
            _this2.wsReadySubsribers.push({
              resolve: resolve2,
              reject
            });
          })];
        });
      });
    };
    this.webLogin = function(envId, refresh) {
      return __awaiter$l(_this, void 0, void 0, function() {
        var loginInfo_1, emptyEnvLoginInfo, promise, loginInfo, loginStartTS, loginResult, curLoginInfo, e_4;
        var _this2 = this;
        return __generator$l(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!refresh) {
                if (envId) {
                  loginInfo_1 = this.logins.get(envId);
                  if (loginInfo_1) {
                    if (loginInfo_1.loggedIn && loginInfo_1.loginResult) {
                      return [2, loginInfo_1.loginResult];
                    }
                    if (loginInfo_1.loggingInPromise !== null && loginInfo_1.loggingInPromise !== void 0) {
                      return [2, loginInfo_1.loggingInPromise];
                    }
                  }
                } else {
                  emptyEnvLoginInfo = this.logins.get("");
                  if ((emptyEnvLoginInfo === null || emptyEnvLoginInfo === void 0 ? void 0 : emptyEnvLoginInfo.loggingInPromise) !== null && (emptyEnvLoginInfo === null || emptyEnvLoginInfo === void 0 ? void 0 : emptyEnvLoginInfo.loggingInPromise) !== void 0) {
                    return [2, emptyEnvLoginInfo.loggingInPromise];
                  }
                }
              }
              promise = new Promise(function(resolve2, reject) {
                (function() {
                  return __awaiter$l(_this2, void 0, void 0, function() {
                    var wsSign, msgData, loginMsg, loginResMsg, e_5;
                    return __generator$l(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          _a3.trys.push([0, 3, , 4]);
                          return [4, this.getWsSign()];
                        case 1:
                          wsSign = _a3.sent();
                          msgData = {
                            envId: wsSign.envId || "",
                            accessToken: "",
                            referrer: "web",
                            sdkVersion: "",
                            dataVersion: ""
                          };
                          loginMsg = {
                            watchId: void 0,
                            requestId: genRequestId(),
                            msgType: "LOGIN",
                            msgData,
                            exMsgData: {
                              runtime: getRuntime(),
                              signStr: wsSign.signStr,
                              secretVersion: wsSign.secretVersion
                            }
                          };
                          return [4, this.send({
                            msg: loginMsg,
                            waitResponse: true,
                            skipOnMessage: true,
                            timeout: DEFAULT_LOGIN_TIMEOUT
                          })];
                        case 2:
                          loginResMsg = _a3.sent();
                          if (!loginResMsg.msgData.code) {
                            resolve2({
                              envId: wsSign.envId
                            });
                          } else {
                            reject(new Error("".concat(loginResMsg.msgData.code, " ").concat(loginResMsg.msgData.message)));
                          }
                          return [3, 4];
                        case 3:
                          e_5 = _a3.sent();
                          reject(e_5);
                          return [3, 4];
                        case 4:
                          return [2];
                      }
                    });
                  });
                })();
              });
              loginInfo = envId && this.logins.get(envId);
              loginStartTS = Date.now();
              if (loginInfo) {
                loginInfo.loggedIn = false;
                loginInfo.loggingInPromise = promise;
                loginInfo.loginStartTS = loginStartTS;
              } else {
                loginInfo = {
                  loggedIn: false,
                  loggingInPromise: promise,
                  loginStartTS
                };
                this.logins.set(envId || "", loginInfo);
              }
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, , 4]);
              return [4, promise];
            case 2:
              loginResult = _a2.sent();
              curLoginInfo = envId && this.logins.get(envId);
              if (curLoginInfo && curLoginInfo === loginInfo && curLoginInfo.loginStartTS === loginStartTS) {
                loginInfo.loggedIn = true;
                loginInfo.loggingInPromise = void 0;
                loginInfo.loginStartTS = void 0;
                loginInfo.loginResult = loginResult;
                return [2, loginResult];
              }
              if (curLoginInfo) {
                if (curLoginInfo.loggedIn && curLoginInfo.loginResult) {
                  return [2, curLoginInfo.loginResult];
                }
                if (curLoginInfo.loggingInPromise !== null && curLoginInfo.loggingInPromise !== void 0) {
                  return [2, curLoginInfo.loggingInPromise];
                }
                throw new Error("ws unexpected login info");
              } else {
                throw new Error("ws login info reset");
              }
            case 3:
              e_4 = _a2.sent();
              loginInfo.loggedIn = false;
              loginInfo.loggingInPromise = void 0;
              loginInfo.loginStartTS = void 0;
              loginInfo.loginResult = void 0;
              throw e_4;
            case 4:
              return [2];
          }
        });
      });
    };
    this.getWsSign = function() {
      return __awaiter$l(_this, void 0, void 0, function() {
        var expiredTs, res, _a2, signStr, wsUrl, secretVersion, envId;
        return __generator$l(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (this.wsSign && this.wsSign.expiredTs > Date.now()) {
                return [2, this.wsSign];
              }
              expiredTs = Date.now() + 6e4;
              return [4, this.context.appConfig.request.send("auth.wsWebSign", { runtime: getRuntime() })];
            case 1:
              res = _b.sent();
              if (res.code) {
                throw new Error("[tcb-js-sdk] 获取实时数据推送登录票据失败: ".concat(res.code));
              }
              if (res.data) {
                _a2 = res.data, signStr = _a2.signStr, wsUrl = _a2.wsUrl, secretVersion = _a2.secretVersion, envId = _a2.envId;
                return [2, {
                  signStr,
                  wsUrl,
                  secretVersion,
                  envId,
                  expiredTs
                }];
              }
              throw new Error("[tcb-js-sdk] 获取实时数据推送登录票据失败");
          }
        });
      });
    };
    this.getWaitExpectedTimeoutLength = function() {
      if (!_this.rttObserved.length) {
        return DEFAULT_EXPECTED_EVENT_WAIT_TIME;
      }
      return _this.rttObserved.reduce(function(acc, cur) {
        return acc + cur;
      }) / _this.rttObserved.length * 1.5;
    };
    this.ping = function() {
      return __awaiter$l(_this, void 0, void 0, function() {
        var msg;
        return __generator$l(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              msg = {
                watchId: void 0,
                requestId: genRequestId(),
                msgType: "PING",
                msgData: null
              };
              return [4, this.send({
                msg
              })];
            case 1:
              _a2.sent();
              return [2];
          }
        });
      });
    };
    this.onWatchStart = function(client, queryID) {
      _this.queryIdClientMap.set(queryID, client);
    };
    this.onWatchClose = function(client, queryID) {
      if (queryID) {
        _this.queryIdClientMap.delete(queryID);
      }
      _this.watchIdClientMap.delete(client.watchId);
      _this.virtualWSClient.delete(client);
      if (!_this.virtualWSClient.size) {
        _this.close(CloseEventCode.NoRealtimeListeners);
      }
    };
    this.maxReconnect = options.maxReconnect || DEFAULT_MAX_RECONNECT;
    this.reconnectInterval = options.reconnectInterval || DEFAULT_WS_RECONNECT_INTERVAL;
    this.context = options.context;
  }
  RealtimeWebSocketClient2.prototype.clearHeartbeat = function() {
    this.pingTimeoutId && clearTimeout(this.pingTimeoutId);
    this.pongTimeoutId && clearTimeout(this.pongTimeoutId);
  };
  RealtimeWebSocketClient2.prototype.close = function(code2) {
    this.clearHeartbeat();
    if (this.ws) {
      this.ws.close(code2, CLOSE_EVENT_CODE_INFO[code2].name);
      this.ws = void 0;
    }
  };
  RealtimeWebSocketClient2.prototype.watch = function(options) {
    if (!this.ws && (this.wsInitPromise === void 0 || this.wsInitPromise === null)) {
      this.initWebSocketConnection(false);
    }
    var virtualClient = new VirtualWebSocketClient(__assign$n(__assign$n({}, options), { send: this.send, login: this.webLogin, isWSConnected: this.isWSConnected, onceWSConnected: this.onceWSConnected, getWaitExpectedTimeoutLength: this.getWaitExpectedTimeoutLength, onWatchStart: this.onWatchStart, onWatchClose: this.onWatchClose, debug: true }));
    this.virtualWSClient.add(virtualClient);
    this.watchIdClientMap.set(virtualClient.watchId, virtualClient);
    return virtualClient.listener;
  };
  RealtimeWebSocketClient2.prototype.heartbeat = function(immediate) {
    var _this = this;
    this.clearHeartbeat();
    this.pingTimeoutId = setTimeout(function() {
      (function() {
        return __awaiter$l(_this, void 0, void 0, function() {
          var _this2 = this;
          return __generator$l(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 3]);
                if (!this.ws || this.ws.readyState !== WS_READY_STATE.OPEN) {
                  return [2];
                }
                this.lastPingSendTS = Date.now();
                return [4, this.ping()];
              case 1:
                _a2.sent();
                this.pingFailed = 0;
                this.pongTimeoutId = setTimeout(function() {
                  console.error("pong timed out");
                  if (_this2.pongMissed < DEFAULT_PONG_MISS_TOLERANCE) {
                    _this2.pongMissed += 1;
                    _this2.heartbeat(true);
                  } else {
                    _this2.initWebSocketConnection(true);
                  }
                }, this.context.appConfig.realtimePongWaitTimeout);
                return [3, 3];
              case 2:
                _a2.sent();
                if (this.pingFailed < DEFAULT_PING_FAIL_TOLERANCE) {
                  this.pingFailed += 1;
                  this.heartbeat();
                } else {
                  this.close(CloseEventCode.HeartbeatPingError);
                }
                return [3, 3];
              case 3:
                return [2];
            }
          });
        });
      })();
    }, immediate ? 0 : this.context.appConfig.realtimePingInterval);
  };
  return RealtimeWebSocketClient2;
}();
var hook = {
  target: "database",
  entity: function() {
    var _a2 = this.platform, adapter2 = _a2.adapter, runtime2 = _a2.runtime;
    setWsClass(adapter2.wsClass);
    setRuntime(runtime2);
  }
};
var component$4 = {
  name: "realtime",
  IIFE: true,
  entity: function() {
    this.prototype.wsClientClass = RealtimeWebSocketClient;
  }
};
try {
  cloudbase.registerComponent(component$4);
  cloudbase.registerHook(hook);
} catch (e2) {
}
function registerRealtime(app) {
  try {
    app.registerComponent(component$4);
    app.registerHook(hook);
  } catch (e2) {
    console.warn(e2);
  }
}
var __decorate = function(decorators2, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators2, target, key, desc);
  else
    for (var i = decorators2.length - 1; i >= 0; i--)
      if (d2 = decorators2[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata = function(k2, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k2, v2);
};
var __awaiter$k = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$k = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var ERRORS$1 = ERRORS$8, COMMUNITY_SITE_URL = COMMUNITY_SITE_URL$4;
var catchErrorsDecorator = catchErrorsDecorator$5;
var COMPONENT_NAME$3 = "analytics";
var reportTypes = ["mall"];
function validateAnalyticsData(data) {
  if (Object.prototype.toString.call(data).slice(8, -1) !== "Object") {
    return false;
  }
  var reportData = data.report_data, reportType = data.report_type;
  if (reportTypes.includes(reportType) === false) {
    return false;
  }
  if (Object.prototype.toString.call(reportData).slice(8, -1) !== "Object") {
    return false;
  }
  if (reportData.action_time !== void 0 && !Number.isInteger(reportData.action_time)) {
    return false;
  }
  if (typeof reportData.action_type !== "string") {
    return false;
  }
  return true;
}
var CloudbaseAnalytics = function() {
  function CloudbaseAnalytics2() {
  }
  CloudbaseAnalytics2.prototype.analytics = function(requestData) {
    return __awaiter$k(this, void 0, void 0, function() {
      var action, actionTime, transformData2, params, request;
      return __generator$k(this, function(_a2) {
        if (!validateAnalyticsData(requestData)) {
          throw new Error(JSON.stringify({
            code: ERRORS$1.INVALID_PARAMS,
            msg: "[".concat(COMPONENT_NAME$3, ".analytics] invalid report data")
          }));
        }
        action = "analytics.report";
        actionTime = requestData.report_data.action_time === void 0 ? Math.floor(Date.now() / 1e3) : requestData.report_data.action_time;
        transformData2 = {
          analytics_scene: requestData.report_type,
          analytics_data: Object.assign({}, requestData.report_data, {
            action_time: actionTime
          })
        };
        params = {
          requestData: transformData2
        };
        request = this.request;
        request.send(action, params);
        return [2];
      });
    });
  };
  __decorate([
    catchErrorsDecorator({
      customInfo: {
        className: "Cloudbase",
        methodName: "analytics"
      },
      title: "上报调用失败",
      messages: [
        "请确认以下各项：",
        "  1 - 调用 analytics() 的语法或参数是否正确",
        "如果问题依然存在，建议到官方问答社区提问或寻找帮助：".concat(COMMUNITY_SITE_URL)
      ]
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
  ], CloudbaseAnalytics2.prototype, "analytics", null);
  return CloudbaseAnalytics2;
}();
var cloudbaseAnalytics = new CloudbaseAnalytics();
var component$3 = {
  name: COMPONENT_NAME$3,
  entity: {
    analytics: cloudbaseAnalytics.analytics
  }
};
try {
  cloudbase.registerComponent(component$3);
} catch (e2) {
}
function registerAnalytics(app) {
  try {
    app.registerComponent(component$3);
  } catch (e2) {
    console.warn(e2);
  }
}
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$1(d2, b2);
};
function __extends$6(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$m = function() {
  __assign$m = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$m.apply(this, arguments);
};
function __awaiter$j(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator$j(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var WxCloudSDKError = (
  /** @class */
  function(_super) {
    __extends$6(WxCloudSDKError2, _super);
    function WxCloudSDKError2(message, extra) {
      var _this = _super.call(this, message) || this;
      _this.name = "WxCloudSDKError";
      _this.code = extra === null || extra === void 0 ? void 0 : extra.code;
      _this.requestId = extra === null || extra === void 0 ? void 0 : extra.requestId;
      _this.originError = extra === null || extra === void 0 ? void 0 : extra.originError;
      return _this;
    }
    return WxCloudSDKError2;
  }(Error)
);
function getGlobalObj() {
  return typeof window !== "undefined" && window || typeof globalThis !== "undefined" && globalThis;
}
function getReferrer() {
  try {
    var globalObj = getGlobalObj();
    if (!globalObj)
      return;
    if (typeof wx$1 === "undefined") {
      return getGlobalObj().location.href;
    }
    return globalObj.__wxRoute;
  } catch (_a2) {
  }
}
function getUserAgent() {
  var globalObj = getGlobalObj();
  if (globalObj === null || globalObj === void 0 ? void 0 : globalObj.navigator)
    return globalObj.navigator.userAgent;
  if (typeof wx$1 !== "undefined" && wx$1.getSystemInfo) {
    var ua_1;
    wx$1.getSystemInfo({
      success: function(res) {
        if (!res)
          return;
        ua_1 = ["brand", "model", "version", "system", "platform", "SDKVersion", "language"].map(function(k2) {
          return "".concat(k2, ": ").concat(res[k2]);
        }).join(", ");
      }
    });
    return ua_1;
  }
}
var VERSION = "1.4.0";
var callDataSource = function(_a2) {
  var dataSourceName = _a2.dataSourceName, methodName = _a2.methodName, params = _a2.params, realMethodName = _a2.realMethodName, callFunction = _a2.callFunction, _b = _a2.envType, envType = _b === void 0 ? "prod" : _b, mode = _a2.mode;
  return __awaiter$j(void 0, void 0, void 0, function() {
    var result, response, requestId, error_1;
    var _c, _d;
    return __generator$j(this, function(_e2) {
      switch (_e2.label) {
        case 0:
          result = {
            data: {},
            requestId: ""
          };
          _e2.label = 1;
        case 1:
          _e2.trys.push([1, 3, , 4]);
          return [4, callFunction({
            name: "lowcode-datasource",
            data: {
              dataSourceName,
              methodName,
              params,
              userAgent: getUserAgent(),
              referrer: getReferrer(),
              "x-sdk-version": VERSION,
              /**
               * todo 移除此字段
               */
              envType,
              mode
            }
          })];
        case 2:
          response = _e2.sent();
          requestId = ((_c = response === null || response === void 0 ? void 0 : response.result) === null || _c === void 0 ? void 0 : _c.requestId) || (response === null || response === void 0 ? void 0 : response.requestId) || (response === null || response === void 0 ? void 0 : response.requestID);
          if (response === null || response === void 0 ? void 0 : response.result.code) {
            throw new WxCloudSDKError("【错误】".concat(response === null || response === void 0 ? void 0 : response.result.message, "\n【操作】调用 models.").concat(dataSourceName ? "".concat(dataSourceName, ".") : "").concat(realMethodName, "\n【错误码】").concat(response === null || response === void 0 ? void 0 : response.result.code, "\n【请求ID】").concat(requestId || "N/A"), {
              code: response === null || response === void 0 ? void 0 : response.result.code,
              requestId
            });
          } else {
            result.data = ((_d = response === null || response === void 0 ? void 0 : response.result) === null || _d === void 0 ? void 0 : _d.data) || {};
            result.requestId = requestId;
          }
          return [3, 4];
        case 3:
          error_1 = _e2.sent();
          if (error_1.name === "WxCloudSDKError") {
            throw error_1;
          } else {
            console.log(error_1);
            throw new WxCloudSDKError("【错误】".concat(error_1.message, "\n      【操作】调用 models.").concat(dataSourceName ? "".concat(dataSourceName, ".") : "").concat(realMethodName, "\n      【请求ID】N/A"), {
              code: "UnknownError",
              originError: error_1
            });
          }
        case 4:
          return [2, result];
      }
    });
  });
};
var runMysqlCommand = function(_a2) {
  var sql = _a2.sql, params = _a2.params, config = _a2.config, callFunction = _a2.callFunction, _b = _a2.unsafe, unsafe = _b === void 0 ? false : _b;
  return __awaiter$j(void 0, void 0, void 0, function() {
    return __generator$j(this, function(_c) {
      return [2, callDataSource({
        realMethodName: "$runSQL",
        methodName: "callWedaApi",
        params: {
          action: "RunMysqlCommand",
          data: {
            sqlTemplate: sql,
            config,
            parameter: unsafe ? "" : Object.entries(params || {}).reduce(function(list, _a3) {
              var key = _a3[0], value = _a3[1];
              if (value !== void 0) {
                var type = "OBJECT";
                var typeofValue = typeof value;
                switch (typeofValue) {
                  case "boolean": {
                    type = "BOOLEAN";
                    break;
                  }
                  case "number": {
                    type = "NUMBER";
                    break;
                  }
                  case "string": {
                    type = "STRING";
                    break;
                  }
                  default: {
                    if (Array.isArray(value)) {
                      type = "ARRAY";
                    } else {
                      type = "OBJECT";
                    }
                  }
                }
                list.push({
                  key,
                  type,
                  value: type === "STRING" ? value : JSON.stringify(value)
                });
              }
              return list;
            }, []) || []
          }
        },
        callFunction,
        mode: "sdk"
      })];
    });
  });
};
var createRawQueryClient = function(callFunction) {
  return {
    $runSQL: function(sql, params, config) {
      return __awaiter$j(this, void 0, void 0, function() {
        var res;
        return __generator$j(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, runMysqlCommand({
                sql,
                params,
                config: __assign$m(__assign$m({}, config), { preparedStatements: true }),
                callFunction
              })];
            case 1:
              res = _a2.sent();
              return [2, res];
          }
        });
      });
    },
    $runSQLRaw: function(sql, config) {
      return __awaiter$j(this, void 0, void 0, function() {
        var res;
        return __generator$j(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, runMysqlCommand({
                sql,
                params: [],
                config: __assign$m(__assign$m({}, config), { preparedStatements: false }),
                callFunction
              })];
            case 1:
              res = _a2.sent();
              return [2, res];
          }
        });
      });
    }
  };
};
var READ_DEFAULT_PARAMS = {
  filter: {
    where: {}
  },
  select: {
    $master: true
  }
};
function createDefaultMethod(methodName) {
  return {
    getUrl: function(modelName) {
      return "".concat(modelName, "/").concat(methodName);
    },
    method: "post"
  };
}
var HTTP_DATA_MODEL_METHODS = {
  get: __assign$m(__assign$m({}, createDefaultMethod("get")), { defaultParams: __assign$m({}, READ_DEFAULT_PARAMS) }),
  list: __assign$m(__assign$m({}, createDefaultMethod("list")), { defaultParams: __assign$m({}, READ_DEFAULT_PARAMS) }),
  create: createDefaultMethod("create"),
  createMany: createDefaultMethod("createMany"),
  update: __assign$m(__assign$m({}, createDefaultMethod("update")), { method: "put" }),
  updateMany: __assign$m(__assign$m({}, createDefaultMethod("updateMany")), { method: "put" }),
  upsert: createDefaultMethod("upsert"),
  "delete": createDefaultMethod("delete"),
  deleteMany: createDefaultMethod("deleteMany")
};
var UNKNOWN_ERROR_MESSAGE = "Unknown error occurred";
var NOT_SUPPORTED_CODE = "NotSupported";
var generateHTTPClient = function(callFunction, fetch2, baseUrl) {
  var rawQueryClient = createRawQueryClient(callFunction);
  return new Proxy({}, {
    get: function(_2, modelName) {
      if (typeof modelName !== "string")
        return void 0;
      if (Object.prototype.hasOwnProperty.call(rawQueryClient, modelName)) {
        return rawQueryClient[modelName];
      }
      return generateHTTPClientByDataSourceName(baseUrl, modelName, fetch2);
    }
  });
};
var createWxCloudSDKError = function(message, modelName, methodName, code2, requestId) {
  return new WxCloudSDKError("【错误】".concat(message, "\n【操作】调用 models.").concat(modelName, ".").concat(methodName, "\n【错误码】").concat(code2, "\n【请求ID】").concat(requestId), {
    code: code2,
    requestId
  });
};
var generateHTTPClientByDataSourceName = function(baseUrl, modelName, fetch2) {
  var client = new Proxy({}, {
    get: function(_2, methodName) {
      var httpDataModelMethod = HTTP_DATA_MODEL_METHODS[methodName];
      if (!httpDataModelMethod) {
        var error = new Error("不支持的操作: ".concat(methodName));
        throw new WxCloudSDKError(error.message || UNKNOWN_ERROR_MESSAGE, {
          originError: error,
          code: NOT_SUPPORTED_CODE,
          requestId: "N/A"
        });
      }
      return function(params) {
        if (params === void 0) {
          params = {};
        }
        return __awaiter$j(void 0, void 0, void 0, function() {
          var getUrl, method, _a2, defaultParams, effectiveParams, envType, url, result, error_1;
          var _b;
          return __generator$j(this, function(_c) {
            switch (_c.label) {
              case 0:
                getUrl = httpDataModelMethod.getUrl, method = httpDataModelMethod.method, _a2 = httpDataModelMethod.defaultParams, defaultParams = _a2 === void 0 ? {} : _a2;
                effectiveParams = Object.assign({}, defaultParams, params);
                envType = effectiveParams.envType === "pre" ? "pre" : "prod";
                url = [baseUrl, envType, getUrl(modelName)].join("/");
                _c.label = 1;
              case 1:
                _c.trys.push([1, 3, , 4]);
                return [4, fetch2({
                  url,
                  body: JSON.stringify(effectiveParams),
                  method
                })];
              case 2:
                result = _c.sent();
                if (result.code) {
                  throw createWxCloudSDKError(result === null || result === void 0 ? void 0 : result.message, modelName, methodName, result === null || result === void 0 ? void 0 : result.code, result === null || result === void 0 ? void 0 : result.requestId);
                }
                if (methodName === "get") {
                  Object.assign(result, { data: (_b = result.data.record) !== null && _b !== void 0 ? _b : result.data });
                }
                return [2, result];
              case 3:
                error_1 = _c.sent();
                throw new WxCloudSDKError((error_1 === null || error_1 === void 0 ? void 0 : error_1.message) || UNKNOWN_ERROR_MESSAGE, {
                  originError: error_1
                });
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    }
  });
  return client;
};
var __assign$l = function() {
  __assign$l = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$l.apply(this, arguments);
};
var __awaiter$i = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$i = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var CloudbaseEventEmitter = CloudbaseEventEmitter$2;
var COMPONENT_NAME$2 = "models";
function getEntity(cloudbase2) {
  var _this = this;
  var callFunction = cloudbase2.callFunction.bind(cloudbase2);
  var cloudbaseFetch = cloudbase2.request.fetch.bind(cloudbase2.request);
  var fetch2 = function(fetchOptions) {
    return __awaiter$i(_this, void 0, void 0, function() {
      var res;
      return __generator$i(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            return [4, cloudbaseFetch(__assign$l(__assign$l({}, fetchOptions), { headers: __assign$l({ "Content-Type": "application/json" }, fetchOptions.headers) }))];
          case 1:
            res = _a3.sent();
            return [4, res.data];
          case 2:
            return [2, _a3.sent()];
        }
      });
    });
  };
  var _a2 = cloudbase2.getEndPointWithKey("GATEWAY"), BASE_URL = _a2.BASE_URL, PROTOCOL2 = _a2.PROTOCOL;
  var baseUrl = "".concat(PROTOCOL2).concat(BASE_URL, "/model");
  var entity = generateHTTPClient(callFunction, fetch2, baseUrl);
  return entity;
}
var cloudbaseModelMap = /* @__PURE__ */ new WeakMap();
function lazyGetEntity(cloudbase2) {
  return new Proxy({}, {
    get: function(_2, prop) {
      var entity = cloudbaseModelMap.get(cloudbase2);
      if (!entity) {
        entity = getEntity(cloudbase2);
        cloudbaseModelMap.set(cloudbase2, entity);
      }
      return entity[prop];
    }
  });
}
var CLOUDBASE_INIT_EVENT = "cloudbase_init";
var bus = new CloudbaseEventEmitter();
bus.on(CLOUDBASE_INIT_EVENT, function(_a2) {
  var cloudbase2 = _a2.data;
  Object.assign(cloudbase2, { models: lazyGetEntity(cloudbase2) });
});
var component$2 = {
  name: COMPONENT_NAME$2,
  namespace: COMPONENT_NAME$2,
  entity: new Proxy({}, {
    get: function(_2, prop) {
      console.warn("【deprecated】Accessing Cloudbase.prototype.models.".concat(prop, "."));
    }
  }),
  injectEvents: {
    bus,
    events: [CLOUDBASE_INIT_EVENT]
  }
};
try {
  cloudbase.registerComponent(component$2);
} catch (e2) {
}
function registerModel(app) {
  try {
    app.registerComponent(component$2);
  } catch (e2) {
    console.warn(e2);
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends$5(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function assert(test2) {
  if (!test2) {
    throw new TypeError("Assertion failed");
  }
}
function noop() {
  return;
}
function typeIsObject(x2) {
  return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
}
function isStreamConstructor(ctor) {
  if (typeof ctor !== "function") {
    return false;
  }
  var startCalled = false;
  try {
    new ctor({
      start: function() {
        startCalled = true;
      }
    });
  } catch (e2) {
  }
  return startCalled;
}
function isReadableStream(readable) {
  if (!typeIsObject(readable)) {
    return false;
  }
  if (typeof readable.getReader !== "function") {
    return false;
  }
  return true;
}
function isReadableStreamConstructor(ctor) {
  if (!isStreamConstructor(ctor)) {
    return false;
  }
  if (!isReadableStream(new ctor())) {
    return false;
  }
  return true;
}
function supportsByobReader(readable) {
  try {
    var reader = readable.getReader({ mode: "byob" });
    reader.releaseLock();
    return true;
  } catch (_a2) {
    return false;
  }
}
function supportsByteSource(ctor) {
  try {
    new ctor({ type: "bytes" });
    return true;
  } catch (_a2) {
    return false;
  }
}
function createReadableStreamWrapper(ctor) {
  assert(isReadableStreamConstructor(ctor));
  var byteSourceSupported = supportsByteSource(ctor);
  return function(readable, _a2) {
    var _b = _a2 === void 0 ? {} : _a2, type = _b.type;
    type = parseReadableType(type);
    if (type === "bytes" && !byteSourceSupported) {
      type = void 0;
    }
    if (readable.constructor === ctor) {
      if (type !== "bytes" || supportsByobReader(readable)) {
        return readable;
      }
    }
    if (type === "bytes") {
      var source = createWrappingReadableSource(readable, { type });
      return new ctor(source);
    } else {
      var source = createWrappingReadableSource(readable);
      return new ctor(source);
    }
  };
}
function createWrappingReadableSource(readable, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, type = _b.type;
  assert(isReadableStream(readable));
  assert(readable.locked === false);
  type = parseReadableType(type);
  var source;
  if (type === "bytes") {
    source = new WrappingReadableByteStreamSource(readable);
  } else {
    source = new WrappingReadableStreamDefaultSource(readable);
  }
  return source;
}
function parseReadableType(type) {
  var typeString = String(type);
  if (typeString === "bytes") {
    return typeString;
  } else if (type === void 0) {
    return type;
  } else {
    throw new RangeError("Invalid type is specified");
  }
}
var AbstractWrappingReadableStreamSource = (
  /** @class */
  function() {
    function AbstractWrappingReadableStreamSource2(underlyingStream) {
      this._underlyingReader = void 0;
      this._readerMode = void 0;
      this._readableStreamController = void 0;
      this._pendingRead = void 0;
      this._underlyingStream = underlyingStream;
      this._attachDefaultReader();
    }
    AbstractWrappingReadableStreamSource2.prototype.start = function(controller) {
      this._readableStreamController = controller;
    };
    AbstractWrappingReadableStreamSource2.prototype.cancel = function(reason) {
      assert(this._underlyingReader !== void 0);
      return this._underlyingReader.cancel(reason);
    };
    AbstractWrappingReadableStreamSource2.prototype._attachDefaultReader = function() {
      if (this._readerMode === "default") {
        return;
      }
      this._detachReader();
      var reader = this._underlyingStream.getReader();
      this._readerMode = "default";
      this._attachReader(reader);
    };
    AbstractWrappingReadableStreamSource2.prototype._attachReader = function(reader) {
      var _this = this;
      assert(this._underlyingReader === void 0);
      this._underlyingReader = reader;
      var closed = this._underlyingReader.closed;
      if (!closed) {
        return;
      }
      closed.then(function() {
        return _this._finishPendingRead();
      }).then(function() {
        if (reader === _this._underlyingReader) {
          _this._readableStreamController.close();
        }
      }, function(reason) {
        if (reader === _this._underlyingReader) {
          _this._readableStreamController.error(reason);
        }
      }).catch(noop);
    };
    AbstractWrappingReadableStreamSource2.prototype._detachReader = function() {
      if (this._underlyingReader === void 0) {
        return;
      }
      this._underlyingReader.releaseLock();
      this._underlyingReader = void 0;
      this._readerMode = void 0;
    };
    AbstractWrappingReadableStreamSource2.prototype._pullWithDefaultReader = function() {
      var _this = this;
      this._attachDefaultReader();
      var read3 = this._underlyingReader.read().then(function(result) {
        var controller = _this._readableStreamController;
        if (result.done) {
          _this._tryClose();
        } else {
          controller.enqueue(result.value);
        }
      });
      this._setPendingRead(read3);
      return read3;
    };
    AbstractWrappingReadableStreamSource2.prototype._tryClose = function() {
      try {
        this._readableStreamController.close();
      } catch (_a2) {
      }
    };
    AbstractWrappingReadableStreamSource2.prototype._setPendingRead = function(readPromise) {
      var _this = this;
      var pendingRead;
      var finishRead = function() {
        if (_this._pendingRead === pendingRead) {
          _this._pendingRead = void 0;
        }
      };
      this._pendingRead = pendingRead = readPromise.then(finishRead, finishRead);
    };
    AbstractWrappingReadableStreamSource2.prototype._finishPendingRead = function() {
      var _this = this;
      if (!this._pendingRead) {
        return void 0;
      }
      var afterRead = function() {
        return _this._finishPendingRead();
      };
      return this._pendingRead.then(afterRead, afterRead);
    };
    return AbstractWrappingReadableStreamSource2;
  }()
);
var WrappingReadableStreamDefaultSource = (
  /** @class */
  function(_super) {
    __extends$5(WrappingReadableStreamDefaultSource2, _super);
    function WrappingReadableStreamDefaultSource2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    WrappingReadableStreamDefaultSource2.prototype.pull = function() {
      return this._pullWithDefaultReader();
    };
    return WrappingReadableStreamDefaultSource2;
  }(AbstractWrappingReadableStreamSource)
);
function toUint8Array(view) {
  return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
}
function copyArrayBufferView(from, to2) {
  var fromArray = toUint8Array(from);
  var toArray2 = toUint8Array(to2);
  toArray2.set(fromArray, 0);
}
var WrappingReadableByteStreamSource = (
  /** @class */
  function(_super) {
    __extends$5(WrappingReadableByteStreamSource2, _super);
    function WrappingReadableByteStreamSource2(underlyingStream) {
      var _this = this;
      var supportsByob = supportsByobReader(underlyingStream);
      _this = _super.call(this, underlyingStream) || this;
      _this._supportsByob = supportsByob;
      return _this;
    }
    Object.defineProperty(WrappingReadableByteStreamSource2.prototype, "type", {
      get: function() {
        return "bytes";
      },
      enumerable: false,
      configurable: true
    });
    WrappingReadableByteStreamSource2.prototype._attachByobReader = function() {
      if (this._readerMode === "byob") {
        return;
      }
      assert(this._supportsByob);
      this._detachReader();
      var reader = this._underlyingStream.getReader({ mode: "byob" });
      this._readerMode = "byob";
      this._attachReader(reader);
    };
    WrappingReadableByteStreamSource2.prototype.pull = function() {
      if (this._supportsByob) {
        var byobRequest = this._readableStreamController.byobRequest;
        if (byobRequest) {
          return this._pullWithByobRequest(byobRequest);
        }
      }
      return this._pullWithDefaultReader();
    };
    WrappingReadableByteStreamSource2.prototype._pullWithByobRequest = function(byobRequest) {
      var _this = this;
      this._attachByobReader();
      var buffer2 = new Uint8Array(byobRequest.view.byteLength);
      var read3 = this._underlyingReader.read(buffer2).then(function(result) {
        _this._readableStreamController;
        if (result.done) {
          _this._tryClose();
          byobRequest.respond(0);
        } else {
          copyArrayBufferView(result.value, byobRequest.view);
          byobRequest.respond(result.value.byteLength);
        }
      });
      this._setPendingRead(read3);
      return read3;
    };
    return WrappingReadableByteStreamSource2;
  }(AbstractWrappingReadableStreamSource)
);
function createParser(onParse) {
  var isFirstChunk;
  var buffer2;
  var startingPosition;
  var startingFieldLength;
  var eventId;
  var eventName;
  var data;
  reset();
  return { feed, reset };
  function reset() {
    isFirstChunk = true;
    buffer2 = "";
    startingPosition = 0;
    startingFieldLength = -1;
    eventId = void 0;
    eventName = void 0;
    data = "";
  }
  function feed(chunk) {
    buffer2 = buffer2 ? buffer2 + chunk : chunk;
    if (isFirstChunk && hasBom(buffer2)) {
      buffer2 = buffer2.slice(BOM.length);
    }
    isFirstChunk = false;
    var length = buffer2.length;
    var position = 0;
    var discardTrailingNewline = false;
    while (position < length) {
      if (discardTrailingNewline) {
        if (buffer2[position] === "\n") {
          position += 1;
        }
        discardTrailingNewline = false;
      }
      var lineLength = -1;
      var fieldLength = startingFieldLength;
      var character = void 0;
      for (var index2 = startingPosition; lineLength < 0 && index2 < length; index2++) {
        character = buffer2[index2];
        if (character === ":" && fieldLength < 0) {
          fieldLength = index2 - position;
        } else if (character === "\r") {
          discardTrailingNewline = true;
          lineLength = index2 - position;
        } else if (character === "\n") {
          lineLength = index2 - position;
        }
      }
      if (lineLength < 0) {
        startingPosition = length - position;
        startingFieldLength = fieldLength;
        break;
      } else {
        startingPosition = 0;
        startingFieldLength = -1;
      }
      parseEventStreamLine(buffer2, position, fieldLength, lineLength);
      position += lineLength + 1;
    }
    if (position === length) {
      buffer2 = "";
    } else if (position > 0) {
      buffer2 = buffer2.slice(position);
    }
  }
  function parseEventStreamLine(lineBuffer, index2, fieldLength, lineLength) {
    if (lineLength === 0) {
      if (data.length > 0) {
        onParse({
          type: "event",
          id: eventId,
          event: eventName || void 0,
          data: data.slice(0, -1)
        });
        data = "";
        eventId = void 0;
      }
      eventName = void 0;
      return;
    }
    var noValue = fieldLength < 0;
    var field = lineBuffer.slice(index2, index2 + (noValue ? lineLength : fieldLength));
    var step = 0;
    if (noValue) {
      step = lineLength;
    } else if (lineBuffer[index2 + fieldLength + 1] === " ") {
      step = fieldLength + 2;
    } else {
      step = fieldLength + 1;
    }
    var position = index2 + step;
    var valueLength = lineLength - step;
    var value = lineBuffer.slice(position, position + valueLength).toString();
    if (field === "data") {
      data += value ? "".concat(value, "\n") : "\n";
    } else if (field === "event") {
      eventName = value;
    } else if (field === "id" && !value.includes("\0")) {
      eventId = value;
    } else if (field === "retry") {
      var retry = parseInt(value, 10);
      if (!Number.isNaN(retry)) {
        onParse({ type: "reconnect-interval", value: retry });
      }
    }
  }
}
var BOM = [239, 187, 191];
function hasBom(buffer2) {
  return BOM.every(function(charCode, index2) {
    return buffer2.charCodeAt(index2) === charCode;
  });
}
var textEncodingShim = { exports: {} };
(function(module2, exports2) {
  (function(root2, factory) {
    {
      module2.exports = factory();
    }
  })(commonjsGlobal, function() {
    var g2 = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : self;
    if (typeof g2.TextEncoder !== "undefined" && typeof g2.TextDecoder !== "undefined") {
      return { "TextEncoder": g2.TextEncoder, "TextDecoder": g2.TextDecoder };
    }
    var utf8Encodings = [
      "utf8",
      "utf-8",
      "unicode-1-1-utf-8"
    ];
    var TextEncoder2 = function(encoding) {
      if (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== "undefined" && encoding !== null) {
        throw new RangeError("Invalid encoding type. Only utf-8 is supported");
      } else {
        this.encoding = "utf-8";
        this.encode = function(str) {
          if (typeof str !== "string") {
            throw new TypeError("passed argument must be of type string");
          }
          var binstr = unescape(encodeURIComponent(str)), arr = new Uint8Array(binstr.length);
          binstr.split("").forEach(function(char, i) {
            arr[i] = char.charCodeAt(0);
          });
          return arr;
        };
      }
    };
    var TextDecoder = function(encoding, options) {
      if (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== "undefined" && encoding !== null) {
        throw new RangeError("Invalid encoding type. Only utf-8 is supported");
      }
      this.encoding = "utf-8";
      this.ignoreBOM = false;
      this.fatal = typeof options !== "undefined" && "fatal" in options ? options.fatal : false;
      if (typeof this.fatal !== "boolean") {
        throw new TypeError("fatal flag must be boolean");
      }
      this.decode = function(view, options2) {
        if (typeof view === "undefined") {
          return "";
        }
        var stream = typeof options2 !== "undefined" && "stream" in options2 ? options2.stream : false;
        if (typeof stream !== "boolean") {
          throw new TypeError("stream option must be boolean");
        }
        if (!ArrayBuffer.isView(view)) {
          throw new TypeError("passed argument must be an array buffer view");
        } else {
          var arr = new Uint8Array(view.buffer, view.byteOffset, view.byteLength), charArr = new Array(arr.length);
          arr.forEach(function(charcode, i) {
            charArr[i] = String.fromCharCode(charcode);
          });
          return decodeURIComponent(escape(charArr.join("")));
        }
      };
    };
    return { "TextEncoder": TextEncoder2, "TextDecoder": TextDecoder };
  });
})(textEncodingShim);
var textEncodingShimExports = textEncodingShim.exports;
var __awaiter$h = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$h = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __asyncValues$1 = function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o2[n2](v2), settle3(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle3(resolve2, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve2({ value: v3, done: d2 });
    }, reject);
  }
};
var ReadableStream$1 = ReadableStream$2;
var TransformStream2 = TransformStream$1;
var createEventSourceParserTransformStream = function() {
  var parser;
  return new TransformStream2({
    start: function(controller) {
      parser = createParser(function(event) {
        if (event.type === "event") {
          controller.enqueue(event);
        }
      });
    },
    transform: function(chunk) {
      parser.feed(chunk);
    }
  });
};
var toPolyfillReadable = createReadableStreamWrapper(ReadableStream$1);
var TextDecoderStream = function() {
  function TextDecoderStream2(encoding, options) {
    if (encoding === void 0) {
      encoding = "utf-8";
    }
    if (options === void 0) {
      options = {};
    }
    var _this = this;
    this.transform = new TransformStream2({
      transform: function(chunk, controller) {
        var value = _this.handle.decode(new Uint8Array(chunk), { stream: true });
        if (value) {
          controller.enqueue(value);
        }
      },
      flush: function(controller) {
        var value = _this.handle.decode();
        if (value) {
          controller.enqueue(value);
        }
        controller.terminate();
      }
    });
    this.handle = new textEncodingShimExports.TextDecoder(encoding, options);
  }
  Object.defineProperty(TextDecoderStream2.prototype, "encoding", {
    get: function() {
      return this.handle.encoding;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextDecoderStream2.prototype, "fatal", {
    get: function() {
      return this.handle.fatal;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextDecoderStream2.prototype, "ignoreBOM", {
    get: function() {
      return this.handle.ignoreBOM;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextDecoderStream2.prototype, "readable", {
    get: function() {
      return this.transform.readable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextDecoderStream2.prototype, "writable", {
    get: function() {
      return this.transform.writable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextDecoderStream2.prototype, Symbol.toStringTag, {
    get: function() {
      return "TextDecoderStream";
    },
    enumerable: false,
    configurable: true
  });
  return TextDecoderStream2;
}();
function createAsyncIterable(stream) {
  var _stream = stream;
  _stream[Symbol.asyncIterator] = function() {
    var reader = stream.getReader();
    return {
      next: function() {
        return __awaiter$h(this, void 0, void 0, function() {
          var _a2, done, value;
          return __generator$h(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, reader.read()];
              case 1:
                _a2 = _b.sent(), done = _a2.done, value = _a2.value;
                return [2, done ? { done: true, value: void 0 } : { done: false, value }];
            }
          });
        });
      }
    };
  };
  return _stream;
}
function intoStandardStream(stream) {
  return createAsyncIterable(stream.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserTransformStream()).pipeThrough(new TransformStream2({
    transform: function(chunk, controller) {
      try {
        var data = JSON.parse(chunk.data);
        controller.enqueue(data);
      } catch (e2) {
        if (chunk.data !== "[DONE]") {
          console.warn("Error when transforming event source data to json", e2, chunk);
        } else {
          controller.terminate();
        }
      }
    }
  })));
}
function intoTextStream(stream) {
  return createAsyncIterable(toPolyfillReadable(stream).pipeThrough(new TextDecoderStream()));
}
function readableStream2JsonObject(stream) {
  var _a2, e_1, _b, _c;
  return __awaiter$h(this, void 0, void 0, function() {
    var s2, total, _d, s_1, s_1_1, chunk, e_1_1;
    return __generator$h(this, function(_e2) {
      switch (_e2.label) {
        case 0:
          s2 = intoTextStream(stream);
          total = "";
          _e2.label = 1;
        case 1:
          _e2.trys.push([1, 6, 7, 12]);
          _d = true, s_1 = __asyncValues$1(s2);
          _e2.label = 2;
        case 2:
          return [4, s_1.next()];
        case 3:
          if (!(s_1_1 = _e2.sent(), _a2 = s_1_1.done, !_a2))
            return [3, 5];
          _c = s_1_1.value;
          _d = false;
          try {
            chunk = _c;
            total += chunk;
          } finally {
            _d = true;
          }
          _e2.label = 4;
        case 4:
          return [3, 2];
        case 5:
          return [3, 12];
        case 6:
          e_1_1 = _e2.sent();
          e_1 = { error: e_1_1 };
          return [3, 12];
        case 7:
          _e2.trys.push([7, , 10, 11]);
          if (!(!_d && !_a2 && (_b = s_1.return)))
            return [3, 9];
          return [4, _b.call(s_1)];
        case 8:
          _e2.sent();
          _e2.label = 9;
        case 9:
          return [3, 11];
        case 10:
          if (e_1)
            throw e_1.error;
          return [7];
        case 11:
          return [7];
        case 12:
          return [2, JSON.parse(total)];
      }
    });
  });
}
function createPromise() {
  var res;
  var rej;
  var promise = new Promise(function(resolve2, reject) {
    res = resolve2;
    rej = reject;
  });
  return { promise, res, rej };
}
function isToolCallAssistantMessage(message) {
  var _a2;
  return message.role === "assistant" && "tool_calls" in message && ((_a2 = message.tool_calls) === null || _a2 === void 0 ? void 0 : _a2[0]) != null;
}
function functionToolToModelTool(tool) {
  return {
    type: "function",
    function: {
      description: tool.description,
      name: tool.name,
      parameters: tool.parameters
    }
  };
}
var __assign$k = function() {
  __assign$k = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$k.apply(this, arguments);
};
var __awaiter$g = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$g = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest$2 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
var Bot = function() {
  function Bot2(req, baseUrl) {
    this.baseUrl = baseUrl;
    var token = arguments[2];
    if (typeof token === "string") {
      this.req = function(_a2) {
        var _b = _a2.headers, headers = _b === void 0 ? {} : _b, rest = __rest$2(_a2, ["headers"]);
        return req(__assign$k(__assign$k({}, rest), { headers: __assign$k(__assign$k({}, headers), { Authorization: "Bearer ".concat(token) }) }));
      };
    } else {
      this.req = req;
    }
  }
  Bot2.prototype.list = function(props) {
    return this.req({
      method: "get",
      url: this.join("bots"),
      data: props
    });
  };
  Bot2.prototype.create = function(_a2) {
    var botInfo = _a2.botInfo;
    return this.req({
      method: "post",
      url: this.join("bots"),
      data: botInfo
    });
  };
  Bot2.prototype.get = function(_a2) {
    var botId = _a2.botId;
    return this.req({
      method: "get",
      url: this.join("bots/".concat(botId))
    });
  };
  Bot2.prototype.update = function(_a2) {
    var botId = _a2.botId, botInfo = _a2.botInfo;
    return this.req({
      method: "PATCH",
      url: this.join("bots/".concat(botId)),
      data: botInfo
    });
  };
  Bot2.prototype.delete = function(_a2) {
    var botId = _a2.botId;
    return this.req({ method: "delete", url: this.join("bots/".concat(botId)) });
  };
  Bot2.prototype.getChatRecords = function(props) {
    return this.req({ method: "get", url: this.join("bots/".concat(props.botId, "/records")), data: props });
  };
  Bot2.prototype.sendFeedback = function(_a2) {
    var userFeedback = _a2.userFeedback;
    return this.req({ method: "post", url: this.join("bots/".concat(userFeedback.botId, "/feedback")), data: userFeedback });
  };
  Bot2.prototype.getFeedback = function(props) {
    return this.req({ method: "get", url: this.join("bots/".concat(props.botId, "/feedback")), data: props });
  };
  Bot2.prototype.getRecommendQuestions = function(props) {
    return __awaiter$g(this, void 0, void 0, function() {
      var res;
      return __generator$g(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              method: "post",
              url: this.join("bots/".concat(props.botId, "/recommend-questions")),
              data: props,
              stream: true
            })];
          case 1:
            res = _a2.sent();
            return [2, new StreamResult(res)];
        }
      });
    });
  };
  Bot2.prototype.generateBot = function(props) {
    return __awaiter$g(this, void 0, void 0, function() {
      var res;
      return __generator$g(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({ method: "post", url: this.join("generate-bot"), data: props, stream: true })];
          case 1:
            res = _a2.sent();
            return [2, new StreamResult(res)];
        }
      });
    });
  };
  Bot2.prototype.getPreview = function(props) {
    return __awaiter$g(this, void 0, void 0, function() {
      var res;
      return __generator$g(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({ method: "post", url: this.join("preview"), data: props, stream: true })];
          case 1:
            res = _a2.sent();
            return [2, new StreamResult(res)];
        }
      });
    });
  };
  Bot2.prototype.generateImage = function(props) {
    return this.req({ method: "post", url: this.join("generate-image"), data: props });
  };
  Bot2.prototype.sendMessage = function(props) {
    return __awaiter$g(this, void 0, void 0, function() {
      var res;
      return __generator$g(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              method: "post",
              url: this.join("bots/".concat(props.botId, "/send-message")),
              data: props,
              stream: true
            })];
          case 1:
            res = _a2.sent();
            return [2, new StreamResult(res)];
        }
      });
    });
  };
  Bot2.prototype.join = function(url) {
    return "".concat(this.baseUrl, "/").concat(url);
  };
  return Bot2;
}();
var StreamResult = function() {
  function StreamResult2(_stream) {
    var stream = toPolyfillReadable(_stream);
    this._eventSourceStream = stream.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserTransformStream());
  }
  Object.defineProperty(StreamResult2.prototype, "teeedStream", {
    get: function() {
      var _a2 = this._eventSourceStream.tee(), s1 = _a2[0], s2 = _a2[1];
      this._eventSourceStream = s2;
      return s1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StreamResult2.prototype, "eventSourceStream", {
    get: function() {
      return createAsyncIterable(this.teeedStream);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StreamResult2.prototype, "dataStream", {
    get: function() {
      return createAsyncIterable(this.eventSourceStream.pipeThrough(new TransformStream2({
        transform: function(chunk, controller) {
          try {
            var data = JSON.parse(chunk.data);
            controller.enqueue(data);
          } catch (e2) {
            if (chunk.data !== "[DONE]") {
              console.warn("Error when transforming event source data to json", e2, chunk);
            } else {
              controller.terminate();
            }
          }
        }
      })));
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StreamResult2.prototype, "textStream", {
    get: function() {
      return createAsyncIterable(this.dataStream.pipeThrough(new TransformStream2({
        transform: function(chunk, controller) {
          var _a2;
          controller.enqueue((_a2 = chunk === null || chunk === void 0 ? void 0 : chunk.content) !== null && _a2 !== void 0 ? _a2 : "");
        }
      })));
    },
    enumerable: false,
    configurable: true
  });
  return StreamResult2;
}();
var __assign$j = function() {
  __assign$j = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$j.apply(this, arguments);
};
var __awaiter$f = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$f = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
function processInput$6(input) {
  var messages = input.messages, model = input.model, temperature = input.temperature, tool_choice = input.tool_choice, tools = input.tools, top_p = input.top_p;
  var processToolChoice = function() {
    if (tool_choice && tool_choice !== "auto") {
      console.warn("`tool_choice` is not 'auto'");
    }
    return tool_choice;
  };
  return __assign$j(__assign$j({}, input), { messages, model, temperature, tool_choice: processToolChoice(), tools, top_p });
}
var ZhiPuSimpleModel = function() {
  function ZhiPuSimpleModel2(req, baseUrl, subUrl) {
    this.req = req;
    this.baseUrl = baseUrl;
    this.subUrl = "zhipu/api/paas/v4/chat/completions";
    if (subUrl != null) {
      this.subUrl = subUrl;
    }
  }
  Object.defineProperty(ZhiPuSimpleModel2.prototype, "url", {
    get: function() {
      return "".concat(this.baseUrl, "/").concat(this.subUrl);
    },
    enumerable: false,
    configurable: true
  });
  ZhiPuSimpleModel2.prototype.doGenerate = function(_data) {
    return __awaiter$f(this, void 0, void 0, function() {
      var data, res;
      return __generator$f(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            data = processInput$6(_data);
            return [4, this.req({
              url: this.url,
              data: __assign$j(__assign$j({}, data), { stream: false }),
              stream: false
            })];
          case 1:
            res = _a2.sent();
            return [2, __assign$j(__assign$j({}, res), { rawResponse: res })];
        }
      });
    });
  };
  ZhiPuSimpleModel2.prototype.doStream = function(_data) {
    return __awaiter$f(this, void 0, void 0, function() {
      var data, isToolCall, _stream, stream, zhipuStream, streamWithRaw;
      return __generator$f(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            data = processInput$6(_data);
            isToolCall = null;
            return [4, this.req({
              url: this.url,
              data: __assign$j(__assign$j({}, data), { stream: true }),
              stream: true
            })];
          case 1:
            _stream = _a2.sent();
            stream = toPolyfillReadable(_stream);
            zhipuStream = intoStandardStream(stream);
            streamWithRaw = zhipuStream.pipeThrough(new TransformStream2({
              transform: function(chunk, controller) {
                var newChoices = chunk.choices.map(function(choice) {
                  var message = choice.delta;
                  if (isToolCall == null)
                    isToolCall = isToolCallAssistantMessage(message);
                  if (isToolCall) {
                    return __assign$j(__assign$j({}, choice), { finish_reason: "tool_calls", delta: message });
                  }
                  return choice;
                });
                var newChunk = __assign$j(__assign$j({}, chunk), { choices: newChoices });
                controller.enqueue(__assign$j(__assign$j({}, newChunk), { rawResponse: chunk }));
              }
            }));
            return [2, createAsyncIterable(streamWithRaw)];
        }
      });
    });
  };
  return ZhiPuSimpleModel2;
}();
var __assign$i = function() {
  __assign$i = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$i.apply(this, arguments);
};
function processInput$5(input) {
  var messages = input.messages, model = input.model, temperature = input.temperature, tool_choice = input.tool_choice, tools = input.tools, top_p = input.top_p;
  var handleTools = function() {
    if (!tools)
      return void 0;
    tools.forEach(function(tool) {
      if (tool.type !== "function")
        console.warn("`type` in tool is not 'function'", tool);
    });
    return tools;
  };
  var handleMessages = function() {
    messages.forEach(function(message) {
      if ("tool_calls" in message) {
        message.tool_calls.filter(function(tool_call) {
          return tool_call.type !== "function";
        }).forEach(function(tool_call) {
          return console.warn("`type` in tool_call is not 'function'", tool_call, message);
        });
      }
    });
    return messages;
  };
  return __assign$i(__assign$i({}, input), { messages: handleMessages(), model, tools: handleTools(), top_p, tool_choice, temperature });
}
function titleCaseToSnakeCase(obj) {
  if (typeof obj !== "object" || obj == null)
    return obj;
  if (Array.isArray(obj))
    return obj.map(function(item) {
      return titleCaseToSnakeCase(item);
    });
  return Object.entries(obj).reduce(function(acc, _a2) {
    var key = _a2[0], value = _a2[1];
    var snakeCaseKey = toSnakeCase(key);
    acc[snakeCaseKey] = typeof value === "object" ? titleCaseToSnakeCase(value) : value;
    return acc;
  }, {});
  function toSnakeCase(s2) {
    var ret = s2.replace(/[A-Z]/g, function(match) {
      return "_".concat(match.toLowerCase());
    });
    return ret.charAt(0) === "_" ? ret.slice(1) : ret;
  }
}
var __assign$h = function() {
  __assign$h = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$h.apply(this, arguments);
};
var __awaiter$e = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$e = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var HunYuanBetaSimpleModel = function() {
  function HunYuanBetaSimpleModel2(req, baseUrl, subUrl) {
    this.req = req;
    this.baseUrl = baseUrl;
    this.subUrl = "hunyuan-beta/openapi/v1/chat/completions";
    if (subUrl != null) {
      this.subUrl = subUrl;
    }
  }
  Object.defineProperty(HunYuanBetaSimpleModel2.prototype, "url", {
    get: function() {
      return "".concat(this.baseUrl, "/").concat(this.subUrl);
    },
    enumerable: false,
    configurable: true
  });
  HunYuanBetaSimpleModel2.prototype.doGenerate = function(data) {
    return __awaiter$e(this, void 0, void 0, function() {
      var res;
      return __generator$e(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              url: this.url,
              data: __assign$h(__assign$h({}, processInput$5(data)), { stream: false }),
              stream: false
            })];
          case 1:
            res = _a2.sent();
            return [2, __assign$h(__assign$h({}, res), { rawResponse: res })];
        }
      });
    });
  };
  HunYuanBetaSimpleModel2.prototype.doStream = function(data) {
    return __awaiter$e(this, void 0, void 0, function() {
      var isToolCall, _stream, stream, hunyuanBetaStream, streamWithRaw;
      return __generator$e(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isToolCall = null;
            return [4, this.req({
              url: this.url,
              data: __assign$h(__assign$h({}, processInput$5(data)), { stream: true }),
              stream: true
            })];
          case 1:
            _stream = _a2.sent();
            stream = toPolyfillReadable(_stream);
            hunyuanBetaStream = intoStandardStream(stream);
            streamWithRaw = hunyuanBetaStream.pipeThrough(new TransformStream2({
              transform: function(chunk, controller) {
                var newChoices = chunk.choices.map(function(choice) {
                  var message = choice.delta;
                  if (isToolCall == null)
                    isToolCall = isToolCallAssistantMessage(message);
                  if (isToolCall) {
                    return __assign$h(__assign$h({}, choice), { finish_reason: "tool_calls", delta: message });
                  }
                  return choice;
                });
                var newChunk = __assign$h(__assign$h({}, chunk), { choices: newChoices });
                controller.enqueue(__assign$h(__assign$h({}, newChunk), { rawResponse: chunk }));
              }
            }));
            return [2, createAsyncIterable(streamWithRaw)];
        }
      });
    });
  };
  return HunYuanBetaSimpleModel2;
}();
var __assign$g = function() {
  __assign$g = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$g.apply(this, arguments);
};
var __awaiter$d = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$d = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var HunYuanSimpleModel = function() {
  function HunYuanSimpleModel2(req, baseUrl, subUrl) {
    this.req = req;
    this.baseUrl = baseUrl;
    this.subUrl = "hunyuan";
    if (subUrl != null) {
      this.subUrl = subUrl;
    }
  }
  Object.defineProperty(HunYuanSimpleModel2.prototype, "url", {
    get: function() {
      return "".concat(this.baseUrl, "/").concat(this.subUrl);
    },
    enumerable: false,
    configurable: true
  });
  HunYuanSimpleModel2.prototype.doGenerate = function(data) {
    return __awaiter$d(this, void 0, void 0, function() {
      var res, output;
      return __generator$d(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              url: this.url,
              headers: {
                "X-Tc-Action": "ChatCompletions"
              },
              data: __assign$g(__assign$g({}, processInput$5(data)), { stream: false }),
              stream: false
            })];
          case 1:
            res = _a2.sent();
            output = titleCaseToSnakeCase(res.Response);
            return [2, __assign$g(__assign$g({}, output), { rawResponse: res })];
        }
      });
    });
  };
  HunYuanSimpleModel2.prototype.doStream = function(data) {
    return __awaiter$d(this, void 0, void 0, function() {
      var isToolCall, _stream, stream, hunyuanStream, streamWithRaw;
      return __generator$d(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isToolCall = null;
            return [4, this.req({
              url: this.url,
              headers: {
                "X-Tc-Action": "ChatCompletions"
              },
              data: __assign$g(__assign$g({}, data), { stream: true }),
              stream: true
            })];
          case 1:
            _stream = _a2.sent();
            stream = toPolyfillReadable(_stream);
            hunyuanStream = intoStandardStream(stream);
            streamWithRaw = hunyuanStream.pipeThrough(new TransformStream2({
              transform: function(_chunk, controller) {
                var chunk = titleCaseToSnakeCase(_chunk);
                var newChoices = chunk.choices.map(function(choice) {
                  var message = choice.delta;
                  if (isToolCall == null)
                    isToolCall = isToolCallAssistantMessage(message);
                  if (isToolCall) {
                    return __assign$g(__assign$g({}, choice), { finish_reason: "tool_calls", delta: message });
                  }
                  return choice;
                });
                var newChunk = __assign$g(__assign$g({}, chunk), { choices: newChoices });
                controller.enqueue(__assign$g(__assign$g({}, newChunk), { rawResponse: _chunk }));
              }
            }));
            return [2, createAsyncIterable(streamWithRaw)];
        }
      });
    });
  };
  return HunYuanSimpleModel2;
}();
var __assign$f = function() {
  __assign$f = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$f.apply(this, arguments);
};
var __awaiter$c = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$c = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
function processInput$4(input) {
  var messages = input.messages, model = input.model, temperature = input.temperature, tools = input.tools, top_p = input.top_p;
  return __assign$f(__assign$f({}, input), { messages, model, tools, top_p, temperature });
}
var ArkSimpleModel = function() {
  function ArkSimpleModel2(req, baseUrl, subUrl) {
    this.req = req;
    this.baseUrl = baseUrl;
    this.subUrl = "ark/api/v3/chat/completions";
    if (subUrl != null) {
      this.subUrl = subUrl;
    }
  }
  Object.defineProperty(ArkSimpleModel2.prototype, "url", {
    get: function() {
      return "".concat(this.baseUrl, "/").concat(this.subUrl);
    },
    enumerable: false,
    configurable: true
  });
  ArkSimpleModel2.prototype.doGenerate = function(data) {
    return __awaiter$c(this, void 0, void 0, function() {
      var res;
      return __generator$c(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              url: this.url,
              data: __assign$f(__assign$f({}, processInput$4(data)), { stream: false }),
              stream: false
            })];
          case 1:
            res = _a2.sent();
            return [2, __assign$f(__assign$f({}, res), { rawResponse: res })];
        }
      });
    });
  };
  ArkSimpleModel2.prototype.doStream = function(data) {
    return __awaiter$c(this, void 0, void 0, function() {
      var isToolCall, _stream, stream, arkStream, streamWithRaw;
      return __generator$c(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isToolCall = null;
            return [4, this.req({
              url: this.url,
              data: __assign$f(__assign$f({}, processInput$4(data)), { stream: true }),
              stream: true
            })];
          case 1:
            _stream = _a2.sent();
            stream = toPolyfillReadable(_stream);
            arkStream = intoStandardStream(stream);
            streamWithRaw = arkStream.pipeThrough(new TransformStream2({
              transform: function(chunk, controller) {
                var newChoices = chunk.choices.map(function(choice) {
                  var message = choice.delta;
                  if (isToolCall == null)
                    isToolCall = isToolCallAssistantMessage(message);
                  if (isToolCall) {
                    return __assign$f(__assign$f({}, choice), { finish_reason: "tool_calls", delta: message });
                  }
                  return choice;
                });
                var newChunk = __assign$f(__assign$f({}, chunk), { choices: newChoices });
                controller.enqueue(__assign$f(__assign$f({}, newChunk), { rawResponse: chunk }));
              }
            }));
            return [2, createAsyncIterable(streamWithRaw)];
        }
      });
    });
  };
  return ArkSimpleModel2;
}();
var __assign$e = function() {
  __assign$e = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$e.apply(this, arguments);
};
var __awaiter$b = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$b = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
function processInput$3(input) {
  var messages = input.messages, model = input.model, temperature = input.temperature, tools = input.tools, top_p = input.top_p;
  return __assign$e(__assign$e({}, input), { messages, model, tools, top_p, temperature });
}
var DSSimpleModel = function() {
  function DSSimpleModel2(req, baseUrl, subUrl) {
    this.req = req;
    this.baseUrl = baseUrl;
    this.subUrl = "dashscope/compatible-mode/v1/chat/completions";
    if (subUrl != null) {
      this.subUrl = subUrl;
    }
  }
  Object.defineProperty(DSSimpleModel2.prototype, "url", {
    get: function() {
      return "".concat(this.baseUrl, "/").concat(this.subUrl);
    },
    enumerable: false,
    configurable: true
  });
  DSSimpleModel2.prototype.doGenerate = function(data) {
    return __awaiter$b(this, void 0, void 0, function() {
      var res;
      return __generator$b(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              url: this.url,
              data: __assign$e(__assign$e({}, processInput$3(data)), { stream: false }),
              stream: false
            })];
          case 1:
            res = _a2.sent();
            return [2, __assign$e(__assign$e({}, res), { rawResponse: res })];
        }
      });
    });
  };
  DSSimpleModel2.prototype.doStream = function(data) {
    return __awaiter$b(this, void 0, void 0, function() {
      var isToolCall, _stream, stream, arkStream, streamWithRaw;
      return __generator$b(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isToolCall = null;
            return [4, this.req({
              url: this.url,
              data: __assign$e(__assign$e({}, processInput$3(data)), { stream: true }),
              stream: true
            })];
          case 1:
            _stream = _a2.sent();
            stream = toPolyfillReadable(_stream);
            arkStream = intoStandardStream(stream);
            streamWithRaw = arkStream.pipeThrough(new TransformStream2({
              transform: function(chunk, controller) {
                var newChoices = chunk.choices.map(function(choice) {
                  var message = Object.assign(choice.delta, { role: "assistant" });
                  if (isToolCall == null)
                    isToolCall = isToolCallAssistantMessage(message);
                  if (isToolCall) {
                    return __assign$e(__assign$e({}, choice), { finish_reason: "tool_calls", delta: message });
                  }
                  return __assign$e(__assign$e({}, choice), { delta: message });
                });
                var newChunk = __assign$e(__assign$e({}, chunk), { choices: newChoices });
                controller.enqueue(__assign$e(__assign$e({}, newChunk), { rawResponse: chunk }));
              }
            }));
            return [2, createAsyncIterable(streamWithRaw)];
        }
      });
    });
  };
  return DSSimpleModel2;
}();
var __assign$d = function() {
  __assign$d = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$d.apply(this, arguments);
};
var __awaiter$a = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$a = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
function processInput$2(input) {
  var messages = input.messages, model = input.model, temperature = input.temperature, tools = input.tools, top_p = input.top_p;
  return __assign$d(__assign$d({}, input), { messages, model, tools, top_p, temperature });
}
var YiSimpleModel = function() {
  function YiSimpleModel2(req, baseUrl, subUrl) {
    this.req = req;
    this.baseUrl = baseUrl;
    this.subUrl = "01-ai/v1/chat/completions";
    if (subUrl != null) {
      this.subUrl = subUrl;
    }
  }
  Object.defineProperty(YiSimpleModel2.prototype, "url", {
    get: function() {
      return "".concat(this.baseUrl, "/").concat(this.subUrl);
    },
    enumerable: false,
    configurable: true
  });
  YiSimpleModel2.prototype.doGenerate = function(data) {
    return __awaiter$a(this, void 0, void 0, function() {
      var res;
      return __generator$a(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              url: this.url,
              data: __assign$d(__assign$d({}, processInput$2(data)), { stream: false }),
              stream: false
            })];
          case 1:
            res = _a2.sent();
            return [2, __assign$d(__assign$d({}, res), { rawResponse: res })];
        }
      });
    });
  };
  YiSimpleModel2.prototype.doStream = function(data) {
    return __awaiter$a(this, void 0, void 0, function() {
      var isToolCall, _stream, stream, arkStream, streamWithRaw;
      return __generator$a(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isToolCall = null;
            return [4, this.req({
              url: this.url,
              data: __assign$d(__assign$d({}, processInput$2(data)), { stream: true }),
              stream: true
            })];
          case 1:
            _stream = _a2.sent();
            stream = toPolyfillReadable(_stream);
            arkStream = intoStandardStream(stream);
            streamWithRaw = arkStream.pipeThrough(new TransformStream2({
              transform: function(chunk, controller) {
                var _a3, _b, _c, _d, _e2, _f;
                if (!(((_c = (_b = (_a3 = chunk === null || chunk === void 0 ? void 0 : chunk.choices) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.delta) === null || _c === void 0 ? void 0 : _c.content) || ((_f = (_e2 = (_d = chunk === null || chunk === void 0 ? void 0 : chunk.choices) === null || _d === void 0 ? void 0 : _d[0]) === null || _e2 === void 0 ? void 0 : _e2.delta) === null || _f === void 0 ? void 0 : _f.tool_calls)))
                  return;
                var newChoices = chunk.choices.map(function(choice) {
                  var message = Object.assign(choice.delta, { role: "assistant" });
                  if (isToolCall == null)
                    isToolCall = isToolCallAssistantMessage(message);
                  if (isToolCall) {
                    return __assign$d(__assign$d({}, choice), { finish_reason: "tool_calls", delta: message });
                  }
                  return __assign$d(__assign$d({}, choice), { delta: message });
                });
                var newChunk = __assign$d(__assign$d({}, chunk), { choices: newChoices });
                controller.enqueue(__assign$d(__assign$d({}, newChunk), { rawResponse: chunk }));
              }
            }));
            return [2, createAsyncIterable(streamWithRaw)];
        }
      });
    });
  };
  return YiSimpleModel2;
}();
var __assign$c = function() {
  __assign$c = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$c.apply(this, arguments);
};
var __awaiter$9 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$9 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
function processInput$1(input) {
  var messages = input.messages, model = input.model, temperature = input.temperature, tools = input.tools, top_p = input.top_p;
  return __assign$c(__assign$c({}, input), { messages, model, tools, top_p, temperature });
}
var MoonshotSimpleModel = function() {
  function MoonshotSimpleModel2(req, baseUrl, subUrl) {
    this.req = req;
    this.baseUrl = baseUrl;
    this.subUrl = "moonshot/v1/chat/completions";
    if (subUrl != null) {
      this.subUrl = subUrl;
    }
  }
  Object.defineProperty(MoonshotSimpleModel2.prototype, "url", {
    get: function() {
      return "".concat(this.baseUrl, "/").concat(this.subUrl);
    },
    enumerable: false,
    configurable: true
  });
  MoonshotSimpleModel2.prototype.doGenerate = function(data) {
    return __awaiter$9(this, void 0, void 0, function() {
      var res;
      return __generator$9(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              url: this.url,
              data: __assign$c(__assign$c({}, processInput$1(data)), { stream: false }),
              stream: false
            })];
          case 1:
            res = _a2.sent();
            return [2, __assign$c(__assign$c({}, res), { rawResponse: res })];
        }
      });
    });
  };
  MoonshotSimpleModel2.prototype.doStream = function(data) {
    return __awaiter$9(this, void 0, void 0, function() {
      var isToolCall, _stream, stream, arkStream, streamWithRaw;
      return __generator$9(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isToolCall = null;
            return [4, this.req({
              url: this.url,
              data: __assign$c(__assign$c({}, processInput$1(data)), { stream: true }),
              stream: true
            })];
          case 1:
            _stream = _a2.sent();
            stream = toPolyfillReadable(_stream);
            arkStream = intoStandardStream(stream);
            streamWithRaw = arkStream.pipeThrough(new TransformStream2({
              transform: function(chunk, controller) {
                var newChoices = chunk.choices.map(function(choice) {
                  var message = choice.delta;
                  if (isToolCall == null)
                    isToolCall = isToolCallAssistantMessage(message);
                  if (isToolCall) {
                    return __assign$c(__assign$c({}, choice), { finish_reason: "tool_calls", delta: message });
                  }
                  return choice;
                });
                var newChunk = __assign$c(__assign$c({}, chunk), { choices: newChoices });
                controller.enqueue(__assign$c(__assign$c({}, newChunk), { rawResponse: chunk }));
              }
            }));
            return [2, createAsyncIterable(streamWithRaw)];
        }
      });
    });
  };
  return MoonshotSimpleModel2;
}();
var __assign$b = function() {
  __assign$b = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$b.apply(this, arguments);
};
var __awaiter$8 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$8 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var HunYuanExpSimpleModel = function() {
  function HunYuanExpSimpleModel2(req, baseUrl, subUrl) {
    this.req = req;
    this.baseUrl = baseUrl;
    this.subUrl = "hunyuan-exp/v1/chat/completions";
    if (subUrl != null) {
      this.subUrl = subUrl;
    }
  }
  Object.defineProperty(HunYuanExpSimpleModel2.prototype, "url", {
    get: function() {
      return "".concat(this.baseUrl, "/").concat(this.subUrl);
    },
    enumerable: false,
    configurable: true
  });
  HunYuanExpSimpleModel2.prototype.doGenerate = function(data) {
    return __awaiter$8(this, void 0, void 0, function() {
      var res;
      return __generator$8(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              url: this.url,
              data: __assign$b(__assign$b({}, processInput$5(data)), { stream: false }),
              stream: false
            })];
          case 1:
            res = _a2.sent();
            return [2, __assign$b(__assign$b({}, res), { rawResponse: res })];
        }
      });
    });
  };
  HunYuanExpSimpleModel2.prototype.doStream = function(data) {
    return __awaiter$8(this, void 0, void 0, function() {
      var isToolCall, _stream, stream, hunyuanBetaStream, streamWithRaw;
      return __generator$8(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isToolCall = null;
            return [4, this.req({
              url: this.url,
              data: __assign$b(__assign$b({}, processInput$5(data)), { stream: true }),
              stream: true
            })];
          case 1:
            _stream = _a2.sent();
            stream = toPolyfillReadable(_stream);
            hunyuanBetaStream = intoStandardStream(stream);
            streamWithRaw = hunyuanBetaStream.pipeThrough(new TransformStream2({
              transform: function(chunk, controller) {
                var newChoices = chunk.choices.map(function(choice) {
                  var message = choice.delta;
                  if (isToolCall == null)
                    isToolCall = isToolCallAssistantMessage(message);
                  if (isToolCall) {
                    return __assign$b(__assign$b({}, choice), { finish_reason: "tool_calls", delta: message });
                  }
                  return choice;
                });
                var newChunk = __assign$b(__assign$b({}, chunk), { choices: newChoices });
                controller.enqueue(__assign$b(__assign$b({}, newChunk), { rawResponse: chunk }));
              }
            }));
            return [2, createAsyncIterable(streamWithRaw)];
        }
      });
    });
  };
  return HunYuanExpSimpleModel2;
}();
var __assign$a = function() {
  __assign$a = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$a.apply(this, arguments);
};
var __awaiter$7 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$7 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var HunYuanOpenSimpleModel = function() {
  function HunYuanOpenSimpleModel2(req, baseUrl, subUrl) {
    this.req = req;
    this.baseUrl = baseUrl;
    this.subUrl = "hunyuan-open/v1/chat/completions";
    if (subUrl != null) {
      this.subUrl = subUrl;
    }
  }
  Object.defineProperty(HunYuanOpenSimpleModel2.prototype, "url", {
    get: function() {
      return "".concat(this.baseUrl, "/").concat(this.subUrl);
    },
    enumerable: false,
    configurable: true
  });
  HunYuanOpenSimpleModel2.prototype.doGenerate = function(data) {
    return __awaiter$7(this, void 0, void 0, function() {
      var res;
      return __generator$7(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              url: this.url,
              data: __assign$a(__assign$a({}, processInput$5(data)), { stream: false }),
              stream: false
            })];
          case 1:
            res = _a2.sent();
            return [2, __assign$a(__assign$a({}, res), { rawResponse: res })];
        }
      });
    });
  };
  HunYuanOpenSimpleModel2.prototype.doStream = function(data) {
    return __awaiter$7(this, void 0, void 0, function() {
      var isToolCall, _stream, stream, hunyuanBetaStream, streamWithRaw;
      return __generator$7(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isToolCall = null;
            return [4, this.req({
              url: this.url,
              data: __assign$a(__assign$a({}, processInput$5(data)), { stream: true }),
              stream: true
            })];
          case 1:
            _stream = _a2.sent();
            stream = toPolyfillReadable(_stream);
            hunyuanBetaStream = intoStandardStream(stream);
            streamWithRaw = hunyuanBetaStream.pipeThrough(new TransformStream2({
              transform: function(chunk, controller) {
                var newChoices = chunk.choices.map(function(choice) {
                  var message = choice.delta;
                  if (isToolCall == null)
                    isToolCall = isToolCallAssistantMessage(message);
                  if (isToolCall) {
                    return __assign$a(__assign$a({}, choice), { finish_reason: "tool_calls", delta: message });
                  }
                  return choice;
                });
                var newChunk = __assign$a(__assign$a({}, chunk), { choices: newChoices });
                controller.enqueue(__assign$a(__assign$a({}, newChunk), { rawResponse: chunk }));
              }
            }));
            return [2, createAsyncIterable(streamWithRaw)];
        }
      });
    });
  };
  return HunYuanOpenSimpleModel2;
}();
var __assign$9 = function() {
  __assign$9 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$9.apply(this, arguments);
};
var __awaiter$6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$6 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var DeepSeekSimpleModel = function() {
  function DeepSeekSimpleModel2(req, baseUrl, subUrl) {
    this.req = req;
    this.baseUrl = baseUrl;
    this.subUrl = "deepseek/v1/chat/completions";
    if (subUrl != null) {
      this.subUrl = subUrl;
    }
  }
  Object.defineProperty(DeepSeekSimpleModel2.prototype, "url", {
    get: function() {
      return "".concat(this.baseUrl, "/").concat(this.subUrl);
    },
    enumerable: false,
    configurable: true
  });
  DeepSeekSimpleModel2.prototype.doGenerate = function(data) {
    return __awaiter$6(this, void 0, void 0, function() {
      var res;
      return __generator$6(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.req({
              url: this.url,
              data: __assign$9(__assign$9({}, data), { stream: false }),
              stream: false
            })];
          case 1:
            res = _a2.sent();
            return [2, __assign$9(__assign$9({}, res), { rawResponse: res })];
        }
      });
    });
  };
  DeepSeekSimpleModel2.prototype.doStream = function(data) {
    return __awaiter$6(this, void 0, void 0, function() {
      var isToolCall, _stream, stream, standardStream, streamWithRaw;
      return __generator$6(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isToolCall = null;
            return [4, this.req({
              url: this.url,
              data: __assign$9(__assign$9({}, data), { stream: true }),
              stream: true
            })];
          case 1:
            _stream = _a2.sent();
            stream = toPolyfillReadable(_stream);
            standardStream = intoStandardStream(stream);
            streamWithRaw = standardStream.pipeThrough(new TransformStream2({
              transform: function(chunk, controller) {
                var newChoices = chunk.choices.map(function(choice) {
                  var message = choice.delta;
                  if (isToolCall == null)
                    isToolCall = isToolCallAssistantMessage(message);
                  if (isToolCall) {
                    return __assign$9(__assign$9({}, choice), { finish_reason: "tool_calls", delta: message });
                  }
                  return choice;
                });
                var newChunk = __assign$9(__assign$9({}, chunk), { choices: newChoices });
                controller.enqueue(__assign$9(__assign$9({}, newChunk), { rawResponse: chunk }));
              }
            }));
            return [2, createAsyncIterable(streamWithRaw)];
        }
      });
    });
  };
  return DeepSeekSimpleModel2;
}();
var __assign$8 = function() {
  __assign$8 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$8.apply(this, arguments);
};
var __awaiter$5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$5 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest$1 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
var __asyncValues = function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o2[n2](v2), settle3(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle3(resolve2, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve2({ value: v3, done: d2 });
    }, reject);
  }
};
var __spreadArray = function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar2; i < l2; i++) {
      if (ar2 || !(i in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i);
        ar2[i] = from[i];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
function processInput(obj) {
  var _a2;
  var onStepFinish = obj.onStepFinish, abortSignal = obj.abortSignal, maxSteps = obj.maxSteps, topP = obj.topP, toolChoice = obj.toolChoice, b2 = __rest$1(obj, ["onStepFinish", "abortSignal", "maxSteps", "topP", "toolChoice"]);
  if (maxSteps != null && maxSteps < 1) {
    throw new Error("`maxSteps` muse be greater than 0.");
  }
  return [
    { onStepFinish, abortSignal, maxSteps },
    __assign$8(__assign$8({}, b2), { tools: (_a2 = b2.tools) === null || _a2 === void 0 ? void 0 : _a2.map(function(tool) {
      if ("fn" in tool) {
        return functionToolToModelTool(tool);
      }
      return tool;
    }), top_p: topP != null ? topP : b2.top_p, tool_choice: toolChoice != null ? toolChoice : b2.tool_choice })
  ];
}
var ReactModel = function() {
  function ReactModel2(model) {
    this.model = model;
  }
  ReactModel2.prototype.generateText = function(_input) {
    var _a2, _b;
    return __awaiter$5(this, void 0, void 0, function() {
      var rawResponses, totalUsage, _c, _d, onStepFinish, _e2, maxSteps, input, doGenerate, currentRes, currentStep, toolCall, stepUsage_1, toolCallResult, choice, e_1, lastChoice, lastMessage, text, messages, stepUsage;
      var _this = this;
      return __generator$5(this, function(_f) {
        switch (_f.label) {
          case 0:
            rawResponses = [];
            totalUsage = { completion_tokens: 0, prompt_tokens: 0, total_tokens: 0 };
            _c = processInput(_input), _d = _c[0], onStepFinish = _d.onStepFinish, _e2 = _d.maxSteps, maxSteps = _e2 === void 0 ? 10 : _e2, input = _c[1];
            doGenerate = function() {
              return _this.model.doGenerate(input);
            };
            return [4, doGenerate()];
          case 1:
            currentRes = _f.sent();
            currentStep = 1;
            currentRes.rawResponse && rawResponses.push(currentRes.rawResponse);
            toolCall = null;
            _f.label = 2;
          case 2:
            if (!(currentStep < maxSteps && (toolCall = getToolCallFromGenerate(currentRes)) != null))
              return [3, 9];
            stepUsage_1 = createSolidUsage(currentRes.usage);
            addToUsage(totalUsage, stepUsage_1);
            _f.label = 3;
          case 3:
            _f.trys.push([3, 7, , 8]);
            return [4, callTool(toolCall)];
          case 4:
            toolCallResult = _f.sent();
            choice = currentRes.choices[0];
            return [4, onStepFinish === null || onStepFinish === void 0 ? void 0 : onStepFinish({
              finishReason: choice.finish_reason,
              messages: input.messages.slice(),
              text: choice.message.content,
              toolCall,
              toolResult: toolCallResult,
              stepUsage: stepUsage_1,
              totalUsage: Object.assign({}, totalUsage)
            })];
          case 5:
            _f.sent();
            pushNewMessages(input.messages, choice.message, toolCallResult);
            return [4, doGenerate()];
          case 6:
            currentRes = _f.sent();
            currentRes.rawResponse && rawResponses.push(currentRes.rawResponse);
            currentStep += 1;
            return [3, 8];
          case 7:
            e_1 = _f.sent();
            return [2, {
              text: "",
              messages: input.messages,
              usage: totalUsage,
              error: e_1,
              rawResponses
            }];
          case 8:
            return [3, 2];
          case 9:
            lastChoice = (_a2 = currentRes === null || currentRes === void 0 ? void 0 : currentRes.choices) === null || _a2 === void 0 ? void 0 : _a2[0];
            lastMessage = lastChoice === null || lastChoice === void 0 ? void 0 : lastChoice.message;
            text = (_b = lastMessage === null || lastMessage === void 0 ? void 0 : lastMessage.content) !== null && _b !== void 0 ? _b : "";
            messages = lastMessage ? __spreadArray(__spreadArray([], input.messages, true), [lastMessage], false) : input.messages;
            stepUsage = createSolidUsage(currentRes.usage);
            addToUsage(totalUsage, stepUsage);
            return [4, onStepFinish === null || onStepFinish === void 0 ? void 0 : onStepFinish({
              finishReason: lastChoice.finish_reason,
              messages: messages.slice(),
              text,
              toolCall: getToolCallFromGenerate(currentRes),
              toolResult: null,
              stepUsage,
              totalUsage: Object.assign({}, totalUsage)
            })];
          case 10:
            _f.sent();
            return [2, {
              text,
              messages,
              usage: totalUsage,
              rawResponses
            }];
        }
      });
    });
  };
  ReactModel2.prototype.streamText = function(_input) {
    var _a2;
    return __awaiter$5(this, void 0, void 0, function() {
      var totalUsage, _b, _c, onStepFinish, _d, maxSteps, input, doStream, currentRes, currentStep, readResult, readCurrentStream, _e2, assistantMessage, stepUsage_2, toolCall, toolCallResult, e_2, _f, s1_1, s2_1, message_1, usage, messages, _g, s1_2, s2_2, messagePromise, usagePromise, message, finishReason, stepUsage, originStream, _h, s1, s2;
      var _this = this;
      return __generator$5(this, function(_j) {
        switch (_j.label) {
          case 0:
            totalUsage = { completion_tokens: 0, prompt_tokens: 0, total_tokens: 0 };
            _b = processInput(_input), _c = _b[0], onStepFinish = _c.onStepFinish, _d = _c.maxSteps, maxSteps = _d === void 0 ? 10 : _d, input = _b[1];
            doStream = function() {
              return _this.model.doStream(input);
            };
            return [4, doStream()];
          case 1:
            currentRes = _j.sent();
            currentStep = 1;
            readResult = null;
            readCurrentStream = function() {
              var _a3 = currentRes.tee(), oldStream = _a3[0], newStream = _a3[1];
              currentRes = createAsyncIterable(oldStream);
              return readFunctionCallStream(newStream);
            };
            _j.label = 2;
          case 2:
            _e2 = currentStep < maxSteps;
            if (!_e2)
              return [3, 4];
            return [4, readCurrentStream()];
          case 3:
            _e2 = (readResult = _j.sent()) != null;
            _j.label = 4;
          case 4:
            if (!_e2)
              return [3, 11];
            assistantMessage = readResult.message, stepUsage_2 = readResult.usage;
            addToUsage(totalUsage, stepUsage_2);
            toolCall = (_a2 = assistantMessage.tool_calls) === null || _a2 === void 0 ? void 0 : _a2[0];
            _j.label = 5;
          case 5:
            _j.trys.push([5, 9, , 10]);
            return [4, callTool(toolCall)];
          case 6:
            toolCallResult = _j.sent();
            return [4, onStepFinish === null || onStepFinish === void 0 ? void 0 : onStepFinish({
              finishReason: "tool_calls",
              messages: input.messages.slice(),
              text: assistantMessage.content,
              toolCall,
              toolResult: toolCallResult,
              stepUsage: stepUsage_2,
              totalUsage: Object.assign({}, totalUsage)
            })];
          case 7:
            _j.sent();
            pushNewMessages(input.messages, assistantMessage, toolCallResult);
            return [4, doStream()];
          case 8:
            currentRes = _j.sent();
            return [3, 10];
          case 9:
            e_2 = _j.sent();
            _f = currentRes.tee(), s1_1 = _f[0], s2_1 = _f[1];
            return [2, {
              messages: Promise.resolve(input.messages),
              dataStream: createAsyncIterable(s1_1),
              textStream: createAsyncIterable(s2_1.pipeThrough(new TransformStream2({
                transform: function(chunk, controller) {
                  var _a3, _b2, _c2;
                  var str = (_c2 = (_b2 = (_a3 = chunk === null || chunk === void 0 ? void 0 : chunk.choices) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b2 === void 0 ? void 0 : _b2.delta) === null || _c2 === void 0 ? void 0 : _c2.content;
                  if (typeof str === "string")
                    controller.enqueue(str);
                }
              }))),
              usage: Promise.resolve(totalUsage),
              error: e_2
            }];
          case 10:
            return [3, 2];
          case 11:
            return [4, readCurrentStream()];
          case 12:
            readResult = _j.sent();
            if (readResult) {
              message_1 = readResult.message, usage = readResult.usage;
              addToUsage(totalUsage, usage);
              messages = __spreadArray(__spreadArray([], input.messages, true), [message_1], false);
              onStepFinish({
                messages: messages.slice(),
                finishReason: "tool_call",
                stepUsage: usage,
                text: message_1.content,
                toolCall: message_1.tool_calls[0],
                totalUsage: Object.assign({}, totalUsage)
              });
              _g = currentRes.tee(), s1_2 = _g[0], s2_2 = _g[1];
              return [2, {
                messages: Promise.resolve(__spreadArray(__spreadArray([], input.messages, true), [message_1], false)),
                dataStream: createAsyncIterable(s1_2),
                textStream: createAsyncIterable(s2_2.pipeThrough(new TransformStream2({
                  transform: function(chunk, controller) {
                    var _a3, _b2, _c2;
                    var str = (_c2 = (_b2 = (_a3 = chunk === null || chunk === void 0 ? void 0 : chunk.choices) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b2 === void 0 ? void 0 : _b2.delta) === null || _c2 === void 0 ? void 0 : _c2.content;
                    if (typeof str === "string")
                      controller.enqueue(str);
                  }
                }))),
                usage: Promise.resolve(totalUsage)
              }];
            }
            messagePromise = createPromise();
            usagePromise = createPromise();
            message = {
              role: "assistant",
              content: ""
            };
            finishReason = "";
            stepUsage = { completion_tokens: 0, prompt_tokens: 0, total_tokens: 0 };
            originStream = currentRes.pipeThrough(new TransformStream2({
              transform: function(chunk, controller) {
                var _a3, _b2, _c2, _d2, _e3, _f2, _g2, _h2;
                var content = (_c2 = (_b2 = (_a3 = chunk === null || chunk === void 0 ? void 0 : chunk.choices) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b2 === void 0 ? void 0 : _b2.delta) === null || _c2 === void 0 ? void 0 : _c2.content;
                if (typeof content === "string") {
                  message.content += content;
                }
                var reason = (_e3 = (_d2 = chunk === null || chunk === void 0 ? void 0 : chunk.choices) === null || _d2 === void 0 ? void 0 : _d2[0]) === null || _e3 === void 0 ? void 0 : _e3.finish_reason;
                if (reason)
                  finishReason = reason;
                if ((_f2 = chunk === null || chunk === void 0 ? void 0 : chunk.usage) === null || _f2 === void 0 ? void 0 : _f2.completion_tokens)
                  stepUsage.completion_tokens = chunk.usage.completion_tokens;
                if ((_g2 = chunk === null || chunk === void 0 ? void 0 : chunk.usage) === null || _g2 === void 0 ? void 0 : _g2.prompt_tokens)
                  stepUsage.prompt_tokens = chunk.usage.prompt_tokens;
                if ((_h2 = chunk === null || chunk === void 0 ? void 0 : chunk.usage) === null || _h2 === void 0 ? void 0 : _h2.total_tokens)
                  stepUsage.total_tokens = chunk.usage.total_tokens;
                controller.enqueue(chunk);
              },
              flush: function() {
                messagePromise.res(__spreadArray(__spreadArray([], input.messages, true), [message], false));
                addToUsage(totalUsage, stepUsage);
                usagePromise.res(Object.assign({}, totalUsage));
                onStepFinish === null || onStepFinish === void 0 ? void 0 : onStepFinish({
                  messages: __spreadArray(__spreadArray([], input.messages, true), [message], false),
                  finishReason,
                  text: message.content,
                  stepUsage,
                  totalUsage: Object.assign({}, totalUsage)
                });
              }
            }));
            _h = originStream.tee(), s1 = _h[0], s2 = _h[1];
            return [2, {
              messages: messagePromise.promise,
              dataStream: createAsyncIterable(s1),
              textStream: createAsyncIterable(s2.pipeThrough(new TransformStream2({
                transform: function(chunk, controller) {
                  var _a3, _b2, _c2;
                  var content = (_c2 = (_b2 = (_a3 = chunk === null || chunk === void 0 ? void 0 : chunk.choices) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b2 === void 0 ? void 0 : _b2.delta) === null || _c2 === void 0 ? void 0 : _c2.content;
                  if (typeof content === "string") {
                    controller.enqueue(content);
                  }
                }
              }))),
              usage: usagePromise.promise
            }];
        }
      });
    });
  };
  return ReactModel2;
}();
function getToolCallFromGenerate(output) {
  var _a2;
  var choice = (_a2 = output === null || output === void 0 ? void 0 : output.choices) === null || _a2 === void 0 ? void 0 : _a2[0];
  if (!choice)
    return null;
  var finish_reason = choice.finish_reason, message = choice.message;
  if (finish_reason !== "tool_calls")
    return null;
  if (!message)
    return null;
  if (!isToolCallAssistantMessage(message))
    return null;
  return message.tool_calls[0];
}
function pushNewMessages(messages, assistantMessage, toolCallResult) {
  messages.push(assistantMessage, {
    role: "tool",
    tool_call_id: assistantMessage.tool_calls[0].id,
    content: JSON.stringify(toolCallResult)
  });
}
function readFunctionCallStream(stream) {
  var _a2, e_3, _b, _c;
  var _d, _e2, _f, _g, _h, _j;
  return __awaiter$5(this, void 0, void 0, function() {
    var stepUsage, aStream, retToolCall, retMessage, _k, aStream_1, aStream_1_1, chunk, choice, finish_reason, delta, toolCall, e_3_1;
    return __generator$5(this, function(_l) {
      switch (_l.label) {
        case 0:
          stepUsage = { completion_tokens: 0, prompt_tokens: 0, total_tokens: 0 };
          aStream = createAsyncIterable(stream);
          retToolCall = {
            id: "",
            function: {
              name: "",
              arguments: ""
            },
            type: ""
          };
          retMessage = {
            role: "assistant",
            content: "",
            tool_calls: [retToolCall]
          };
          _l.label = 1;
        case 1:
          _l.trys.push([1, 6, 7, 12]);
          _k = true, aStream_1 = __asyncValues(aStream);
          _l.label = 2;
        case 2:
          return [4, aStream_1.next()];
        case 3:
          if (!(aStream_1_1 = _l.sent(), _a2 = aStream_1_1.done, !_a2))
            return [3, 5];
          _c = aStream_1_1.value;
          _k = false;
          try {
            chunk = _c;
            choice = chunk === null || chunk === void 0 ? void 0 : chunk.choices[0];
            if (!choice)
              return [2, null];
            finish_reason = choice.finish_reason, delta = choice.delta;
            if (finish_reason !== "tool_calls")
              return [2, null];
            if (!delta)
              return [3, 4];
            if (delta.content)
              retMessage.content += delta.content;
            if (!("tool_calls" in delta))
              return [3, 4];
            toolCall = (_d = delta === null || delta === void 0 ? void 0 : delta.tool_calls) === null || _d === void 0 ? void 0 : _d[0];
            if (toolCall === null || toolCall === void 0 ? void 0 : toolCall.id)
              retToolCall.id = toolCall.id;
            if (toolCall === null || toolCall === void 0 ? void 0 : toolCall.type)
              retToolCall.type = toolCall.type;
            if ((_e2 = toolCall === null || toolCall === void 0 ? void 0 : toolCall.function) === null || _e2 === void 0 ? void 0 : _e2.name)
              retToolCall.function.name = toolCall.function.name;
            if ((_f = toolCall === null || toolCall === void 0 ? void 0 : toolCall.function) === null || _f === void 0 ? void 0 : _f.arguments)
              retToolCall.function.arguments += toolCall.function.arguments;
            if ((_g = chunk === null || chunk === void 0 ? void 0 : chunk.usage) === null || _g === void 0 ? void 0 : _g.completion_tokens)
              stepUsage.completion_tokens = chunk.usage.completion_tokens;
            if ((_h = chunk === null || chunk === void 0 ? void 0 : chunk.usage) === null || _h === void 0 ? void 0 : _h.prompt_tokens)
              stepUsage.prompt_tokens = chunk.usage.prompt_tokens;
            if ((_j = chunk === null || chunk === void 0 ? void 0 : chunk.usage) === null || _j === void 0 ? void 0 : _j.total_tokens)
              stepUsage.total_tokens = chunk.usage.total_tokens;
          } finally {
            _k = true;
          }
          _l.label = 4;
        case 4:
          return [3, 2];
        case 5:
          return [3, 12];
        case 6:
          e_3_1 = _l.sent();
          e_3 = { error: e_3_1 };
          return [3, 12];
        case 7:
          _l.trys.push([7, , 10, 11]);
          if (!(!_k && !_a2 && (_b = aStream_1.return)))
            return [3, 9];
          return [4, _b.call(aStream_1)];
        case 8:
          _l.sent();
          _l.label = 9;
        case 9:
          return [3, 11];
        case 10:
          if (e_3)
            throw e_3.error;
          return [7];
        case 11:
          return [7];
        case 12:
          return [2, {
            message: retMessage,
            usage: stepUsage
          }];
      }
    });
  });
}
var toolMap = /* @__PURE__ */ new Map();
function callTool(toolCall) {
  return toolMap.get(toolCall.function.name)(JSON.parse(toolCall.function.arguments));
}
function createSolidUsage(usage) {
  var _a2, _b, _c;
  return {
    completion_tokens: (_a2 = usage === null || usage === void 0 ? void 0 : usage.completion_tokens) !== null && _a2 !== void 0 ? _a2 : 0,
    prompt_tokens: (_b = usage === null || usage === void 0 ? void 0 : usage.prompt_tokens) !== null && _b !== void 0 ? _b : 0,
    total_tokens: (_c = usage === null || usage === void 0 ? void 0 : usage.total_tokens) !== null && _c !== void 0 ? _c : 0
  };
}
function addToUsage(targetUsage, sourceUsage) {
  targetUsage.completion_tokens += sourceUsage.completion_tokens;
  targetUsage.prompt_tokens += sourceUsage.prompt_tokens;
  targetUsage.total_tokens += sourceUsage.total_tokens;
}
var MODELS$1 = {
  hunyuan: HunYuanSimpleModel,
  "hunyuan-beta": HunYuanBetaSimpleModel,
  ark: ArkSimpleModel,
  dashscope: DSSimpleModel,
  "01-ai": YiSimpleModel,
  moonshot: MoonshotSimpleModel,
  zhipu: ZhiPuSimpleModel,
  "hunyuan-exp": HunYuanExpSimpleModel,
  "hunyuan-open": HunYuanOpenSimpleModel,
  deepseek: DeepSeekSimpleModel
};
const models = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArkSimpleModel,
  DSSimpleModel,
  HunYuanBetaSimpleModel,
  HunYuanExpSimpleModel,
  HunYuanOpenSimpleModel,
  HunYuanSimpleModel,
  MODELS: MODELS$1,
  MoonshotSimpleModel,
  ReactModel,
  YiSimpleModel,
  ZhiPuSimpleModel,
  toolMap
}, Symbol.toStringTag, { value: "Module" }));
var __assign$7 = function() {
  __assign$7 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$7.apply(this, arguments);
};
var __awaiter$4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$4 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var MODELS = MODELS$1;
var AI = function() {
  function AI2(req, baseUrl) {
    var _this = this;
    this.req = req;
    this.baseUrl = baseUrl;
    this.modelRequest = function(_a2) {
      var url = _a2.url, data = _a2.data, headers = _a2.headers, stream = _a2.stream;
      return __awaiter$4(_this, void 0, void 0, function() {
        var fetchHeaders, _b, responseData, header;
        return __generator$4(this, function(_c) {
          switch (_c.label) {
            case 0:
              fetchHeaders = {
                "Content-Type": "application/json"
              };
              stream && Object.assign(fetchHeaders, { Accept: "text/event-stream" });
              return [4, this.req.fetch({
                method: "post",
                headers: __assign$7(__assign$7({}, fetchHeaders), headers),
                body: JSON.stringify(data),
                url,
                stream
              })];
            case 1:
              _b = _c.sent(), responseData = _b.data, header = _b.header;
              return [2, handleResponseData(responseData, header)];
          }
        });
      });
    };
    this.botRequest = function(_a2) {
      var method = _a2.method, url = _a2.url, _b = _a2.data, data = _b === void 0 ? {} : _b, headers = _a2.headers, stream = _a2.stream;
      return __awaiter$4(_this, void 0, void 0, function() {
        function objectToParam(obj) {
          return Object.entries(obj).map(function(_a3) {
            var key = _a3[0], value = _a3[1];
            return "".concat(key, "=").concat(value);
          }).join("&");
        }
        var _c, fetchHeaders, _d, responseData, header;
        return __generator$4(this, function(_e2) {
          switch (_e2.label) {
            case 0:
              if (!(method === "get"))
                return [3, 2];
              _c = handleResponseData;
              return [4, this.req.fetch({ url: "".concat(url, "?").concat(objectToParam(data)), method, headers, stream })];
            case 1:
              return [2, _c.apply(void 0, [_e2.sent().data])];
            case 2:
              fetchHeaders = {
                "Content-Type": "application/json"
              };
              stream && Object.assign(fetchHeaders, { Accept: "text/event-stream" });
              return [4, this.req.fetch({
                url,
                body: JSON.stringify(data),
                headers: __assign$7(__assign$7({}, fetchHeaders), headers),
                stream,
                method
              })];
            case 3:
              _d = _e2.sent(), responseData = _d.data, header = _d.header;
              return [2, handleResponseData(responseData, header)];
          }
        });
      });
    };
    this.aiBaseUrl = "".concat(baseUrl, "/ai");
    this.aiBotBaseUrl = "".concat(baseUrl, "/aibot");
    this.bot = new Bot(this.botRequest, this.aiBotBaseUrl);
  }
  AI2.prototype.createModel = function(model) {
    var SimpleModelConstructor = MODELS[model];
    var simpleModel = new SimpleModelConstructor(this.modelRequest, this.aiBaseUrl);
    var reactModel = new ReactModel(simpleModel);
    return reactModel;
  };
  AI2.prototype.registerModel = function(name2, model) {
    if (MODELS[name2] != null) {
      console.warn("AI model ".concat(name2, " already exists!"));
      return;
    }
    MODELS[name2] = model;
  };
  AI2.prototype.registerFunctionTool = function(functionTool) {
    if (toolMap.has(functionTool.name)) {
      console.warn("AI function tool ".concat(functionTool.name, " already exists and will be overwritten!"));
    }
    toolMap.set(functionTool.name, functionTool.fn);
  };
  return AI2;
}();
var GO_TO_AI_TEXT = "请检查调用方式，或前往云开发 AI+ 首页查看文档：https://tcb.cloud.tencent.com/dev#/ai";
function handleResponseData(responseData, header) {
  var _a2, _b;
  return __awaiter$4(this, void 0, void 0, function() {
    var json, json;
    return __generator$4(this, function(_c) {
      switch (_c.label) {
        case 0:
          if (!("then" in responseData))
            return [3, 2];
          return [4, responseData];
        case 1:
          json = _c.sent();
          if ("code" in json && json.code !== "NORMAL") {
            throw new Error("AI+ 请求出错，错误码：".concat(json.code, "，错误信息：").concat(json.message, "\n").concat(GO_TO_AI_TEXT, "\n").concat(JSON.stringify(json, null, 2)));
          }
          return [2, responseData];
        case 2:
          if (!((_b = (_a2 = header === null || header === void 0 ? void 0 : header.get) === null || _a2 === void 0 ? void 0 : _a2.call(header, "content-type")) === null || _b === void 0 ? void 0 : _b.includes("application/json")))
            return [3, 4];
          return [4, readableStream2JsonObject(responseData)];
        case 3:
          json = _c.sent();
          if ("code" in json && json.code !== "NORMAL") {
            throw new Error("AI+ 请求出错，错误码：".concat(json.code, "，错误信息：").concat(json.message, "\n").concat(GO_TO_AI_TEXT, "\n").concat(JSON.stringify(json, null, 2)));
          }
          _c.label = 4;
        case 4:
          return [2, responseData];
      }
    });
  });
}
var __assign$6 = function() {
  __assign$6 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$6.apply(this, arguments);
};
var __awaiter$3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$3 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
var COMPONENT_NAME$1 = "ai";
__rest(models, ["MODELS"]);
var createRequestInstanceWithAccessTokenHeader = function(_a2) {
  var getAccessToken = _a2.getAccessToken, req = _a2.req;
  var fetch2 = function(options) {
    return __awaiter$3(void 0, void 0, void 0, function() {
      var token, _a3, headers, restOptions, accessToken;
      return __generator$3(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (typeof req.fetch !== "function") {
              throw new Error("req.fetch is not a function");
            }
            token = options.token, _a3 = options.headers, headers = _a3 === void 0 ? {} : _a3, restOptions = __rest(options, ["token", "headers"]);
            if (!(token != null))
              return [3, 1];
            accessToken = token;
            return [3, 3];
          case 1:
            return [4, getAccessToken()];
          case 2:
            accessToken = _b.sent().accessToken;
            _b.label = 3;
          case 3:
            return [2, req.fetch(__assign$6({ headers: __assign$6({ Authorization: "Bearer ".concat(accessToken) }, headers) }, restOptions))];
        }
      });
    });
  };
  return {
    download: req.download,
    post: req.post,
    upload: req.upload,
    fetch: fetch2
  };
};
function createAi(_a2) {
  var env = _a2.env, baseUrl = _a2.baseUrl, req = _a2.req, getAccessToken = _a2.getAccessToken, handleReqInstance = _a2.handleReqInstance;
  var getBaseUrl = function() {
    if (baseUrl != null) {
      return baseUrl;
    }
    if (env == null) {
      throw new Error("`env` is required when `baseUrl` is not provided!");
    }
    return "https://".concat(env, ".api.tcloudbasegateway.com/v1");
  };
  var getReq = function() {
    if (handleReqInstance == null) {
      if (getAccessToken == null) {
        throw new Error("`getAccessToken` is required when `handleReqInstance` is not provided!");
      }
      return createRequestInstanceWithAccessTokenHeader({ req, getAccessToken });
    }
    return handleReqInstance({ req });
  };
  return new AI(getReq(), getBaseUrl());
}
function ai(options) {
  var _this = this;
  var _a2;
  var req = this.request;
  if (req.fetch == null) {
    throw new Error("cloudbase.request.fetch() unimplemented!");
  }
  var getUrlFromCloud = function() {
    var _a3 = _this.getEndPointWithKey("GATEWAY"), BASE_URL = _a3.BASE_URL, PROTOCOL2 = _a3.PROTOCOL;
    return "".concat(PROTOCOL2).concat(BASE_URL);
  };
  var baseUrl = (_a2 = options === null || options === void 0 ? void 0 : options.baseUrl) !== null && _a2 !== void 0 ? _a2 : getUrlFromCloud();
  return createAi({ req, baseUrl, handleReqInstance: function(_a3) {
    var req2 = _a3.req;
    return req2;
  } });
}
var component$1 = {
  name: COMPONENT_NAME$1,
  entity: { ai }
};
function registerAi(app) {
  try {
    app.registerComponent(component$1);
  } catch (e2) {
    console.warn(e2);
  }
}
var _a;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["DocIDError"] = "文档ID不合法";
  ErrorCode2["CollNameError"] = "集合名称不合法";
  ErrorCode2["OpStrError"] = "操作符不合法";
  ErrorCode2["DirectionError"] = "排序字符不合法";
  ErrorCode2["IntergerError"] = "must be integer";
  ErrorCode2["QueryParamTypeError"] = "查询参数必须为对象";
  ErrorCode2["QueryParamValueError"] = "查询参数对象值不能均为undefined";
})(ErrorCode || (ErrorCode = {}));
var FieldType = {
  String: "String",
  Number: "Number",
  Object: "Object",
  Array: "Array",
  Boolean: "Boolean",
  Null: "Null",
  GeoPoint: "GeoPoint",
  GeoLineString: "GeoLineString",
  GeoPolygon: "GeoPolygon",
  GeoMultiPoint: "GeoMultiPoint",
  GeoMultiLineString: "GeoMultiLineString",
  GeoMultiPolygon: "GeoMultiPolygon",
  Timestamp: "Date",
  Command: "Command",
  ServerDate: "ServerDate",
  BsonDate: "BsonDate"
};
var OrderDirectionList = ["desc", "asc"];
var WhereFilterOpList = ["<", "<=", "==", ">=", ">"];
var Opeartor;
(function(Opeartor2) {
  Opeartor2["lt"] = "<";
  Opeartor2["gt"] = ">";
  Opeartor2["lte"] = "<=";
  Opeartor2["gte"] = ">=";
  Opeartor2["eq"] = "==";
})(Opeartor || (Opeartor = {}));
_a = {}, _a[Opeartor.eq] = "$eq", _a[Opeartor.lt] = "$lt", _a[Opeartor.lte] = "$lte", _a[Opeartor.gt] = "$gt", _a[Opeartor.gte] = "$gte", _a;
var QueryType;
(function(QueryType2) {
  QueryType2["WHERE"] = "WHERE";
  QueryType2["DOC"] = "DOC";
})(QueryType || (QueryType = {}));
var __extends$4 = /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var _symbols = [];
var __internalMark__ = {};
var HiddenSymbol = /* @__PURE__ */ function() {
  function HiddenSymbol2(target) {
    Object.defineProperties(this, {
      target: {
        enumerable: false,
        writable: false,
        configurable: false,
        value: target
      }
    });
  }
  return HiddenSymbol2;
}();
var InternalSymbol = function(_super) {
  __extends$4(InternalSymbol2, _super);
  function InternalSymbol2(target, __mark__) {
    var _this = this;
    if (__mark__ !== __internalMark__) {
      throw new TypeError("InternalSymbol cannot be constructed with new operator");
    }
    _this = _super.call(this, target) || this;
    return _this;
  }
  InternalSymbol2.for = function(target) {
    for (var i = 0, len = _symbols.length; i < len; i++) {
      if (_symbols[i].target === target) {
        return _symbols[i].instance;
      }
    }
    var symbol = new InternalSymbol2(target, __internalMark__);
    _symbols.push({
      target,
      instance: symbol
    });
    return symbol;
  };
  return InternalSymbol2;
}(HiddenSymbol);
var SYMBOL_UNSET_FIELD_NAME = InternalSymbol.for("UNSET_FIELD_NAME");
var SYMBOL_UPDATE_COMMAND = InternalSymbol.for("UPDATE_COMMAND");
var SYMBOL_QUERY_COMMAND = InternalSymbol.for("QUERY_COMMAND");
var SYMBOL_LOGIC_COMMAND = InternalSymbol.for("LOGIC_COMMAND");
var SYMBOL_GEO_POINT = InternalSymbol.for("GEO_POINT");
var SYMBOL_GEO_LINE_STRING = InternalSymbol.for("SYMBOL_GEO_LINE_STRING");
var SYMBOL_GEO_POLYGON = InternalSymbol.for("SYMBOL_GEO_POLYGON");
var SYMBOL_GEO_MULTI_POINT = InternalSymbol.for("SYMBOL_GEO_MULTI_POINT");
var SYMBOL_GEO_MULTI_LINE_STRING = InternalSymbol.for("SYMBOL_GEO_MULTI_LINE_STRING");
var SYMBOL_GEO_MULTI_POLYGON = InternalSymbol.for("SYMBOL_GEO_MULTI_POLYGON");
var SYMBOL_SERVER_DATE = InternalSymbol.for("SERVER_DATE");
var SYMBOL_REGEXP = InternalSymbol.for("REGEXP");
var ServerDate = function() {
  function ServerDate2(_a2) {
    var _b = (_a2 === void 0 ? {} : _a2).offset, offset = _b === void 0 ? 0 : _b;
    this.offset = offset;
  }
  Object.defineProperty(ServerDate2.prototype, "_internalType", {
    get: function() {
      return SYMBOL_SERVER_DATE;
    },
    enumerable: true,
    configurable: true
  });
  ServerDate2.prototype.parse = function() {
    return {
      $date: {
        offset: this.offset
      }
    };
  };
  return ServerDate2;
}();
function ServerDateConstructor(opt) {
  return new ServerDate(opt);
}
var __read$2 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar2;
};
var Util = function() {
  function Util2() {
  }
  Util2.formatResDocumentData = function(documents) {
    return documents.map(function(document2) {
      return Util2.formatField(document2);
    });
  };
  Util2.formatField = function(document2) {
    var keys = Object.keys(document2);
    var protoField = {};
    if (Array.isArray(document2)) {
      protoField = [];
    }
    keys.forEach(function(key) {
      var item = document2[key];
      var type = Util2.whichType(item);
      var realValue;
      switch (type) {
        case FieldType.GeoPoint:
          realValue = new Point(item.coordinates[0], item.coordinates[1]);
          break;
        case FieldType.GeoLineString:
          realValue = new LineString(item.coordinates.map(function(point) {
            return new Point(point[0], point[1]);
          }));
          break;
        case FieldType.GeoPolygon:
          realValue = new Polygon(item.coordinates.map(function(line) {
            return new LineString(line.map(function(_a2) {
              var _b = __read$2(_a2, 2), lng = _b[0], lat = _b[1];
              return new Point(lng, lat);
            }));
          }));
          break;
        case FieldType.GeoMultiPoint:
          realValue = new MultiPoint(item.coordinates.map(function(point) {
            return new Point(point[0], point[1]);
          }));
          break;
        case FieldType.GeoMultiLineString:
          realValue = new MultiLineString(item.coordinates.map(function(line) {
            return new LineString(line.map(function(_a2) {
              var _b = __read$2(_a2, 2), lng = _b[0], lat = _b[1];
              return new Point(lng, lat);
            }));
          }));
          break;
        case FieldType.GeoMultiPolygon:
          realValue = new MultiPolygon(item.coordinates.map(function(polygon) {
            return new Polygon(polygon.map(function(line) {
              return new LineString(line.map(function(_a2) {
                var _b = __read$2(_a2, 2), lng = _b[0], lat = _b[1];
                return new Point(lng, lat);
              }));
            }));
          }));
          break;
        case FieldType.Timestamp:
          realValue = new Date(item.$timestamp * 1e3);
          break;
        case FieldType.Object:
        case FieldType.Array:
          realValue = Util2.formatField(item);
          break;
        case FieldType.ServerDate:
          realValue = new Date(item.$date);
          break;
        default:
          realValue = item;
      }
      if (Array.isArray(protoField)) {
        protoField.push(realValue);
      } else {
        protoField[key] = realValue;
      }
    });
    return protoField;
  };
  Util2.whichType = function(obj) {
    var type = Object.prototype.toString.call(obj).slice(8, -1);
    if (type === FieldType.Timestamp) {
      return FieldType.BsonDate;
    }
    if (type === FieldType.Object) {
      if (obj instanceof Point) {
        return FieldType.GeoPoint;
      } else if (obj instanceof Date) {
        return FieldType.Timestamp;
      } else if (obj instanceof ServerDate) {
        return FieldType.ServerDate;
      }
      if (obj.$timestamp) {
        type = FieldType.Timestamp;
      } else if (obj.$date) {
        type = FieldType.ServerDate;
      } else if (Point.validate(obj)) {
        type = FieldType.GeoPoint;
      } else if (LineString.validate(obj)) {
        type = FieldType.GeoLineString;
      } else if (Polygon.validate(obj)) {
        type = FieldType.GeoPolygon;
      } else if (MultiPoint.validate(obj)) {
        type = FieldType.GeoMultiPoint;
      } else if (MultiLineString.validate(obj)) {
        type = FieldType.GeoMultiLineString;
      } else if (MultiPolygon.validate(obj)) {
        type = FieldType.GeoMultiPolygon;
      }
    }
    return type;
  };
  Util2.generateDocId = function() {
    var chars2 = "ABCDEFabcdef0123456789";
    var autoId = "";
    for (var i = 0; i < 24; i++) {
      autoId += chars2.charAt(Math.floor(Math.random() * chars2.length));
    }
    return autoId;
  };
  return Util2;
}();
var Validate = function() {
  function Validate2() {
  }
  Validate2.isGeopoint = function(point, degree) {
    if (Util.whichType(degree) !== FieldType.Number) {
      throw new Error("Geo Point must be number type");
    }
    var degreeAbs = Math.abs(degree);
    if (point === "latitude" && degreeAbs > 90) {
      throw new Error("latitude should be a number ranges from -90 to 90");
    } else if (point === "longitude" && degreeAbs > 180) {
      throw new Error("longitude should be a number ranges from -180 to 180");
    }
    return true;
  };
  Validate2.isInteger = function(param, num) {
    if (!Number.isInteger(num)) {
      throw new Error(param + ErrorCode.IntergerError);
    }
    return true;
  };
  Validate2.isFieldOrder = function(direction) {
    if (OrderDirectionList.indexOf(direction) === -1) {
      throw new Error(ErrorCode.DirectionError);
    }
    return true;
  };
  Validate2.isFieldPath = function(path) {
    if (!/^[a-zA-Z0-9-_\.]/.test(path)) {
      throw new Error();
    }
    return true;
  };
  Validate2.isOperator = function(op) {
    if (WhereFilterOpList.indexOf(op) === -1) {
      throw new Error(ErrorCode.OpStrError);
    }
    return true;
  };
  Validate2.isCollName = function(name2) {
    if (!/^[a-zA-Z0-9]([a-zA-Z0-9-_]){1,32}$/.test(name2)) {
      throw new Error(ErrorCode.CollNameError);
    }
    return true;
  };
  Validate2.isDocID = function(docId) {
    if (!/^([a-fA-F0-9]){24}$/.test(docId)) {
      throw new Error(ErrorCode.DocIDError);
    }
    return true;
  };
  return Validate2;
}();
var getType = function(x2) {
  return Object.prototype.toString.call(x2).slice(8, -1).toLowerCase();
};
var isObject = function(x2) {
  return getType(x2) === "object";
};
var isString = function(x2) {
  return getType(x2) === "string";
};
var isNumber = function(x2) {
  return getType(x2) === "number";
};
var isArray = function(x2) {
  return Array.isArray(x2);
};
var isDate$1 = function(x2) {
  return getType(x2) === "date";
};
var isRegExp$1 = function(x2) {
  return getType(x2) === "regexp";
};
var isInternalObject = function(x2) {
  return x2 && x2._internalType instanceof InternalSymbol;
};
var Point = function() {
  function Point2(longitude, latitude) {
    Validate.isGeopoint("longitude", longitude);
    Validate.isGeopoint("latitude", latitude);
    this.longitude = longitude;
    this.latitude = latitude;
  }
  Point2.prototype.parse = function(key) {
    var _a2;
    return _a2 = {}, _a2[key] = {
      type: "Point",
      coordinates: [this.longitude, this.latitude]
    }, _a2;
  };
  Point2.prototype.toJSON = function() {
    return {
      type: "Point",
      coordinates: [
        this.longitude,
        this.latitude
      ]
    };
  };
  Point2.prototype.toReadableString = function() {
    return "[" + this.longitude + "," + this.latitude + "]";
  };
  Point2.validate = function(point) {
    return point.type === "Point" && isArray(point.coordinates) && Validate.isGeopoint("longitude", point.coordinates[0]) && Validate.isGeopoint("latitude", point.coordinates[1]);
  };
  Object.defineProperty(Point2.prototype, "_internalType", {
    get: function() {
      return SYMBOL_GEO_POINT;
    },
    enumerable: true,
    configurable: true
  });
  return Point2;
}();
var __values$5 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var LineString = function() {
  function LineString2(points) {
    if (!isArray(points)) {
      throw new TypeError('"points" must be of type Point[]. Received type ' + typeof points);
    }
    if (points.length < 2) {
      throw new Error('"points" must contain 2 points at least');
    }
    points.forEach(function(point) {
      if (!(point instanceof Point)) {
        throw new TypeError('"points" must be of type Point[]. Received type ' + typeof point + "[]");
      }
    });
    this.points = points;
  }
  LineString2.prototype.parse = function(key) {
    var _a2;
    return _a2 = {}, _a2[key] = {
      type: "LineString",
      coordinates: this.points.map(function(point) {
        return point.toJSON().coordinates;
      })
    }, _a2;
  };
  LineString2.prototype.toJSON = function() {
    return {
      type: "LineString",
      coordinates: this.points.map(function(point) {
        return point.toJSON().coordinates;
      })
    };
  };
  LineString2.validate = function(lineString) {
    var e_1, _a2;
    if (lineString.type !== "LineString" || !isArray(lineString.coordinates)) {
      return false;
    }
    try {
      for (var _b = __values$5(lineString.coordinates), _c = _b.next(); !_c.done; _c = _b.next()) {
        var point = _c.value;
        if (!isNumber(point[0]) || !isNumber(point[1])) {
          return false;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return true;
  };
  LineString2.isClosed = function(lineString) {
    var firstPoint = lineString.points[0];
    var lastPoint = lineString.points[lineString.points.length - 1];
    if (firstPoint.latitude === lastPoint.latitude && firstPoint.longitude === lastPoint.longitude) {
      return true;
    }
  };
  Object.defineProperty(LineString2.prototype, "_internalType", {
    get: function() {
      return SYMBOL_GEO_LINE_STRING;
    },
    enumerable: true,
    configurable: true
  });
  return LineString2;
}();
var __values$4 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Polygon = function() {
  function Polygon2(lines) {
    if (!isArray(lines)) {
      throw new TypeError('"lines" must be of type LineString[]. Received type ' + typeof lines);
    }
    if (lines.length === 0) {
      throw new Error("Polygon must contain 1 linestring at least");
    }
    lines.forEach(function(line) {
      if (!(line instanceof LineString)) {
        throw new TypeError('"lines" must be of type LineString[]. Received type ' + typeof line + "[]");
      }
      if (!LineString.isClosed(line)) {
        throw new Error("LineString " + line.points.map(function(p2) {
          return p2.toReadableString();
        }) + " is not a closed cycle");
      }
    });
    this.lines = lines;
  }
  Polygon2.prototype.parse = function(key) {
    var _a2;
    return _a2 = {}, _a2[key] = {
      type: "Polygon",
      coordinates: this.lines.map(function(line) {
        return line.points.map(function(point) {
          return [point.longitude, point.latitude];
        });
      })
    }, _a2;
  };
  Polygon2.prototype.toJSON = function() {
    return {
      type: "Polygon",
      coordinates: this.lines.map(function(line) {
        return line.points.map(function(point) {
          return [point.longitude, point.latitude];
        });
      })
    };
  };
  Polygon2.validate = function(polygon) {
    var e_1, _a2, e_2, _b;
    if (polygon.type !== "Polygon" || !isArray(polygon.coordinates)) {
      return false;
    }
    try {
      for (var _c = __values$4(polygon.coordinates), _d = _c.next(); !_d.done; _d = _c.next()) {
        var line = _d.value;
        if (!this.isCloseLineString(line)) {
          return false;
        }
        try {
          for (var line_1 = (e_2 = void 0, __values$4(line)), line_1_1 = line_1.next(); !line_1_1.done; line_1_1 = line_1.next()) {
            var point = line_1_1.value;
            if (!isNumber(point[0]) || !isNumber(point[1])) {
              return false;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (line_1_1 && !line_1_1.done && (_b = line_1.return))
              _b.call(line_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a2 = _c.return))
          _a2.call(_c);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return true;
  };
  Polygon2.isCloseLineString = function(lineString) {
    var firstPoint = lineString[0];
    var lastPoint = lineString[lineString.length - 1];
    if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
      return false;
    }
    return true;
  };
  Object.defineProperty(Polygon2.prototype, "_internalType", {
    get: function() {
      return SYMBOL_GEO_MULTI_POLYGON;
    },
    enumerable: true,
    configurable: true
  });
  return Polygon2;
}();
var __values$3 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var MultiPoint = function() {
  function MultiPoint2(points) {
    if (!isArray(points)) {
      throw new TypeError('"points" must be of type Point[]. Received type ' + typeof points);
    }
    if (points.length === 0) {
      throw new Error('"points" must contain 1 point at least');
    }
    points.forEach(function(point) {
      if (!(point instanceof Point)) {
        throw new TypeError('"points" must be of type Point[]. Received type ' + typeof point + "[]");
      }
    });
    this.points = points;
  }
  MultiPoint2.prototype.parse = function(key) {
    var _a2;
    return _a2 = {}, _a2[key] = {
      type: "MultiPoint",
      coordinates: this.points.map(function(point) {
        return point.toJSON().coordinates;
      })
    }, _a2;
  };
  MultiPoint2.prototype.toJSON = function() {
    return {
      type: "MultiPoint",
      coordinates: this.points.map(function(point) {
        return point.toJSON().coordinates;
      })
    };
  };
  MultiPoint2.validate = function(multiPoint) {
    var e_1, _a2;
    if (multiPoint.type !== "MultiPoint" || !isArray(multiPoint.coordinates)) {
      return false;
    }
    try {
      for (var _b = __values$3(multiPoint.coordinates), _c = _b.next(); !_c.done; _c = _b.next()) {
        var point = _c.value;
        if (!isNumber(point[0]) || !isNumber(point[1])) {
          return false;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return true;
  };
  Object.defineProperty(MultiPoint2.prototype, "_internalType", {
    get: function() {
      return SYMBOL_GEO_MULTI_POINT;
    },
    enumerable: true,
    configurable: true
  });
  return MultiPoint2;
}();
var __values$2 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var MultiLineString = function() {
  function MultiLineString2(lines) {
    if (!isArray(lines)) {
      throw new TypeError('"lines" must be of type LineString[]. Received type ' + typeof lines);
    }
    if (lines.length === 0) {
      throw new Error("Polygon must contain 1 linestring at least");
    }
    lines.forEach(function(line) {
      if (!(line instanceof LineString)) {
        throw new TypeError('"lines" must be of type LineString[]. Received type ' + typeof line + "[]");
      }
    });
    this.lines = lines;
  }
  MultiLineString2.prototype.parse = function(key) {
    var _a2;
    return _a2 = {}, _a2[key] = {
      type: "MultiLineString",
      coordinates: this.lines.map(function(line) {
        return line.points.map(function(point) {
          return [point.longitude, point.latitude];
        });
      })
    }, _a2;
  };
  MultiLineString2.prototype.toJSON = function() {
    return {
      type: "MultiLineString",
      coordinates: this.lines.map(function(line) {
        return line.points.map(function(point) {
          return [point.longitude, point.latitude];
        });
      })
    };
  };
  MultiLineString2.validate = function(multiLineString) {
    var e_1, _a2, e_2, _b;
    if (multiLineString.type !== "MultiLineString" || !isArray(multiLineString.coordinates)) {
      return false;
    }
    try {
      for (var _c = __values$2(multiLineString.coordinates), _d = _c.next(); !_d.done; _d = _c.next()) {
        var line = _d.value;
        try {
          for (var line_1 = (e_2 = void 0, __values$2(line)), line_1_1 = line_1.next(); !line_1_1.done; line_1_1 = line_1.next()) {
            var point = line_1_1.value;
            if (!isNumber(point[0]) || !isNumber(point[1])) {
              return false;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (line_1_1 && !line_1_1.done && (_b = line_1.return))
              _b.call(line_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a2 = _c.return))
          _a2.call(_c);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return true;
  };
  Object.defineProperty(MultiLineString2.prototype, "_internalType", {
    get: function() {
      return SYMBOL_GEO_MULTI_LINE_STRING;
    },
    enumerable: true,
    configurable: true
  });
  return MultiLineString2;
}();
var __values$1 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var MultiPolygon = function() {
  function MultiPolygon2(polygons) {
    var e_1, _a2;
    if (!isArray(polygons)) {
      throw new TypeError('"polygons" must be of type Polygon[]. Received type ' + typeof polygons);
    }
    if (polygons.length === 0) {
      throw new Error("MultiPolygon must contain 1 polygon at least");
    }
    try {
      for (var polygons_1 = __values$1(polygons), polygons_1_1 = polygons_1.next(); !polygons_1_1.done; polygons_1_1 = polygons_1.next()) {
        var polygon = polygons_1_1.value;
        if (!(polygon instanceof Polygon)) {
          throw new TypeError('"polygon" must be of type Polygon[]. Received type ' + typeof polygon + "[]");
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (polygons_1_1 && !polygons_1_1.done && (_a2 = polygons_1.return))
          _a2.call(polygons_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    this.polygons = polygons;
  }
  MultiPolygon2.prototype.parse = function(key) {
    var _a2;
    return _a2 = {}, _a2[key] = {
      type: "MultiPolygon",
      coordinates: this.polygons.map(function(polygon) {
        return polygon.lines.map(function(line) {
          return line.points.map(function(point) {
            return [point.longitude, point.latitude];
          });
        });
      })
    }, _a2;
  };
  MultiPolygon2.prototype.toJSON = function() {
    return {
      type: "MultiPolygon",
      coordinates: this.polygons.map(function(polygon) {
        return polygon.lines.map(function(line) {
          return line.points.map(function(point) {
            return [point.longitude, point.latitude];
          });
        });
      })
    };
  };
  MultiPolygon2.validate = function(multiPolygon) {
    var e_2, _a2, e_3, _b, e_4, _c;
    if (multiPolygon.type !== "MultiPolygon" || !isArray(multiPolygon.coordinates)) {
      return false;
    }
    try {
      for (var _d = __values$1(multiPolygon.coordinates), _e2 = _d.next(); !_e2.done; _e2 = _d.next()) {
        var polygon = _e2.value;
        try {
          for (var polygon_1 = (e_3 = void 0, __values$1(polygon)), polygon_1_1 = polygon_1.next(); !polygon_1_1.done; polygon_1_1 = polygon_1.next()) {
            var line = polygon_1_1.value;
            try {
              for (var line_1 = (e_4 = void 0, __values$1(line)), line_1_1 = line_1.next(); !line_1_1.done; line_1_1 = line_1.next()) {
                var point = line_1_1.value;
                if (!isNumber(point[0]) || !isNumber(point[1])) {
                  return false;
                }
              }
            } catch (e_4_1) {
              e_4 = { error: e_4_1 };
            } finally {
              try {
                if (line_1_1 && !line_1_1.done && (_c = line_1.return))
                  _c.call(line_1);
              } finally {
                if (e_4)
                  throw e_4.error;
              }
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (polygon_1_1 && !polygon_1_1.done && (_b = polygon_1.return))
              _b.call(polygon_1);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_e2 && !_e2.done && (_a2 = _d.return))
          _a2.call(_d);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return true;
  };
  Object.defineProperty(MultiPolygon2.prototype, "_internalType", {
    get: function() {
      return SYMBOL_GEO_POLYGON;
    },
    enumerable: true,
    configurable: true
  });
  return MultiPolygon2;
}();
const Geo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LineString,
  MultiLineString,
  MultiPoint,
  MultiPolygon,
  Point,
  Polygon
}, Symbol.toStringTag, { value: "Module" }));
var createPromiseCallback = function() {
  var cb;
  if (!Promise) {
    cb = function() {
    };
    cb.promise = {};
    var throwPromiseNotDefined = function() {
      throw new Error('Your Node runtime does support ES6 Promises. Set "global.Promise" to your preferred implementation of promises.');
    };
    Object.defineProperty(cb.promise, "then", { get: throwPromiseNotDefined });
    Object.defineProperty(cb.promise, "catch", { get: throwPromiseNotDefined });
    return cb;
  }
  var promise = new Promise(function(resolve2, reject) {
    cb = function(err, data) {
      if (err)
        return reject(err);
      return resolve2(data);
    };
  });
  cb.promise = promise;
  return cb;
};
var UPDATE_COMMANDS_LITERAL;
(function(UPDATE_COMMANDS_LITERAL2) {
  UPDATE_COMMANDS_LITERAL2["SET"] = "set";
  UPDATE_COMMANDS_LITERAL2["REMOVE"] = "remove";
  UPDATE_COMMANDS_LITERAL2["INC"] = "inc";
  UPDATE_COMMANDS_LITERAL2["MUL"] = "mul";
  UPDATE_COMMANDS_LITERAL2["PUSH"] = "push";
  UPDATE_COMMANDS_LITERAL2["PULL"] = "pull";
  UPDATE_COMMANDS_LITERAL2["PULL_ALL"] = "pullAll";
  UPDATE_COMMANDS_LITERAL2["POP"] = "pop";
  UPDATE_COMMANDS_LITERAL2["SHIFT"] = "shift";
  UPDATE_COMMANDS_LITERAL2["UNSHIFT"] = "unshift";
  UPDATE_COMMANDS_LITERAL2["ADD_TO_SET"] = "addToSet";
  UPDATE_COMMANDS_LITERAL2["BIT"] = "bit";
  UPDATE_COMMANDS_LITERAL2["RENAME"] = "rename";
  UPDATE_COMMANDS_LITERAL2["MAX"] = "max";
  UPDATE_COMMANDS_LITERAL2["MIN"] = "min";
})(UPDATE_COMMANDS_LITERAL || (UPDATE_COMMANDS_LITERAL = {}));
var UpdateCommand = function() {
  function UpdateCommand2(operator, operands, fieldName) {
    this._internalType = SYMBOL_UPDATE_COMMAND;
    Object.defineProperties(this, {
      _internalType: {
        enumerable: false,
        configurable: false
      }
    });
    this.operator = operator;
    this.operands = operands;
    this.fieldName = fieldName || SYMBOL_UNSET_FIELD_NAME;
  }
  UpdateCommand2.prototype._setFieldName = function(fieldName) {
    var command = new UpdateCommand2(this.operator, this.operands, fieldName);
    return command;
  };
  return UpdateCommand2;
}();
function isUpdateCommand(object) {
  return object && object instanceof UpdateCommand && object._internalType === SYMBOL_UPDATE_COMMAND;
}
var LOGIC_COMMANDS_LITERAL;
(function(LOGIC_COMMANDS_LITERAL2) {
  LOGIC_COMMANDS_LITERAL2["AND"] = "and";
  LOGIC_COMMANDS_LITERAL2["OR"] = "or";
  LOGIC_COMMANDS_LITERAL2["NOT"] = "not";
  LOGIC_COMMANDS_LITERAL2["NOR"] = "nor";
})(LOGIC_COMMANDS_LITERAL || (LOGIC_COMMANDS_LITERAL = {}));
var LogicCommand = function() {
  function LogicCommand2(operator, operands, fieldName) {
    this._internalType = SYMBOL_LOGIC_COMMAND;
    Object.defineProperties(this, {
      _internalType: {
        enumerable: false,
        configurable: false
      }
    });
    this.operator = operator;
    this.operands = operands;
    this.fieldName = fieldName || SYMBOL_UNSET_FIELD_NAME;
    if (this.fieldName !== SYMBOL_UNSET_FIELD_NAME) {
      if (Array.isArray(operands)) {
        operands = operands.slice();
        this.operands = operands;
        for (var i = 0, len = operands.length; i < len; i++) {
          var query = operands[i];
          if (isLogicCommand(query) || isQueryCommand(query)) {
            operands[i] = query._setFieldName(this.fieldName);
          }
        }
      } else {
        var query = operands;
        if (isLogicCommand(query) || isQueryCommand(query)) {
          operands = query._setFieldName(this.fieldName);
        }
      }
    }
  }
  LogicCommand2.prototype._setFieldName = function(fieldName) {
    var operands = this.operands.map(function(operand) {
      if (operand instanceof LogicCommand2) {
        return operand._setFieldName(fieldName);
      } else {
        return operand;
      }
    });
    var command = new LogicCommand2(this.operator, operands, fieldName);
    return command;
  };
  LogicCommand2.prototype.and = function() {
    var expressions = Array.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);
    expressions.unshift(this);
    return new LogicCommand2(LOGIC_COMMANDS_LITERAL.AND, expressions, this.fieldName);
  };
  LogicCommand2.prototype.or = function() {
    var expressions = Array.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);
    expressions.unshift(this);
    return new LogicCommand2(LOGIC_COMMANDS_LITERAL.OR, expressions, this.fieldName);
  };
  return LogicCommand2;
}();
function isLogicCommand(object) {
  return object && object instanceof LogicCommand && object._internalType === SYMBOL_LOGIC_COMMAND;
}
var __extends$3 = /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var QUERY_COMMANDS_LITERAL;
(function(QUERY_COMMANDS_LITERAL2) {
  QUERY_COMMANDS_LITERAL2["EQ"] = "eq";
  QUERY_COMMANDS_LITERAL2["NEQ"] = "neq";
  QUERY_COMMANDS_LITERAL2["GT"] = "gt";
  QUERY_COMMANDS_LITERAL2["GTE"] = "gte";
  QUERY_COMMANDS_LITERAL2["LT"] = "lt";
  QUERY_COMMANDS_LITERAL2["LTE"] = "lte";
  QUERY_COMMANDS_LITERAL2["IN"] = "in";
  QUERY_COMMANDS_LITERAL2["NIN"] = "nin";
  QUERY_COMMANDS_LITERAL2["ALL"] = "all";
  QUERY_COMMANDS_LITERAL2["ELEM_MATCH"] = "elemMatch";
  QUERY_COMMANDS_LITERAL2["EXISTS"] = "exists";
  QUERY_COMMANDS_LITERAL2["SIZE"] = "size";
  QUERY_COMMANDS_LITERAL2["MOD"] = "mod";
  QUERY_COMMANDS_LITERAL2["GEO_NEAR"] = "geoNear";
  QUERY_COMMANDS_LITERAL2["GEO_WITHIN"] = "geoWithin";
  QUERY_COMMANDS_LITERAL2["GEO_INTERSECTS"] = "geoIntersects";
})(QUERY_COMMANDS_LITERAL || (QUERY_COMMANDS_LITERAL = {}));
var QueryCommand = function(_super) {
  __extends$3(QueryCommand2, _super);
  function QueryCommand2(operator, operands, fieldName) {
    var _this = _super.call(this, operator, operands, fieldName) || this;
    _this.operator = operator;
    _this._internalType = SYMBOL_QUERY_COMMAND;
    return _this;
  }
  QueryCommand2.prototype.toJSON = function() {
    var _a2, _b;
    switch (this.operator) {
      case QUERY_COMMANDS_LITERAL.IN:
      case QUERY_COMMANDS_LITERAL.NIN:
        return _a2 = {}, _a2["$" + this.operator] = this.operands, _a2;
      default:
        return _b = {}, _b["$" + this.operator] = this.operands[0], _b;
    }
  };
  QueryCommand2.prototype._setFieldName = function(fieldName) {
    var command = new QueryCommand2(this.operator, this.operands, fieldName);
    return command;
  };
  QueryCommand2.prototype.eq = function(val) {
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.EQ, [val], this.fieldName);
    return this.and(command);
  };
  QueryCommand2.prototype.neq = function(val) {
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.NEQ, [val], this.fieldName);
    return this.and(command);
  };
  QueryCommand2.prototype.gt = function(val) {
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.GT, [val], this.fieldName);
    return this.and(command);
  };
  QueryCommand2.prototype.gte = function(val) {
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.GTE, [val], this.fieldName);
    return this.and(command);
  };
  QueryCommand2.prototype.lt = function(val) {
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.LT, [val], this.fieldName);
    return this.and(command);
  };
  QueryCommand2.prototype.lte = function(val) {
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.LTE, [val], this.fieldName);
    return this.and(command);
  };
  QueryCommand2.prototype.in = function(list) {
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.IN, list, this.fieldName);
    return this.and(command);
  };
  QueryCommand2.prototype.nin = function(list) {
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.NIN, list, this.fieldName);
    return this.and(command);
  };
  QueryCommand2.prototype.geoNear = function(val) {
    if (!(val.geometry instanceof Point)) {
      throw new TypeError('"geometry" must be of type Point. Received type ' + typeof val.geometry);
    }
    if (val.maxDistance !== void 0 && !isNumber(val.maxDistance)) {
      throw new TypeError('"maxDistance" must be of type Number. Received type ' + typeof val.maxDistance);
    }
    if (val.minDistance !== void 0 && !isNumber(val.minDistance)) {
      throw new TypeError('"minDistance" must be of type Number. Received type ' + typeof val.minDistance);
    }
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.GEO_NEAR, [val], this.fieldName);
    return this.and(command);
  };
  QueryCommand2.prototype.geoWithin = function(val) {
    if (!(val.geometry instanceof MultiPolygon) && !(val.geometry instanceof Polygon)) {
      throw new TypeError('"geometry" must be of type Polygon or MultiPolygon. Received type ' + typeof val.geometry);
    }
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.GEO_WITHIN, [val], this.fieldName);
    return this.and(command);
  };
  QueryCommand2.prototype.geoIntersects = function(val) {
    if (!(val.geometry instanceof Point) && !(val.geometry instanceof LineString) && !(val.geometry instanceof Polygon) && !(val.geometry instanceof MultiPoint) && !(val.geometry instanceof MultiLineString) && !(val.geometry instanceof MultiPolygon)) {
      throw new TypeError('"geometry" must be of type Point, LineString, Polygon, MultiPoint, MultiLineString or MultiPolygon. Received type ' + typeof val.geometry);
    }
    var command = new QueryCommand2(QUERY_COMMANDS_LITERAL.GEO_INTERSECTS, [val], this.fieldName);
    return this.and(command);
  };
  return QueryCommand2;
}(LogicCommand);
function isQueryCommand(object) {
  return object && object instanceof QueryCommand && object._internalType === SYMBOL_QUERY_COMMAND;
}
function isComparisonCommand(object) {
  return isQueryCommand(object);
}
var OperatorMap = {};
for (var key in QUERY_COMMANDS_LITERAL) {
  OperatorMap[key] = "$" + key;
}
for (var key in LOGIC_COMMANDS_LITERAL) {
  OperatorMap[key] = "$" + key;
}
for (var key in UPDATE_COMMANDS_LITERAL) {
  OperatorMap[key] = "$" + key;
}
OperatorMap[QUERY_COMMANDS_LITERAL.NEQ] = "$ne";
OperatorMap[UPDATE_COMMANDS_LITERAL.REMOVE] = "$unset";
OperatorMap[UPDATE_COMMANDS_LITERAL.SHIFT] = "$pop";
OperatorMap[UPDATE_COMMANDS_LITERAL.UNSHIFT] = "$push";
function operatorToString(operator) {
  return OperatorMap[operator] || "$" + operator;
}
var __assign$5 = function() {
  __assign$5 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$5.apply(this, arguments);
};
var __read$1 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar2;
};
var __spread$1 = function() {
  for (var ar2 = [], i = 0; i < arguments.length; i++)
    ar2 = ar2.concat(__read$1(arguments[i]));
  return ar2;
};
function serialize(val) {
  return serializeHelper(val, [val]);
}
function serializeHelper(val, visited) {
  if (isInternalObject(val)) {
    switch (val._internalType) {
      case SYMBOL_GEO_POINT: {
        return val.toJSON();
      }
      case SYMBOL_SERVER_DATE: {
        return val.parse();
      }
      case SYMBOL_REGEXP: {
        return val.parse();
      }
      default: {
        return val.toJSON ? val.toJSON() : val;
      }
    }
  } else if (isDate$1(val)) {
    return {
      $date: +val
    };
  } else if (isRegExp$1(val)) {
    return {
      $regex: val.source,
      $options: val.flags
    };
  } else if (isArray(val)) {
    return val.map(function(item) {
      if (visited.indexOf(item) > -1) {
        throw new Error("Cannot convert circular structure to JSON");
      }
      return serializeHelper(item, __spread$1(visited, [
        item
      ]));
    });
  } else if (isObject(val)) {
    var ret = __assign$5({}, val);
    for (var key in ret) {
      if (visited.indexOf(ret[key]) > -1) {
        throw new Error("Cannot convert circular structure to JSON");
      }
      ret[key] = serializeHelper(ret[key], __spread$1(visited, [
        ret[key]
      ]));
    }
    return ret;
  } else {
    return val;
  }
}
var __assign$4 = function() {
  __assign$4 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$4.apply(this, arguments);
};
var __read = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar2;
};
var __spread = function() {
  for (var ar2 = [], i = 0; i < arguments.length; i++)
    ar2 = ar2.concat(__read(arguments[i]));
  return ar2;
};
function flatten(query, shouldPreserverObject, parents, visited) {
  var cloned = __assign$4({}, query);
  for (var key in query) {
    if (/^\$/.test(key))
      continue;
    var value = query[key];
    if (!value)
      continue;
    if (isObject(value) && !shouldPreserverObject(value)) {
      if (visited.indexOf(value) > -1) {
        throw new Error("Cannot convert circular structure to JSON");
      }
      var newParents = __spread(parents, [
        key
      ]);
      var newVisited = __spread(visited, [
        value
      ]);
      var flattenedChild = flatten(value, shouldPreserverObject, newParents, newVisited);
      cloned[key] = flattenedChild;
      var hasKeyNotCombined = false;
      for (var childKey in flattenedChild) {
        if (!/^\$/.test(childKey)) {
          cloned[key + "." + childKey] = flattenedChild[childKey];
          delete cloned[key][childKey];
        } else {
          hasKeyNotCombined = true;
        }
      }
      if (!hasKeyNotCombined) {
        delete cloned[key];
      }
    }
  }
  return cloned;
}
function flattenQueryObject(query) {
  return flatten(query, isConversionRequired, [], [query]);
}
function mergeConditionAfterEncode(query, condition, key) {
  if (!condition[key]) {
    delete query[key];
  }
  for (var conditionKey in condition) {
    if (query[conditionKey]) {
      if (isArray(query[conditionKey])) {
        query[conditionKey].push(condition[conditionKey]);
      } else if (isObject(query[conditionKey])) {
        if (isObject(condition[conditionKey])) {
          Object.assign(query[conditionKey], condition[conditionKey]);
        } else {
          console.warn("unmergable condition, query is object but condition is " + getType(condition) + ", can only overwrite", condition, key);
          query[conditionKey] = condition[conditionKey];
        }
      } else {
        console.warn("to-merge query is of type " + getType(query) + ", can only overwrite", query, condition, key);
        query[conditionKey] = condition[conditionKey];
      }
    } else {
      query[conditionKey] = condition[conditionKey];
    }
  }
}
function isConversionRequired(val) {
  return isInternalObject(val) || isDate$1(val) || isRegExp$1(val);
}
function encodeInternalDataType(val) {
  return serialize(val);
}
var UpdateSerializer = function() {
  function UpdateSerializer2() {
  }
  UpdateSerializer2.encode = function(query) {
    var stringifier = new UpdateSerializer2();
    return stringifier.encodeUpdate(query);
  };
  UpdateSerializer2.prototype.encodeUpdate = function(query) {
    if (isUpdateCommand(query)) {
      return this.encodeUpdateCommand(query);
    } else if (getType(query) === "object") {
      return this.encodeUpdateObject(query);
    } else {
      return query;
    }
  };
  UpdateSerializer2.prototype.encodeUpdateCommand = function(query) {
    if (query.fieldName === SYMBOL_UNSET_FIELD_NAME) {
      throw new Error("Cannot encode a comparison command with unset field name");
    }
    switch (query.operator) {
      case UPDATE_COMMANDS_LITERAL.PUSH:
      case UPDATE_COMMANDS_LITERAL.PULL:
      case UPDATE_COMMANDS_LITERAL.PULL_ALL:
      case UPDATE_COMMANDS_LITERAL.POP:
      case UPDATE_COMMANDS_LITERAL.SHIFT:
      case UPDATE_COMMANDS_LITERAL.UNSHIFT:
      case UPDATE_COMMANDS_LITERAL.ADD_TO_SET: {
        return this.encodeArrayUpdateCommand(query);
      }
      default: {
        return this.encodeFieldUpdateCommand(query);
      }
    }
  };
  UpdateSerializer2.prototype.encodeFieldUpdateCommand = function(query) {
    var _a2, _b, _c, _d;
    var $op = operatorToString(query.operator);
    switch (query.operator) {
      case UPDATE_COMMANDS_LITERAL.REMOVE: {
        return _a2 = {}, _a2[$op] = (_b = {}, _b[query.fieldName] = "", _b), _a2;
      }
      default: {
        return _c = {}, _c[$op] = (_d = {}, _d[query.fieldName] = query.operands[0], _d), _c;
      }
    }
  };
  UpdateSerializer2.prototype.encodeArrayUpdateCommand = function(query) {
    var _a2, _b, _c, _d, _e2, _f, _g, _h, _j, _k;
    var $op = operatorToString(query.operator);
    switch (query.operator) {
      case UPDATE_COMMANDS_LITERAL.PUSH: {
        var modifiers = void 0;
        if (isArray(query.operands)) {
          modifiers = {
            $each: query.operands.map(encodeInternalDataType)
          };
        } else {
          modifiers = query.operands;
        }
        return _a2 = {}, _a2[$op] = (_b = {}, _b[query.fieldName] = modifiers, _b), _a2;
      }
      case UPDATE_COMMANDS_LITERAL.UNSHIFT: {
        var modifiers = {
          $each: query.operands.map(encodeInternalDataType),
          $position: 0
        };
        return _c = {}, _c[$op] = (_d = {}, _d[query.fieldName] = modifiers, _d), _c;
      }
      case UPDATE_COMMANDS_LITERAL.POP: {
        return _e2 = {}, _e2[$op] = (_f = {}, _f[query.fieldName] = 1, _f), _e2;
      }
      case UPDATE_COMMANDS_LITERAL.SHIFT: {
        return _g = {}, _g[$op] = (_h = {}, _h[query.fieldName] = -1, _h), _g;
      }
      default: {
        return _j = {}, _j[$op] = (_k = {}, _k[query.fieldName] = encodeInternalDataType(query.operands), _k), _j;
      }
    }
  };
  UpdateSerializer2.prototype.encodeUpdateObject = function(query) {
    var flattened = flattenQueryObject(query);
    for (var key in flattened) {
      if (/^\$/.test(key))
        continue;
      var val = flattened[key];
      if (isUpdateCommand(val)) {
        flattened[key] = val._setFieldName(key);
        var condition = this.encodeUpdateCommand(flattened[key]);
        mergeConditionAfterEncode(flattened, condition, key);
      } else {
        flattened[key] = val = encodeInternalDataType(val);
        var $setCommand = new UpdateCommand(UPDATE_COMMANDS_LITERAL.SET, [val], key);
        var condition = this.encodeUpdateCommand($setCommand);
        mergeConditionAfterEncode(flattened, condition, key);
      }
    }
    return flattened;
  };
  return UpdateSerializer2;
}();
var wsList = {};
function getWsInstance(db) {
  if (!Db.wsClientClass) {
    throw new Error("to use realtime you must import realtime module first");
  }
  var env = db.config.env;
  if (!wsList[env]) {
    wsList[env] = new Db.wsClientClass({
      context: {
        appConfig: {
          docSizeLimit: 1e3,
          realtimePingInterval: 1e4,
          realtimePongWaitTimeout: 5e3,
          request: new Db.reqClass(db.config)
        }
      }
    });
  }
  return wsList[env];
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var DocumentReference$1 = function() {
  function DocumentReference2(db, coll, docID, projection) {
    var _this = this;
    if (projection === void 0) {
      projection = {};
    }
    this.watch = function(options) {
      var ws = getWsInstance(_this._db);
      return ws.watch(__assign$3(__assign$3({}, options), { envId: _this._db.config.env, collectionName: _this._coll, query: JSON.stringify({
        _id: _this.id
      }) }));
    };
    this._db = db;
    this._coll = coll;
    this.id = docID;
    this.request = new Db.reqClass(this._db.config);
    this.projection = projection;
  }
  DocumentReference2.prototype.create = function(data, callback) {
    callback = callback || createPromiseCallback();
    var params = {
      collectionName: this._coll,
      data: serialize(data)
    };
    if (this.id) {
      params["_id"] = this.id;
    }
    this.request.send("database.addDocument", params).then(function(res) {
      if (res.code) {
        callback(0, res);
      } else {
        callback(0, {
          id: res.data._id,
          requestId: res.requestId
        });
      }
    }).catch(function(err) {
      callback(err);
    });
    return callback.promise;
  };
  DocumentReference2.prototype.set = function(data, callback) {
    callback = callback || createPromiseCallback();
    if (!this.id) {
      return Promise.resolve({
        code: "INVALID_PARAM",
        message: "docId不能为空"
      });
    }
    if (!data || typeof data !== "object") {
      return Promise.resolve({
        code: "INVALID_PARAM",
        message: "参数必需是非空对象"
      });
    }
    if (data.hasOwnProperty("_id")) {
      return Promise.resolve({
        code: "INVALID_PARAM",
        message: "不能更新_id的值"
      });
    }
    var hasOperator = false;
    var checkMixed = function(objs) {
      if (typeof objs === "object") {
        for (var key in objs) {
          if (objs[key] instanceof UpdateCommand) {
            hasOperator = true;
          } else if (typeof objs[key] === "object") {
            checkMixed(objs[key]);
          }
        }
      }
    };
    checkMixed(data);
    if (hasOperator) {
      return Promise.resolve({
        code: "DATABASE_REQUEST_FAILED",
        message: "update operator complicit"
      });
    }
    var merge2 = false;
    var param = {
      collectionName: this._coll,
      queryType: QueryType.DOC,
      data: serialize(data),
      multi: false,
      merge: merge2,
      upsert: true
    };
    if (this.id) {
      param["query"] = { _id: this.id };
    }
    this.request.send("database.updateDocument", param).then(function(res) {
      if (res.code) {
        callback(0, res);
      } else {
        callback(0, {
          updated: res.data.updated,
          upsertedId: res.data.upserted_id,
          requestId: res.requestId
        });
      }
    }).catch(function(err) {
      callback(err);
    });
    return callback.promise;
  };
  DocumentReference2.prototype.update = function(data, callback) {
    callback = callback || createPromiseCallback();
    if (!data || typeof data !== "object") {
      return Promise.resolve({
        code: "INVALID_PARAM",
        message: "参数必需是非空对象"
      });
    }
    if (data.hasOwnProperty("_id")) {
      return Promise.resolve({
        code: "INVALID_PARAM",
        message: "不能更新_id的值"
      });
    }
    var query = { _id: this.id };
    var merge2 = true;
    var param = {
      collectionName: this._coll,
      data: UpdateSerializer.encode(data),
      query,
      queryType: QueryType.DOC,
      multi: false,
      merge: merge2,
      upsert: false
    };
    this.request.send("database.updateDocument", param).then(function(res) {
      if (res.code) {
        callback(0, res);
      } else {
        callback(0, {
          updated: res.data.updated,
          upsertedId: res.data.upserted_id,
          requestId: res.requestId
        });
      }
    }).catch(function(err) {
      callback(err);
    });
    return callback.promise;
  };
  DocumentReference2.prototype.remove = function(callback) {
    callback = callback || createPromiseCallback();
    var query = { _id: this.id };
    var param = {
      collectionName: this._coll,
      query,
      queryType: QueryType.DOC,
      multi: false
    };
    this.request.send("database.deleteDocument", param).then(function(res) {
      if (res.code) {
        callback(0, res);
      } else {
        callback(0, {
          deleted: res.data.deleted,
          requestId: res.requestId
        });
      }
    }).catch(function(err) {
      callback(err);
    });
    return callback.promise;
  };
  DocumentReference2.prototype.get = function(callback) {
    callback = callback || createPromiseCallback();
    var query = { _id: this.id };
    var param = {
      collectionName: this._coll,
      query,
      queryType: QueryType.DOC,
      multi: false,
      projection: this.projection
    };
    this.request.send("database.queryDocument", param).then(function(res) {
      if (res.code) {
        callback(0, res);
      } else {
        var documents = Util.formatResDocumentData(res.data.list);
        callback(0, {
          data: documents,
          requestId: res.requestId
        });
      }
    }).catch(function(err) {
      callback(err);
    });
    return callback.promise;
  };
  DocumentReference2.prototype.field = function(projection) {
    for (var k2 in projection) {
      if (projection[k2]) {
        projection[k2] = 1;
      } else {
        projection[k2] = 0;
      }
    }
    return new DocumentReference2(this._db, this._coll, this.id, projection);
  };
  return DocumentReference2;
}();
var QuerySerializer = function() {
  function QuerySerializer2() {
  }
  QuerySerializer2.encode = function(query) {
    var encoder2 = new QueryEncoder();
    return encoder2.encodeQuery(query);
  };
  return QuerySerializer2;
}();
var QueryEncoder = function() {
  function QueryEncoder2() {
  }
  QueryEncoder2.prototype.encodeQuery = function(query, key) {
    var _a2;
    if (isConversionRequired(query)) {
      if (isLogicCommand(query)) {
        return this.encodeLogicCommand(query);
      } else if (isQueryCommand(query)) {
        return this.encodeQueryCommand(query);
      } else {
        return _a2 = {}, _a2[key] = this.encodeQueryObject(query), _a2;
      }
    } else {
      if (isObject(query)) {
        return this.encodeQueryObject(query);
      } else {
        return query;
      }
    }
  };
  QueryEncoder2.prototype.encodeRegExp = function(query) {
    return {
      $regex: query.source,
      $options: query.flags
    };
  };
  QueryEncoder2.prototype.encodeLogicCommand = function(query) {
    var _a2, _b, _c, _d, _e2, _f, _g;
    var _this = this;
    switch (query.operator) {
      case LOGIC_COMMANDS_LITERAL.NOR:
      case LOGIC_COMMANDS_LITERAL.AND:
      case LOGIC_COMMANDS_LITERAL.OR: {
        var $op = operatorToString(query.operator);
        var subqueries = query.operands.map(function(oprand) {
          return _this.encodeQuery(oprand, query.fieldName);
        });
        return _a2 = {}, _a2[$op] = subqueries, _a2;
      }
      case LOGIC_COMMANDS_LITERAL.NOT: {
        var $op = operatorToString(query.operator);
        var operatorExpression = query.operands[0];
        if (isRegExp$1(operatorExpression)) {
          return _b = {}, _b[query.fieldName] = (_c = {}, _c[$op] = this.encodeRegExp(operatorExpression), _c), _b;
        } else {
          var subqueries = this.encodeQuery(operatorExpression)[query.fieldName];
          return _d = {}, _d[query.fieldName] = (_e2 = {}, _e2[$op] = subqueries, _e2), _d;
        }
      }
      default: {
        var $op = operatorToString(query.operator);
        if (query.operands.length === 1) {
          var subquery = this.encodeQuery(query.operands[0]);
          return _f = {}, _f[$op] = subquery, _f;
        } else {
          var subqueries = query.operands.map(this.encodeQuery.bind(this));
          return _g = {}, _g[$op] = subqueries, _g;
        }
      }
    }
  };
  QueryEncoder2.prototype.encodeQueryCommand = function(query) {
    if (isComparisonCommand(query)) {
      return this.encodeComparisonCommand(query);
    } else {
      return this.encodeComparisonCommand(query);
    }
  };
  QueryEncoder2.prototype.encodeComparisonCommand = function(query) {
    var _a2, _b, _c, _d, _e2, _f, _g, _h, _j;
    if (query.fieldName === SYMBOL_UNSET_FIELD_NAME) {
      throw new Error("Cannot encode a comparison command with unset field name");
    }
    var $op = operatorToString(query.operator);
    switch (query.operator) {
      case QUERY_COMMANDS_LITERAL.EQ:
      case QUERY_COMMANDS_LITERAL.NEQ:
      case QUERY_COMMANDS_LITERAL.LT:
      case QUERY_COMMANDS_LITERAL.LTE:
      case QUERY_COMMANDS_LITERAL.GT:
      case QUERY_COMMANDS_LITERAL.GTE:
      case QUERY_COMMANDS_LITERAL.ELEM_MATCH:
      case QUERY_COMMANDS_LITERAL.EXISTS:
      case QUERY_COMMANDS_LITERAL.SIZE:
      case QUERY_COMMANDS_LITERAL.MOD: {
        return _a2 = {}, _a2[query.fieldName] = (_b = {}, _b[$op] = encodeInternalDataType(query.operands[0]), _b), _a2;
      }
      case QUERY_COMMANDS_LITERAL.IN:
      case QUERY_COMMANDS_LITERAL.NIN:
      case QUERY_COMMANDS_LITERAL.ALL: {
        return _c = {}, _c[query.fieldName] = (_d = {}, _d[$op] = encodeInternalDataType(query.operands), _d), _c;
      }
      case QUERY_COMMANDS_LITERAL.GEO_NEAR: {
        var options = query.operands[0];
        return _e2 = {}, _e2[query.fieldName] = {
          $nearSphere: {
            $geometry: options.geometry.toJSON(),
            $maxDistance: options.maxDistance,
            $minDistance: options.minDistance
          }
        }, _e2;
      }
      case QUERY_COMMANDS_LITERAL.GEO_WITHIN: {
        var options = query.operands[0];
        return _f = {}, _f[query.fieldName] = {
          $geoWithin: {
            $geometry: options.geometry.toJSON()
          }
        }, _f;
      }
      case QUERY_COMMANDS_LITERAL.GEO_INTERSECTS: {
        var options = query.operands[0];
        return _g = {}, _g[query.fieldName] = {
          $geoIntersects: {
            $geometry: options.geometry.toJSON()
          }
        }, _g;
      }
      default: {
        return _h = {}, _h[query.fieldName] = (_j = {}, _j[$op] = encodeInternalDataType(query.operands[0]), _j), _h;
      }
    }
  };
  QueryEncoder2.prototype.encodeQueryObject = function(query) {
    var flattened = flattenQueryObject(query);
    for (var key in flattened) {
      var val = flattened[key];
      if (isLogicCommand(val)) {
        flattened[key] = val._setFieldName(key);
        var condition = this.encodeLogicCommand(flattened[key]);
        this.mergeConditionAfterEncode(flattened, condition, key);
      } else if (isComparisonCommand(val)) {
        flattened[key] = val._setFieldName(key);
        var condition = this.encodeComparisonCommand(flattened[key]);
        this.mergeConditionAfterEncode(flattened, condition, key);
      } else if (isConversionRequired(val)) {
        flattened[key] = encodeInternalDataType(val);
      }
    }
    return flattened;
  };
  QueryEncoder2.prototype.mergeConditionAfterEncode = function(query, condition, key) {
    if (!condition[key]) {
      delete query[key];
    }
    for (var conditionKey in condition) {
      if (query[conditionKey]) {
        if (isArray(query[conditionKey])) {
          query[conditionKey] = query[conditionKey].concat(condition[conditionKey]);
        } else if (isObject(query[conditionKey])) {
          if (isObject(condition[conditionKey])) {
            Object.assign(query, condition);
          } else {
            console.warn("unmergable condition, query is object but condition is " + getType(condition) + ", can only overwrite", condition, key);
            query[conditionKey] = condition[conditionKey];
          }
        } else {
          console.warn("to-merge query is of type " + getType(query) + ", can only overwrite", query, condition, key);
          query[conditionKey] = condition[conditionKey];
        }
      } else {
        query[conditionKey] = condition[conditionKey];
      }
    }
  };
  return QueryEncoder2;
}();
var __assign$2 = function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
var Query$1 = function() {
  function Query2(db, coll, fieldFilters, fieldOrders, queryOptions) {
    var _this = this;
    this.watch = function(options) {
      var ws = getWsInstance(_this._db);
      return ws.watch(__assign$2(__assign$2({}, options), { envId: _this._db.config.env, collectionName: _this._coll, query: JSON.stringify(_this._fieldFilters || {}), limit: _this._queryOptions.limit, orderBy: _this._fieldOrders ? _this._fieldOrders.reduce(function(acc, cur) {
        acc[cur.field] = cur.direction;
        return acc;
      }, {}) : void 0 }));
    };
    this._db = db;
    this._coll = coll;
    this._fieldFilters = fieldFilters;
    this._fieldOrders = fieldOrders || [];
    this._queryOptions = queryOptions || {};
    this._request = new Db.reqClass(this._db.config);
  }
  Query2.prototype.get = function(callback) {
    callback = callback || createPromiseCallback();
    var newOder = [];
    if (this._fieldOrders) {
      this._fieldOrders.forEach(function(order) {
        newOder.push(order);
      });
    }
    var param = {
      collectionName: this._coll,
      queryType: QueryType.WHERE
    };
    if (this._fieldFilters) {
      param.query = this._fieldFilters;
    }
    if (newOder.length > 0) {
      param.order = newOder;
    }
    if (this._queryOptions.offset) {
      param.offset = this._queryOptions.offset;
    }
    if (this._queryOptions.limit) {
      param.limit = this._queryOptions.limit < 1e3 ? this._queryOptions.limit : 1e3;
    } else {
      param.limit = 100;
    }
    if (this._queryOptions.projection) {
      param.projection = this._queryOptions.projection;
    }
    this._request.send("database.queryDocument", param).then(function(res) {
      if (res.code) {
        callback(0, res);
      } else {
        var documents = Util.formatResDocumentData(res.data.list);
        var result = {
          data: documents,
          requestId: res.requestId
        };
        if (res.total)
          result.total = res.total;
        if (res.limit)
          result.limit = res.limit;
        if (res.offset)
          result.offset = res.offset;
        callback(0, result);
      }
    }).catch(function(err) {
      callback(err);
    });
    return callback.promise;
  };
  Query2.prototype.count = function(callback) {
    callback = callback || createPromiseCallback();
    var param = {
      collectionName: this._coll,
      queryType: QueryType.WHERE
    };
    if (this._fieldFilters) {
      param.query = this._fieldFilters;
    }
    this._request.send("database.countDocument", param).then(function(res) {
      if (res.code) {
        callback(0, res);
      } else {
        callback(0, {
          requestId: res.requestId,
          total: res.data.total
        });
      }
    }).catch(function(e2) {
      callback(e2);
    });
    return callback.promise;
  };
  Query2.prototype.where = function(query) {
    if (Object.prototype.toString.call(query).slice(8, -1) !== "Object") {
      throw Error(ErrorCode.QueryParamTypeError);
    }
    var keys = Object.keys(query);
    var checkFlag = keys.some(function(item) {
      return query[item] !== void 0;
    });
    if (keys.length && !checkFlag) {
      throw Error(ErrorCode.QueryParamValueError);
    }
    return new Query2(this._db, this._coll, QuerySerializer.encode(query), this._fieldOrders, this._queryOptions);
  };
  Query2.prototype.orderBy = function(fieldPath, directionStr) {
    Validate.isFieldPath(fieldPath);
    Validate.isFieldOrder(directionStr);
    var newOrder = {
      field: fieldPath,
      direction: directionStr
    };
    var combinedOrders = this._fieldOrders.concat(newOrder);
    return new Query2(this._db, this._coll, this._fieldFilters, combinedOrders, this._queryOptions);
  };
  Query2.prototype.limit = function(limit) {
    Validate.isInteger("limit", limit);
    var option = __assign$2({}, this._queryOptions);
    option.limit = limit;
    return new Query2(this._db, this._coll, this._fieldFilters, this._fieldOrders, option);
  };
  Query2.prototype.skip = function(offset) {
    Validate.isInteger("offset", offset);
    var option = __assign$2({}, this._queryOptions);
    option.offset = offset;
    return new Query2(this._db, this._coll, this._fieldFilters, this._fieldOrders, option);
  };
  Query2.prototype.update = function(data, callback) {
    callback = callback || createPromiseCallback();
    if (!data || typeof data !== "object") {
      return Promise.resolve({
        code: "INVALID_PARAM",
        message: "参数必需是非空对象"
      });
    }
    if (data.hasOwnProperty("_id")) {
      return Promise.resolve({
        code: "INVALID_PARAM",
        message: "不能更新_id的值"
      });
    }
    var param = {
      collectionName: this._coll,
      query: this._fieldFilters,
      queryType: QueryType.WHERE,
      multi: true,
      merge: true,
      upsert: false,
      data: UpdateSerializer.encode(data)
    };
    this._request.send("database.updateDocument", param).then(function(res) {
      if (res.code) {
        callback(0, res);
      } else {
        callback(0, {
          requestId: res.requestId,
          updated: res.data.updated,
          upsertId: res.data.upsert_id
        });
      }
    }).catch(function(e2) {
      callback(e2);
    });
    return callback.promise;
  };
  Query2.prototype.field = function(projection) {
    for (var k2 in projection) {
      if (projection[k2]) {
        if (typeof projection[k2] !== "object") {
          projection[k2] = 1;
        }
      } else {
        projection[k2] = 0;
      }
    }
    var option = __assign$2({}, this._queryOptions);
    option.projection = projection;
    return new Query2(this._db, this._coll, this._fieldFilters, this._fieldOrders, option);
  };
  Query2.prototype.remove = function(callback) {
    callback = callback || createPromiseCallback();
    if (Object.keys(this._queryOptions).length > 0) {
      console.warn("`offset`, `limit` and `projection` are not supported in remove() operation");
    }
    if (this._fieldOrders.length > 0) {
      console.warn("`orderBy` is not supported in remove() operation");
    }
    var param = {
      collectionName: this._coll,
      query: QuerySerializer.encode(this._fieldFilters),
      queryType: QueryType.WHERE,
      multi: true
    };
    this._request.send("database.deleteDocument", param).then(function(res) {
      if (res.code) {
        callback(0, res);
      } else {
        callback(0, {
          requestId: res.requestId,
          deleted: res.data.deleted
        });
      }
    }).catch(function(e2) {
      callback(e2);
    });
    return callback.promise;
  };
  return Query2;
}();
function createCommonjsModule(fn, module2) {
  return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
}
var byteLength_1 = byteLength;
var toByteArray_1 = toByteArray;
var fromByteArray_1 = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b642) {
  var len = b642.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b642.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b642) {
  var lens = getLens(b642);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b642, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b642) {
  var tmp;
  var lens = getLens(b642);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b642, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b642.charCodeAt(i)] << 18 | revLookup[b642.charCodeAt(i + 1)] << 12 | revLookup[b642.charCodeAt(i + 2)] << 6 | revLookup[b642.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b642.charCodeAt(i)] << 2 | revLookup[b642.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b642.charCodeAt(i)] << 10 | revLookup[b642.charCodeAt(i + 1)] << 4 | revLookup[b642.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var base64Js = {
  byteLength: byteLength_1,
  toByteArray: toByteArray_1,
  fromByteArray: fromByteArray_1
};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var read = function read2(buffer2, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i];
  i += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
var write = function write2(buffer2, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e2 & 255, i += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d2] |= s2 * 128;
};
var ieee754 = {
  read,
  write
};
var buffer$1 = createCommonjsModule(function(module2, exports2) {
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? (
    // eslint-disable-line dot-notation
    Symbol["for"]("nodejs.util.inspect.custom")
  ) : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = {
        foo: function foo() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function get2() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function get2() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + babelHelpers["typeof"](value));
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    var b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + babelHelpers["typeof"](value));
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length = byteLength2(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b2)
      return 0;
    var x2 = a2.length;
    var y2 = b2.length;
    for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a2[i] !== b2[i]) {
        x2 = a2[i];
        y2 = b2[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    var i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          Buffer2.from(buf).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + babelHelpers["typeof"](string));
    }
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    var i = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    var length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    var str = "";
    var max = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + babelHelpers["typeof"](target));
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x2 = thisEnd - thisStart;
    var y2 = end - start;
    var len = Math.min(x2, y2);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read3(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read3(arr, i) === read3(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j2 = 0; j2 < valLength; j2++) {
          if (read3(arr, i + j2) !== read3(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write3(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64Js.fromByteArray(buf);
    } else {
      return base64Js.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var i = byteLength3;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64Js.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table;
  }();
});
var buffer_1 = buffer$1.Buffer;
buffer$1.SlowBuffer;
buffer$1.INSPECT_MAX_BYTES;
buffer$1.kMaxLength;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var _extendStatics = function extendStatics2(d2, b2) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
    }
  };
  return _extendStatics(d2, b2);
};
function __extends$2(d2, b2) {
  _extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var BSONError = (
  /** @class */
  function(_super) {
    __extends$2(BSONError2, _super);
    function BSONError2(message) {
      var _this = _super.call(this, message) || this;
      Object.setPrototypeOf(_this, BSONError2.prototype);
      return _this;
    }
    Object.defineProperty(BSONError2.prototype, "name", {
      get: function() {
        return "BSONError";
      },
      enumerable: false,
      configurable: true
    });
    return BSONError2;
  }(Error)
);
var BSONTypeError = (
  /** @class */
  function(_super) {
    __extends$2(BSONTypeError2, _super);
    function BSONTypeError2(message) {
      var _this = _super.call(this, message) || this;
      Object.setPrototypeOf(_this, BSONTypeError2.prototype);
      return _this;
    }
    Object.defineProperty(BSONTypeError2.prototype, "name", {
      get: function() {
        return "BSONTypeError";
      },
      enumerable: false,
      configurable: true
    });
    return BSONTypeError2;
  }(TypeError)
);
function checkForMath(potentialGlobal) {
  return potentialGlobal && potentialGlobal.Math == Math && potentialGlobal;
}
function getGlobal() {
  return checkForMath(typeof globalThis === "object" && globalThis) || checkForMath(typeof window === "object" && window) || checkForMath(typeof self === "object" && self) || checkForMath(typeof global === "object" && global) || // eslint-disable-next-line @typescript-eslint/no-implied-eval
  Function("return this")();
}
function isReactNative() {
  var g2 = getGlobal();
  return typeof g2.navigator === "object" && g2.navigator.product === "ReactNative";
}
var insecureRandomBytes = function insecureRandomBytes2(size2) {
  var insecureWarning = isReactNative() ? "BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values." : "BSON: No cryptographic implementation for random bytes present, falling back to a less secure implementation.";
  console.warn(insecureWarning);
  var result = buffer_1.alloc(size2);
  for (var i = 0; i < size2; ++i)
    result[i] = Math.floor(Math.random() * 256);
  return result;
};
var detectRandomBytes = function() {
  {
    if (typeof window !== "undefined") {
      var target_1 = window.crypto || window.msCrypto;
      if (target_1 && target_1.getRandomValues) {
        return function(size2) {
          return target_1.getRandomValues(buffer_1.alloc(size2));
        };
      }
    }
    if (typeof global !== "undefined" && global.crypto && global.crypto.getRandomValues) {
      return function(size2) {
        return global.crypto.getRandomValues(buffer_1.alloc(size2));
      };
    }
    return insecureRandomBytes;
  }
};
var randomBytes = detectRandomBytes();
function isAnyArrayBuffer(value) {
  return ["[object ArrayBuffer]", "[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(value));
}
function isUint8Array(value) {
  return Object.prototype.toString.call(value) === "[object Uint8Array]";
}
function isRegExp(d2) {
  return Object.prototype.toString.call(d2) === "[object RegExp]";
}
function isDate(d2) {
  return isObjectLike(d2) && Object.prototype.toString.call(d2) === "[object Date]";
}
function isObjectLike(candidate) {
  return typeof candidate === "object" && candidate !== null;
}
function deprecate(fn, message) {
  var warned = false;
  function deprecated() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!warned) {
      console.warn(message);
      warned = true;
    }
    return fn.apply(this, args);
  }
  return deprecated;
}
function ensureBuffer(potentialBuffer) {
  if (ArrayBuffer.isView(potentialBuffer)) {
    return buffer_1.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
  }
  if (isAnyArrayBuffer(potentialBuffer)) {
    return buffer_1.from(potentialBuffer);
  }
  throw new BSONTypeError("Must use either Buffer or TypedArray");
}
var VALIDATION_REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{12}4[0-9a-f]{3}[89ab][0-9a-f]{15})$/i;
var uuidValidateString = function(str) {
  return typeof str === "string" && VALIDATION_REGEX.test(str);
};
var uuidHexStringToBuffer = function(hexString) {
  if (!uuidValidateString(hexString)) {
    throw new BSONTypeError('UUID string representations must be a 32 or 36 character hex string (dashes excluded/included). Format: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" or "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".');
  }
  var sanitizedHexString = hexString.replace(/-/g, "");
  return buffer_1.from(sanitizedHexString, "hex");
};
var bufferToUuidHexString = function(buffer2, includeDashes) {
  if (includeDashes === void 0) {
    includeDashes = true;
  }
  return includeDashes ? buffer2.toString("hex", 0, 4) + "-" + buffer2.toString("hex", 4, 6) + "-" + buffer2.toString("hex", 6, 8) + "-" + buffer2.toString("hex", 8, 10) + "-" + buffer2.toString("hex", 10, 16) : buffer2.toString("hex");
};
var JS_INT_MAX = Math.pow(2, 53);
var JS_INT_MIN = -Math.pow(2, 53);
var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
var Binary = (
  /** @class */
  function() {
    function Binary2(buffer2, subType) {
      if (!(this instanceof Binary2))
        return new Binary2(buffer2, subType);
      if (!(buffer2 == null) && !(typeof buffer2 === "string") && !ArrayBuffer.isView(buffer2) && !(buffer2 instanceof ArrayBuffer) && !Array.isArray(buffer2)) {
        throw new BSONTypeError("Binary can only be constructed from string, Buffer, TypedArray, or Array<number>");
      }
      this.sub_type = subType !== null && subType !== void 0 ? subType : Binary2.BSON_BINARY_SUBTYPE_DEFAULT;
      if (buffer2 == null) {
        this.buffer = buffer_1.alloc(Binary2.BUFFER_SIZE);
        this.position = 0;
      } else {
        if (typeof buffer2 === "string") {
          this.buffer = buffer_1.from(buffer2, "binary");
        } else if (Array.isArray(buffer2)) {
          this.buffer = buffer_1.from(buffer2);
        } else {
          this.buffer = ensureBuffer(buffer2);
        }
        this.position = this.buffer.byteLength;
      }
    }
    Binary2.prototype.put = function(byteValue) {
      if (typeof byteValue === "string" && byteValue.length !== 1) {
        throw new BSONTypeError("only accepts single character String");
      } else if (typeof byteValue !== "number" && byteValue.length !== 1)
        throw new BSONTypeError("only accepts single character Uint8Array or Array");
      var decodedByte;
      if (typeof byteValue === "string") {
        decodedByte = byteValue.charCodeAt(0);
      } else if (typeof byteValue === "number") {
        decodedByte = byteValue;
      } else {
        decodedByte = byteValue[0];
      }
      if (decodedByte < 0 || decodedByte > 255) {
        throw new BSONTypeError("only accepts number in a valid unsigned byte range 0-255");
      }
      if (this.buffer.length > this.position) {
        this.buffer[this.position++] = decodedByte;
      } else {
        var buffer2 = buffer_1.alloc(Binary2.BUFFER_SIZE + this.buffer.length);
        this.buffer.copy(buffer2, 0, 0, this.buffer.length);
        this.buffer = buffer2;
        this.buffer[this.position++] = decodedByte;
      }
    };
    Binary2.prototype.write = function(sequence, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.length < offset + sequence.length) {
        var buffer2 = buffer_1.alloc(this.buffer.length + sequence.length);
        this.buffer.copy(buffer2, 0, 0, this.buffer.length);
        this.buffer = buffer2;
      }
      if (ArrayBuffer.isView(sequence)) {
        this.buffer.set(ensureBuffer(sequence), offset);
        this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
      } else if (typeof sequence === "string") {
        this.buffer.write(sequence, offset, sequence.length, "binary");
        this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position;
      }
    };
    Binary2.prototype.read = function(position, length) {
      length = length && length > 0 ? length : this.position;
      return this.buffer.slice(position, position + length);
    };
    Binary2.prototype.value = function(asRaw) {
      asRaw = !!asRaw;
      if (asRaw && this.buffer.length === this.position) {
        return this.buffer;
      }
      if (asRaw) {
        return this.buffer.slice(0, this.position);
      }
      return this.buffer.toString("binary", 0, this.position);
    };
    Binary2.prototype.length = function() {
      return this.position;
    };
    Binary2.prototype.toJSON = function() {
      return this.buffer.toString("base64");
    };
    Binary2.prototype.toString = function(format) {
      return this.buffer.toString(format);
    };
    Binary2.prototype.toExtendedJSON = function(options) {
      options = options || {};
      var base64String = this.buffer.toString("base64");
      var subType = Number(this.sub_type).toString(16);
      if (options.legacy) {
        return {
          $binary: base64String,
          $type: subType.length === 1 ? "0" + subType : subType
        };
      }
      return {
        $binary: {
          base64: base64String,
          subType: subType.length === 1 ? "0" + subType : subType
        }
      };
    };
    Binary2.prototype.toUUID = function() {
      if (this.sub_type === Binary2.SUBTYPE_UUID) {
        return new UUID(this.buffer.slice(0, this.position));
      }
      throw new BSONError('Binary sub_type "'.concat(this.sub_type, '" is not supported for converting to UUID. Only "').concat(Binary2.SUBTYPE_UUID, '" is currently supported.'));
    };
    Binary2.fromExtendedJSON = function(doc, options) {
      options = options || {};
      var data;
      var type;
      if ("$binary" in doc) {
        if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
          type = doc.$type ? parseInt(doc.$type, 16) : 0;
          data = buffer_1.from(doc.$binary, "base64");
        } else {
          if (typeof doc.$binary !== "string") {
            type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
            data = buffer_1.from(doc.$binary.base64, "base64");
          }
        }
      } else if ("$uuid" in doc) {
        type = 4;
        data = uuidHexStringToBuffer(doc.$uuid);
      }
      if (!data) {
        throw new BSONTypeError("Unexpected Binary Extended JSON format ".concat(JSON.stringify(doc)));
      }
      return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary2(data, type);
    };
    Binary2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    Binary2.prototype.inspect = function() {
      var asBuffer = this.value(true);
      return 'new Binary(Buffer.from("'.concat(asBuffer.toString("hex"), '", "hex"), ').concat(this.sub_type, ")");
    };
    Binary2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    Binary2.BUFFER_SIZE = 256;
    Binary2.SUBTYPE_DEFAULT = 0;
    Binary2.SUBTYPE_FUNCTION = 1;
    Binary2.SUBTYPE_BYTE_ARRAY = 2;
    Binary2.SUBTYPE_UUID_OLD = 3;
    Binary2.SUBTYPE_UUID = 4;
    Binary2.SUBTYPE_MD5 = 5;
    Binary2.SUBTYPE_ENCRYPTED = 6;
    Binary2.SUBTYPE_COLUMN = 7;
    Binary2.SUBTYPE_USER_DEFINED = 128;
    return Binary2;
  }()
);
Object.defineProperty(Binary.prototype, "_bsontype", { value: "Binary" });
var UUID_BYTE_LENGTH = 16;
var UUID = (
  /** @class */
  function(_super) {
    __extends$2(UUID2, _super);
    function UUID2(input) {
      var _this = this;
      var bytes;
      var hexStr;
      if (input == null) {
        bytes = UUID2.generate();
      } else if (input instanceof UUID2) {
        bytes = buffer_1.from(input.buffer);
        hexStr = input.__id;
      } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
        bytes = ensureBuffer(input);
      } else if (typeof input === "string") {
        bytes = uuidHexStringToBuffer(input);
      } else {
        throw new BSONTypeError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
      }
      _this = _super.call(this, bytes, BSON_BINARY_SUBTYPE_UUID_NEW) || this;
      _this.__id = hexStr;
      return _this;
    }
    Object.defineProperty(UUID2.prototype, "id", {
      /**
       * The UUID bytes
       * @readonly
       */
      get: function() {
        return this.buffer;
      },
      set: function(value) {
        this.buffer = value;
        if (UUID2.cacheHexString) {
          this.__id = bufferToUuidHexString(value);
        }
      },
      enumerable: false,
      configurable: true
    });
    UUID2.prototype.toHexString = function(includeDashes) {
      if (includeDashes === void 0) {
        includeDashes = true;
      }
      if (UUID2.cacheHexString && this.__id) {
        return this.__id;
      }
      var uuidHexString = bufferToUuidHexString(this.id, includeDashes);
      if (UUID2.cacheHexString) {
        this.__id = uuidHexString;
      }
      return uuidHexString;
    };
    UUID2.prototype.toString = function(encoding) {
      return encoding ? this.id.toString(encoding) : this.toHexString();
    };
    UUID2.prototype.toJSON = function() {
      return this.toHexString();
    };
    UUID2.prototype.equals = function(otherId) {
      if (!otherId) {
        return false;
      }
      if (otherId instanceof UUID2) {
        return otherId.id.equals(this.id);
      }
      try {
        return new UUID2(otherId).id.equals(this.id);
      } catch (_a2) {
        return false;
      }
    };
    UUID2.prototype.toBinary = function() {
      return new Binary(this.id, Binary.SUBTYPE_UUID);
    };
    UUID2.generate = function() {
      var bytes = randomBytes(UUID_BYTE_LENGTH);
      bytes[6] = bytes[6] & 15 | 64;
      bytes[8] = bytes[8] & 63 | 128;
      return buffer_1.from(bytes);
    };
    UUID2.isValid = function(input) {
      if (!input) {
        return false;
      }
      if (input instanceof UUID2) {
        return true;
      }
      if (typeof input === "string") {
        return uuidValidateString(input);
      }
      if (isUint8Array(input)) {
        if (input.length !== UUID_BYTE_LENGTH) {
          return false;
        }
        return (input[6] & 240) === 64 && (input[8] & 128) === 128;
      }
      return false;
    };
    UUID2.createFromHexString = function(hexString) {
      var buffer2 = uuidHexStringToBuffer(hexString);
      return new UUID2(buffer2);
    };
    UUID2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    UUID2.prototype.inspect = function() {
      return 'new UUID("'.concat(this.toHexString(), '")');
    };
    return UUID2;
  }(Binary)
);
var Code = (
  /** @class */
  function() {
    function Code2(code2, scope) {
      if (!(this instanceof Code2))
        return new Code2(code2, scope);
      this.code = code2;
      this.scope = scope;
    }
    Code2.prototype.toJSON = function() {
      return { code: this.code, scope: this.scope };
    };
    Code2.prototype.toExtendedJSON = function() {
      if (this.scope) {
        return { $code: this.code, $scope: this.scope };
      }
      return { $code: this.code };
    };
    Code2.fromExtendedJSON = function(doc) {
      return new Code2(doc.$code, doc.$scope);
    };
    Code2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    Code2.prototype.inspect = function() {
      var codeJson = this.toJSON();
      return 'new Code("'.concat(String(codeJson.code), '"').concat(codeJson.scope ? ", ".concat(JSON.stringify(codeJson.scope)) : "", ")");
    };
    return Code2;
  }()
);
Object.defineProperty(Code.prototype, "_bsontype", { value: "Code" });
function isDBRefLike(value) {
  return isObjectLike(value) && value.$id != null && typeof value.$ref === "string" && (value.$db == null || typeof value.$db === "string");
}
var DBRef = (
  /** @class */
  function() {
    function DBRef2(collection, oid, db, fields) {
      if (!(this instanceof DBRef2))
        return new DBRef2(collection, oid, db, fields);
      var parts = collection.split(".");
      if (parts.length === 2) {
        db = parts.shift();
        collection = parts.shift();
      }
      this.collection = collection;
      this.oid = oid;
      this.db = db;
      this.fields = fields || {};
    }
    Object.defineProperty(DBRef2.prototype, "namespace", {
      // Property provided for compatibility with the 1.x parser
      // the 1.x parser used a "namespace" property, while 4.x uses "collection"
      /** @internal */
      get: function() {
        return this.collection;
      },
      set: function(value) {
        this.collection = value;
      },
      enumerable: false,
      configurable: true
    });
    DBRef2.prototype.toJSON = function() {
      var o2 = Object.assign({
        $ref: this.collection,
        $id: this.oid
      }, this.fields);
      if (this.db != null)
        o2.$db = this.db;
      return o2;
    };
    DBRef2.prototype.toExtendedJSON = function(options) {
      options = options || {};
      var o2 = {
        $ref: this.collection,
        $id: this.oid
      };
      if (options.legacy) {
        return o2;
      }
      if (this.db)
        o2.$db = this.db;
      o2 = Object.assign(o2, this.fields);
      return o2;
    };
    DBRef2.fromExtendedJSON = function(doc) {
      var copy = Object.assign({}, doc);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef2(doc.$ref, doc.$id, doc.$db, copy);
    };
    DBRef2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    DBRef2.prototype.inspect = function() {
      var oid = this.oid === void 0 || this.oid.toString === void 0 ? this.oid : this.oid.toString();
      return 'new DBRef("'.concat(this.namespace, '", new ObjectId("').concat(String(oid), '")').concat(this.db ? ', "'.concat(this.db, '"') : "", ")");
    };
    return DBRef2;
  }()
);
Object.defineProperty(DBRef.prototype, "_bsontype", { value: "DBRef" });
var wasm = void 0;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(
    // prettier-ignore
    new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])
  ), {}).exports;
} catch (_a2) {
}
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var INT_CACHE = {};
var UINT_CACHE = {};
var Long = (
  /** @class */
  function() {
    function Long2(low, high, unsigned) {
      if (low === void 0) {
        low = 0;
      }
      if (!(this instanceof Long2))
        return new Long2(low, high, unsigned);
      if (typeof low === "bigint") {
        Object.assign(this, Long2.fromBigInt(low, !!high));
      } else if (typeof low === "string") {
        Object.assign(this, Long2.fromString(low, !!high));
      } else {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Object.defineProperty(this, "__isLong__", {
        value: true,
        configurable: false,
        writable: false,
        enumerable: false
      });
    }
    Long2.fromBits = function(lowBits, highBits, unsigned) {
      return new Long2(lowBits, highBits, unsigned);
    };
    Long2.fromInt = function(value, unsigned) {
      var obj, cachedObj, cache2;
      if (unsigned) {
        value >>>= 0;
        if (cache2 = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long2.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache2)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache2 = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long2.fromBits(value, value < 0 ? -1 : 0, false);
        if (cache2)
          INT_CACHE[value] = obj;
        return obj;
      }
    };
    Long2.fromNumber = function(value, unsigned) {
      if (isNaN(value))
        return unsigned ? Long2.UZERO : Long2.ZERO;
      if (unsigned) {
        if (value < 0)
          return Long2.UZERO;
        if (value >= TWO_PWR_64_DBL)
          return Long2.MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return Long2.MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return Long2.MAX_VALUE;
      }
      if (value < 0)
        return Long2.fromNumber(-value, unsigned).neg();
      return Long2.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    };
    Long2.fromBigInt = function(value, unsigned) {
      return Long2.fromString(value.toString(), unsigned);
    };
    Long2.fromString = function(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return Long2.ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p2;
      if ((p2 = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p2 === 0) {
        return Long2.fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
      var result = Long2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size2 = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size2), radix);
        if (size2 < 8) {
          var power = Long2.fromNumber(Math.pow(radix, size2));
          result = result.mul(power).add(Long2.fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(Long2.fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    };
    Long2.fromBytes = function(bytes, unsigned, le2) {
      return le2 ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
    };
    Long2.fromBytesLE = function(bytes, unsigned) {
      return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    };
    Long2.fromBytesBE = function(bytes, unsigned) {
      return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    };
    Long2.isLong = function(value) {
      return isObjectLike(value) && value["__isLong__"] === true;
    };
    Long2.fromValue = function(val, unsigned) {
      if (typeof val === "number")
        return Long2.fromNumber(val, unsigned);
      if (typeof val === "string")
        return Long2.fromString(val, unsigned);
      return Long2.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    };
    Long2.prototype.add = function(addend) {
      if (!Long2.isLong(addend))
        addend = Long2.fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    Long2.prototype.and = function(other) {
      if (!Long2.isLong(other))
        other = Long2.fromValue(other);
      return Long2.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    Long2.prototype.compare = function(other) {
      if (!Long2.isLong(other))
        other = Long2.fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    Long2.prototype.comp = function(other) {
      return this.compare(other);
    };
    Long2.prototype.divide = function(divisor) {
      if (!Long2.isLong(divisor))
        divisor = Long2.fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return Long2.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? Long2.UZERO : Long2.ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(Long2.MIN_VALUE)) {
          if (divisor.eq(Long2.ONE) || divisor.eq(Long2.NEG_ONE))
            return Long2.MIN_VALUE;
          else if (divisor.eq(Long2.MIN_VALUE))
            return Long2.ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(Long2.ZERO)) {
              return divisor.isNegative() ? Long2.ONE : Long2.NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(Long2.MIN_VALUE))
          return this.unsigned ? Long2.UZERO : Long2.ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = Long2.ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return Long2.UZERO;
        if (divisor.gt(this.shru(1)))
          return Long2.UONE;
        res = Long2.UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long2.fromNumber(approx);
        var approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = Long2.fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = Long2.ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    Long2.prototype.div = function(divisor) {
      return this.divide(divisor);
    };
    Long2.prototype.equals = function(other) {
      if (!Long2.isLong(other))
        other = Long2.fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    Long2.prototype.eq = function(other) {
      return this.equals(other);
    };
    Long2.prototype.getHighBits = function() {
      return this.high;
    };
    Long2.prototype.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    };
    Long2.prototype.getLowBits = function() {
      return this.low;
    };
    Long2.prototype.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    };
    Long2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        return this.eq(Long2.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      }
      var val = this.high !== 0 ? this.high : this.low;
      var bit;
      for (bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) !== 0)
          break;
      return this.high !== 0 ? bit + 33 : bit + 1;
    };
    Long2.prototype.greaterThan = function(other) {
      return this.comp(other) > 0;
    };
    Long2.prototype.gt = function(other) {
      return this.greaterThan(other);
    };
    Long2.prototype.greaterThanOrEqual = function(other) {
      return this.comp(other) >= 0;
    };
    Long2.prototype.gte = function(other) {
      return this.greaterThanOrEqual(other);
    };
    Long2.prototype.ge = function(other) {
      return this.greaterThanOrEqual(other);
    };
    Long2.prototype.isEven = function() {
      return (this.low & 1) === 0;
    };
    Long2.prototype.isNegative = function() {
      return !this.unsigned && this.high < 0;
    };
    Long2.prototype.isOdd = function() {
      return (this.low & 1) === 1;
    };
    Long2.prototype.isPositive = function() {
      return this.unsigned || this.high >= 0;
    };
    Long2.prototype.isZero = function() {
      return this.high === 0 && this.low === 0;
    };
    Long2.prototype.lessThan = function(other) {
      return this.comp(other) < 0;
    };
    Long2.prototype.lt = function(other) {
      return this.lessThan(other);
    };
    Long2.prototype.lessThanOrEqual = function(other) {
      return this.comp(other) <= 0;
    };
    Long2.prototype.lte = function(other) {
      return this.lessThanOrEqual(other);
    };
    Long2.prototype.modulo = function(divisor) {
      if (!Long2.isLong(divisor))
        divisor = Long2.fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return Long2.fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    Long2.prototype.mod = function(divisor) {
      return this.modulo(divisor);
    };
    Long2.prototype.rem = function(divisor) {
      return this.modulo(divisor);
    };
    Long2.prototype.multiply = function(multiplier) {
      if (this.isZero())
        return Long2.ZERO;
      if (!Long2.isLong(multiplier))
        multiplier = Long2.fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return Long2.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return Long2.ZERO;
      if (this.eq(Long2.MIN_VALUE))
        return multiplier.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      if (multiplier.eq(Long2.MIN_VALUE))
        return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(Long2.TWO_PWR_24) && multiplier.lt(Long2.TWO_PWR_24))
        return Long2.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    Long2.prototype.mul = function(multiplier) {
      return this.multiply(multiplier);
    };
    Long2.prototype.negate = function() {
      if (!this.unsigned && this.eq(Long2.MIN_VALUE))
        return Long2.MIN_VALUE;
      return this.not().add(Long2.ONE);
    };
    Long2.prototype.neg = function() {
      return this.negate();
    };
    Long2.prototype.not = function() {
      return Long2.fromBits(~this.low, ~this.high, this.unsigned);
    };
    Long2.prototype.notEquals = function(other) {
      return !this.equals(other);
    };
    Long2.prototype.neq = function(other) {
      return this.notEquals(other);
    };
    Long2.prototype.ne = function(other) {
      return this.notEquals(other);
    };
    Long2.prototype.or = function(other) {
      if (!Long2.isLong(other))
        other = Long2.fromValue(other);
      return Long2.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    Long2.prototype.shiftLeft = function(numBits) {
      if (Long2.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long2.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return Long2.fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    Long2.prototype.shl = function(numBits) {
      return this.shiftLeft(numBits);
    };
    Long2.prototype.shiftRight = function(numBits) {
      if (Long2.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long2.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return Long2.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    Long2.prototype.shr = function(numBits) {
      return this.shiftRight(numBits);
    };
    Long2.prototype.shiftRightUnsigned = function(numBits) {
      if (Long2.isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return Long2.fromBits(high, 0, this.unsigned);
        else
          return Long2.fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    Long2.prototype.shr_u = function(numBits) {
      return this.shiftRightUnsigned(numBits);
    };
    Long2.prototype.shru = function(numBits) {
      return this.shiftRightUnsigned(numBits);
    };
    Long2.prototype.subtract = function(subtrahend) {
      if (!Long2.isLong(subtrahend))
        subtrahend = Long2.fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    Long2.prototype.sub = function(subtrahend) {
      return this.subtract(subtrahend);
    };
    Long2.prototype.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    Long2.prototype.toNumber = function() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    Long2.prototype.toBigInt = function() {
      return BigInt(this.toString());
    };
    Long2.prototype.toBytes = function(le2) {
      return le2 ? this.toBytesLE() : this.toBytesBE();
    };
    Long2.prototype.toBytesLE = function() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    Long2.prototype.toBytesBE = function() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long2.prototype.toSigned = function() {
      if (!this.unsigned)
        return this;
      return Long2.fromBits(this.low, this.high, false);
    };
    Long2.prototype.toString = function(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(Long2.MIN_VALUE)) {
          var radixLong = Long2.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 6), this.unsigned);
      var rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    Long2.prototype.toUnsigned = function() {
      if (this.unsigned)
        return this;
      return Long2.fromBits(this.low, this.high, true);
    };
    Long2.prototype.xor = function(other) {
      if (!Long2.isLong(other))
        other = Long2.fromValue(other);
      return Long2.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    Long2.prototype.eqz = function() {
      return this.isZero();
    };
    Long2.prototype.le = function(other) {
      return this.lessThanOrEqual(other);
    };
    Long2.prototype.toExtendedJSON = function(options) {
      if (options && options.relaxed)
        return this.toNumber();
      return { $numberLong: this.toString() };
    };
    Long2.fromExtendedJSON = function(doc, options) {
      var result = Long2.fromString(doc.$numberLong);
      return options && options.relaxed ? result.toNumber() : result;
    };
    Long2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    Long2.prototype.inspect = function() {
      return 'new Long("'.concat(this.toString(), '"').concat(this.unsigned ? ", true" : "", ")");
    };
    Long2.TWO_PWR_24 = Long2.fromInt(TWO_PWR_24_DBL);
    Long2.MAX_UNSIGNED_VALUE = Long2.fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long2.ZERO = Long2.fromInt(0);
    Long2.UZERO = Long2.fromInt(0, true);
    Long2.ONE = Long2.fromInt(1);
    Long2.UONE = Long2.fromInt(1, true);
    Long2.NEG_ONE = Long2.fromInt(-1);
    Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0, false);
    return Long2;
  }()
);
Object.defineProperty(Long.prototype, "__isLong__", { value: true });
Object.defineProperty(Long.prototype, "_bsontype", { value: "Long" });
var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
var EXPONENT_MAX = 6111;
var EXPONENT_MIN = -6176;
var EXPONENT_BIAS = 6176;
var MAX_DIGITS = 34;
var NAN_BUFFER = [
  124,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
].reverse();
var INF_NEGATIVE_BUFFER = [
  248,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
].reverse();
var INF_POSITIVE_BUFFER = [
  120,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
].reverse();
var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
var COMBINATION_MASK = 31;
var EXPONENT_MASK = 16383;
var COMBINATION_INFINITY = 30;
var COMBINATION_NAN = 31;
function isDigit(value) {
  return !isNaN(parseInt(value, 10));
}
function divideu128(value) {
  var DIVISOR = Long.fromNumber(1e3 * 1e3 * 1e3);
  var _rem = Long.fromNumber(0);
  if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
    return { quotient: value, rem: _rem };
  }
  for (var i = 0; i <= 3; i++) {
    _rem = _rem.shiftLeft(32);
    _rem = _rem.add(new Long(value.parts[i], 0));
    value.parts[i] = _rem.div(DIVISOR).low;
    _rem = _rem.modulo(DIVISOR);
  }
  return { quotient: value, rem: _rem };
}
function multiply64x2(left, right) {
  if (!left && !right) {
    return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
  }
  var leftHigh = left.shiftRightUnsigned(32);
  var leftLow = new Long(left.getLowBits(), 0);
  var rightHigh = right.shiftRightUnsigned(32);
  var rightLow = new Long(right.getLowBits(), 0);
  var productHigh = leftHigh.multiply(rightHigh);
  var productMid = leftHigh.multiply(rightLow);
  var productMid2 = leftLow.multiply(rightHigh);
  var productLow = leftLow.multiply(rightLow);
  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
  productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
  productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
  return { high: productHigh, low: productLow };
}
function lessThan(left, right) {
  var uhleft = left.high >>> 0;
  var uhright = right.high >>> 0;
  if (uhleft < uhright) {
    return true;
  } else if (uhleft === uhright) {
    var ulleft = left.low >>> 0;
    var ulright = right.low >>> 0;
    if (ulleft < ulright)
      return true;
  }
  return false;
}
function invalidErr(string, message) {
  throw new BSONTypeError('"'.concat(string, '" is not a valid Decimal128 string - ').concat(message));
}
var Decimal128 = (
  /** @class */
  function() {
    function Decimal1282(bytes) {
      if (!(this instanceof Decimal1282))
        return new Decimal1282(bytes);
      if (typeof bytes === "string") {
        this.bytes = Decimal1282.fromString(bytes).bytes;
      } else if (isUint8Array(bytes)) {
        if (bytes.byteLength !== 16) {
          throw new BSONTypeError("Decimal128 must take a Buffer of 16 bytes");
        }
        this.bytes = bytes;
      } else {
        throw new BSONTypeError("Decimal128 must take a Buffer or string");
      }
    }
    Decimal1282.fromString = function(representation) {
      var isNegative = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var firstDigit = 0;
      var lastDigit = 0;
      var exponent = 0;
      var i = 0;
      var significandHigh = new Long(0, 0);
      var significandLow = new Long(0, 0);
      var biasedExponent = 0;
      var index2 = 0;
      if (representation.length >= 7e3) {
        throw new BSONTypeError("" + representation + " not a valid Decimal128 string");
      }
      var stringMatch = representation.match(PARSE_STRING_REGEXP);
      var infMatch = representation.match(PARSE_INF_REGEXP);
      var nanMatch = representation.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
        throw new BSONTypeError("" + representation + " not a valid Decimal128 string");
      }
      if (stringMatch) {
        var unsignedNumber = stringMatch[2];
        var e2 = stringMatch[4];
        var expSign = stringMatch[5];
        var expNumber = stringMatch[6];
        if (e2 && expNumber === void 0)
          invalidErr(representation, "missing exponent power");
        if (e2 && unsignedNumber === void 0)
          invalidErr(representation, "missing exponent base");
        if (e2 === void 0 && (expSign || expNumber)) {
          invalidErr(representation, "missing e before exponent");
        }
      }
      if (representation[index2] === "+" || representation[index2] === "-") {
        isNegative = representation[index2++] === "-";
      }
      if (!isDigit(representation[index2]) && representation[index2] !== ".") {
        if (representation[index2] === "i" || representation[index2] === "I") {
          return new Decimal1282(buffer_1.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        } else if (representation[index2] === "N") {
          return new Decimal1282(buffer_1.from(NAN_BUFFER));
        }
      }
      while (isDigit(representation[index2]) || representation[index2] === ".") {
        if (representation[index2] === ".") {
          if (sawRadix)
            invalidErr(representation, "contains multiple periods");
          sawRadix = true;
          index2 = index2 + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (representation[index2] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(representation[index2], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero)
          nDigits = nDigits + 1;
        if (sawRadix)
          radixPosition = radixPosition + 1;
        nDigitsRead = nDigitsRead + 1;
        index2 = index2 + 1;
      }
      if (sawRadix && !nDigitsRead)
        throw new BSONTypeError("" + representation + " not a valid Decimal128 string");
      if (representation[index2] === "e" || representation[index2] === "E") {
        var match = representation.substr(++index2).match(EXPONENT_REGEX);
        if (!match || !match[2])
          return new Decimal1282(buffer_1.from(NAN_BUFFER));
        exponent = parseInt(match[0], 10);
        index2 = index2 + match[0].length;
      }
      if (representation[index2])
        return new Decimal1282(buffer_1.from(NAN_BUFFER));
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (significantDigits !== 1) {
          while (digits[firstNonZero + significantDigits - 1] === 0) {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          var digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, "overflow");
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0 && significantDigits < nDigitsStored) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          var digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, "overflow");
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits) {
        var endOfString = nDigitsRead;
        if (sawRadix) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        if (isNegative) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        var roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
        var roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
              if (parseInt(representation[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          var dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal1282(buffer_1.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
                }
              }
            }
          }
        }
      }
      significandHigh = Long.fromNumber(0);
      significandLow = Long.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        var dIdx = firstDigit;
        significandLow = Long.fromNumber(digits[dIdx++]);
        significandHigh = new Long(0, 0);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      } else {
        var dIdx = firstDigit;
        significandHigh = Long.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long.fromNumber(10));
          significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
        }
        significandLow = Long.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      }
      var significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
      if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
        dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long.fromString("9223372036854775808"));
      }
      var buffer2 = buffer_1.alloc(16);
      index2 = 0;
      buffer2[index2++] = dec.low.low & 255;
      buffer2[index2++] = dec.low.low >> 8 & 255;
      buffer2[index2++] = dec.low.low >> 16 & 255;
      buffer2[index2++] = dec.low.low >> 24 & 255;
      buffer2[index2++] = dec.low.high & 255;
      buffer2[index2++] = dec.low.high >> 8 & 255;
      buffer2[index2++] = dec.low.high >> 16 & 255;
      buffer2[index2++] = dec.low.high >> 24 & 255;
      buffer2[index2++] = dec.high.low & 255;
      buffer2[index2++] = dec.high.low >> 8 & 255;
      buffer2[index2++] = dec.high.low >> 16 & 255;
      buffer2[index2++] = dec.high.low >> 24 & 255;
      buffer2[index2++] = dec.high.high & 255;
      buffer2[index2++] = dec.high.high >> 8 & 255;
      buffer2[index2++] = dec.high.high >> 16 & 255;
      buffer2[index2++] = dec.high.high >> 24 & 255;
      return new Decimal1282(buffer2);
    };
    Decimal1282.prototype.toString = function() {
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++)
        significand[i] = 0;
      var index2 = 0;
      var is_zero = false;
      var significand_msb;
      var significand128 = { parts: [0, 0, 0, 0] };
      var j2, k2;
      var string = [];
      index2 = 0;
      var buffer2 = this.bytes;
      var low = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
      var midl = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
      var midh = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
      var high = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
      index2 = 0;
      var dec = {
        low: new Long(low, midl),
        high: new Long(midh, high)
      };
      if (dec.high.lessThan(Long.ZERO)) {
        string.push("-");
      }
      var combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      var exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k2 = 3; k2 >= 0; k2--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low;
          if (!least_digits)
            continue;
          for (j2 = 8; j2 >= 0; j2--) {
            significand[k2 * 9 + j2] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index2] = 0;
      } else {
        significand_digits = 36;
        while (!significand[index2]) {
          significand_digits = significand_digits - 1;
          index2 = index2 + 1;
        }
      }
      var scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        if (significand_digits > 34) {
          string.push("".concat(0));
          if (exponent > 0)
            string.push("E+".concat(exponent));
          else if (exponent < 0)
            string.push("E".concat(exponent));
          return string.join("");
        }
        string.push("".concat(significand[index2++]));
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push(".");
        }
        for (var i = 0; i < significand_digits; i++) {
          string.push("".concat(significand[index2++]));
        }
        string.push("E");
        if (scientific_exponent > 0) {
          string.push("+".concat(scientific_exponent));
        } else {
          string.push("".concat(scientific_exponent));
        }
      } else {
        if (exponent >= 0) {
          for (var i = 0; i < significand_digits; i++) {
            string.push("".concat(significand[index2++]));
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (var i = 0; i < radix_position; i++) {
              string.push("".concat(significand[index2++]));
            }
          } else {
            string.push("0");
          }
          string.push(".");
          while (radix_position++ < 0) {
            string.push("0");
          }
          for (var i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push("".concat(significand[index2++]));
          }
        }
      }
      return string.join("");
    };
    Decimal1282.prototype.toJSON = function() {
      return { $numberDecimal: this.toString() };
    };
    Decimal1282.prototype.toExtendedJSON = function() {
      return { $numberDecimal: this.toString() };
    };
    Decimal1282.fromExtendedJSON = function(doc) {
      return Decimal1282.fromString(doc.$numberDecimal);
    };
    Decimal1282.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    Decimal1282.prototype.inspect = function() {
      return 'new Decimal128("'.concat(this.toString(), '")');
    };
    return Decimal1282;
  }()
);
Object.defineProperty(Decimal128.prototype, "_bsontype", { value: "Decimal128" });
var Double = (
  /** @class */
  function() {
    function Double2(value) {
      if (!(this instanceof Double2))
        return new Double2(value);
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value;
    }
    Double2.prototype.valueOf = function() {
      return this.value;
    };
    Double2.prototype.toJSON = function() {
      return this.value;
    };
    Double2.prototype.toString = function(radix) {
      return this.value.toString(radix);
    };
    Double2.prototype.toExtendedJSON = function(options) {
      if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
        return this.value;
      }
      if (Object.is(Math.sign(this.value), -0)) {
        return { $numberDouble: "-".concat(this.value.toFixed(1)) };
      }
      return {
        $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
      };
    };
    Double2.fromExtendedJSON = function(doc, options) {
      var doubleValue = parseFloat(doc.$numberDouble);
      return options && options.relaxed ? doubleValue : new Double2(doubleValue);
    };
    Double2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    Double2.prototype.inspect = function() {
      var eJSON = this.toExtendedJSON();
      return "new Double(".concat(eJSON.$numberDouble, ")");
    };
    return Double2;
  }()
);
Object.defineProperty(Double.prototype, "_bsontype", { value: "Double" });
var Int32 = (
  /** @class */
  function() {
    function Int322(value) {
      if (!(this instanceof Int322))
        return new Int322(value);
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value | 0;
    }
    Int322.prototype.valueOf = function() {
      return this.value;
    };
    Int322.prototype.toString = function(radix) {
      return this.value.toString(radix);
    };
    Int322.prototype.toJSON = function() {
      return this.value;
    };
    Int322.prototype.toExtendedJSON = function(options) {
      if (options && (options.relaxed || options.legacy))
        return this.value;
      return { $numberInt: this.value.toString() };
    };
    Int322.fromExtendedJSON = function(doc, options) {
      return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int322(doc.$numberInt);
    };
    Int322.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    Int322.prototype.inspect = function() {
      return "new Int32(".concat(this.valueOf(), ")");
    };
    return Int322;
  }()
);
Object.defineProperty(Int32.prototype, "_bsontype", { value: "Int32" });
var MaxKey = (
  /** @class */
  function() {
    function MaxKey2() {
      if (!(this instanceof MaxKey2))
        return new MaxKey2();
    }
    MaxKey2.prototype.toExtendedJSON = function() {
      return { $maxKey: 1 };
    };
    MaxKey2.fromExtendedJSON = function() {
      return new MaxKey2();
    };
    MaxKey2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    MaxKey2.prototype.inspect = function() {
      return "new MaxKey()";
    };
    return MaxKey2;
  }()
);
Object.defineProperty(MaxKey.prototype, "_bsontype", { value: "MaxKey" });
var MinKey = (
  /** @class */
  function() {
    function MinKey2() {
      if (!(this instanceof MinKey2))
        return new MinKey2();
    }
    MinKey2.prototype.toExtendedJSON = function() {
      return { $minKey: 1 };
    };
    MinKey2.fromExtendedJSON = function() {
      return new MinKey2();
    };
    MinKey2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    MinKey2.prototype.inspect = function() {
      return "new MinKey()";
    };
    return MinKey2;
  }()
);
Object.defineProperty(MinKey.prototype, "_bsontype", { value: "MinKey" });
var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
var PROCESS_UNIQUE = null;
var kId = Symbol("id");
var ObjectId = (
  /** @class */
  function() {
    function ObjectId2(inputId) {
      if (!(this instanceof ObjectId2))
        return new ObjectId2(inputId);
      var workingId;
      if (typeof inputId === "object" && inputId && "id" in inputId) {
        if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
          throw new BSONTypeError("Argument passed in must have an id that is of type string or Buffer");
        }
        if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
          workingId = buffer_1.from(inputId.toHexString(), "hex");
        } else {
          workingId = inputId.id;
        }
      } else {
        workingId = inputId;
      }
      if (workingId == null || typeof workingId === "number") {
        this[kId] = ObjectId2.generate(typeof workingId === "number" ? workingId : void 0);
      } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
        this[kId] = workingId instanceof buffer_1 ? workingId : ensureBuffer(workingId);
      } else if (typeof workingId === "string") {
        if (workingId.length === 12) {
          var bytes = buffer_1.from(workingId);
          if (bytes.byteLength === 12) {
            this[kId] = bytes;
          } else {
            throw new BSONTypeError("Argument passed in must be a string of 12 bytes");
          }
        } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {
          this[kId] = buffer_1.from(workingId, "hex");
        } else {
          throw new BSONTypeError("Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer");
        }
      } else {
        throw new BSONTypeError("Argument passed in does not match the accepted types");
      }
      if (ObjectId2.cacheHexString) {
        this.__id = this.id.toString("hex");
      }
    }
    Object.defineProperty(ObjectId2.prototype, "id", {
      /**
       * The ObjectId bytes
       * @readonly
       */
      get: function() {
        return this[kId];
      },
      set: function(value) {
        this[kId] = value;
        if (ObjectId2.cacheHexString) {
          this.__id = value.toString("hex");
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObjectId2.prototype, "generationTime", {
      /**
       * The generation time of this ObjectId instance
       * @deprecated Please use getTimestamp / createFromTime which returns an int32 epoch
       */
      get: function() {
        return this.id.readInt32BE(0);
      },
      set: function(value) {
        this.id.writeUInt32BE(value, 0);
      },
      enumerable: false,
      configurable: true
    });
    ObjectId2.prototype.toHexString = function() {
      if (ObjectId2.cacheHexString && this.__id) {
        return this.__id;
      }
      var hexString = this.id.toString("hex");
      if (ObjectId2.cacheHexString && !this.__id) {
        this.__id = hexString;
      }
      return hexString;
    };
    ObjectId2.getInc = function() {
      return ObjectId2.index = (ObjectId2.index + 1) % 16777215;
    };
    ObjectId2.generate = function(time) {
      if ("number" !== typeof time) {
        time = Math.floor(Date.now() / 1e3);
      }
      var inc = ObjectId2.getInc();
      var buffer2 = buffer_1.alloc(12);
      buffer2.writeUInt32BE(time, 0);
      if (PROCESS_UNIQUE === null) {
        PROCESS_UNIQUE = randomBytes(5);
      }
      buffer2[4] = PROCESS_UNIQUE[0];
      buffer2[5] = PROCESS_UNIQUE[1];
      buffer2[6] = PROCESS_UNIQUE[2];
      buffer2[7] = PROCESS_UNIQUE[3];
      buffer2[8] = PROCESS_UNIQUE[4];
      buffer2[11] = inc & 255;
      buffer2[10] = inc >> 8 & 255;
      buffer2[9] = inc >> 16 & 255;
      return buffer2;
    };
    ObjectId2.prototype.toString = function(format) {
      if (format)
        return this.id.toString(format);
      return this.toHexString();
    };
    ObjectId2.prototype.toJSON = function() {
      return this.toHexString();
    };
    ObjectId2.prototype.equals = function(otherId) {
      if (otherId === void 0 || otherId === null) {
        return false;
      }
      if (otherId instanceof ObjectId2) {
        return this[kId][11] === otherId[kId][11] && this[kId].equals(otherId[kId]);
      }
      if (typeof otherId === "string" && ObjectId2.isValid(otherId) && otherId.length === 12 && isUint8Array(this.id)) {
        return otherId === buffer_1.prototype.toString.call(this.id, "latin1");
      }
      if (typeof otherId === "string" && ObjectId2.isValid(otherId) && otherId.length === 24) {
        return otherId.toLowerCase() === this.toHexString();
      }
      if (typeof otherId === "string" && ObjectId2.isValid(otherId) && otherId.length === 12) {
        return buffer_1.from(otherId).equals(this.id);
      }
      if (typeof otherId === "object" && "toHexString" in otherId && typeof otherId.toHexString === "function") {
        var otherIdString = otherId.toHexString();
        var thisIdString = this.toHexString().toLowerCase();
        return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
      }
      return false;
    };
    ObjectId2.prototype.getTimestamp = function() {
      var timestamp = /* @__PURE__ */ new Date();
      var time = this.id.readUInt32BE(0);
      timestamp.setTime(Math.floor(time) * 1e3);
      return timestamp;
    };
    ObjectId2.createPk = function() {
      return new ObjectId2();
    };
    ObjectId2.createFromTime = function(time) {
      var buffer2 = buffer_1.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      buffer2.writeUInt32BE(time, 0);
      return new ObjectId2(buffer2);
    };
    ObjectId2.createFromHexString = function(hexString) {
      if (typeof hexString === "undefined" || hexString != null && hexString.length !== 24) {
        throw new BSONTypeError("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      return new ObjectId2(buffer_1.from(hexString, "hex"));
    };
    ObjectId2.isValid = function(id) {
      if (id == null)
        return false;
      try {
        new ObjectId2(id);
        return true;
      } catch (_a2) {
        return false;
      }
    };
    ObjectId2.prototype.toExtendedJSON = function() {
      if (this.toHexString)
        return { $oid: this.toHexString() };
      return { $oid: this.toString("hex") };
    };
    ObjectId2.fromExtendedJSON = function(doc) {
      return new ObjectId2(doc.$oid);
    };
    ObjectId2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    ObjectId2.prototype.inspect = function() {
      return 'new ObjectId("'.concat(this.toHexString(), '")');
    };
    ObjectId2.index = Math.floor(Math.random() * 16777215);
    return ObjectId2;
  }()
);
Object.defineProperty(ObjectId.prototype, "generate", {
  value: deprecate(function(time) {
    return ObjectId.generate(time);
  }, "Please use the static `ObjectId.generate(time)` instead")
});
Object.defineProperty(ObjectId.prototype, "getInc", {
  value: deprecate(function() {
    return ObjectId.getInc();
  }, "Please use the static `ObjectId.getInc()` instead")
});
Object.defineProperty(ObjectId.prototype, "get_inc", {
  value: deprecate(function() {
    return ObjectId.getInc();
  }, "Please use the static `ObjectId.getInc()` instead")
});
Object.defineProperty(ObjectId, "get_inc", {
  value: deprecate(function() {
    return ObjectId.getInc();
  }, "Please use the static `ObjectId.getInc()` instead")
});
Object.defineProperty(ObjectId.prototype, "_bsontype", { value: "ObjectID" });
function alphabetize(str) {
  return str.split("").sort().join("");
}
var BSONRegExp = (
  /** @class */
  function() {
    function BSONRegExp2(pattern, options) {
      if (!(this instanceof BSONRegExp2))
        return new BSONRegExp2(pattern, options);
      this.pattern = pattern;
      this.options = alphabetize(options !== null && options !== void 0 ? options : "");
      if (this.pattern.indexOf("\0") !== -1) {
        throw new BSONError("BSON Regex patterns cannot contain null bytes, found: ".concat(JSON.stringify(this.pattern)));
      }
      if (this.options.indexOf("\0") !== -1) {
        throw new BSONError("BSON Regex options cannot contain null bytes, found: ".concat(JSON.stringify(this.options)));
      }
      for (var i = 0; i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new BSONError("The regular expression option [".concat(this.options[i], "] is not supported"));
        }
      }
    }
    BSONRegExp2.parseOptions = function(options) {
      return options ? options.split("").sort().join("") : "";
    };
    BSONRegExp2.prototype.toExtendedJSON = function(options) {
      options = options || {};
      if (options.legacy) {
        return { $regex: this.pattern, $options: this.options };
      }
      return { $regularExpression: { pattern: this.pattern, options: this.options } };
    };
    BSONRegExp2.fromExtendedJSON = function(doc) {
      if ("$regex" in doc) {
        if (typeof doc.$regex !== "string") {
          if (doc.$regex._bsontype === "BSONRegExp") {
            return doc;
          }
        } else {
          return new BSONRegExp2(doc.$regex, BSONRegExp2.parseOptions(doc.$options));
        }
      }
      if ("$regularExpression" in doc) {
        return new BSONRegExp2(doc.$regularExpression.pattern, BSONRegExp2.parseOptions(doc.$regularExpression.options));
      }
      throw new BSONTypeError("Unexpected BSONRegExp EJSON object form: ".concat(JSON.stringify(doc)));
    };
    return BSONRegExp2;
  }()
);
Object.defineProperty(BSONRegExp.prototype, "_bsontype", { value: "BSONRegExp" });
var BSONSymbol = (
  /** @class */
  function() {
    function BSONSymbol2(value) {
      if (!(this instanceof BSONSymbol2))
        return new BSONSymbol2(value);
      this.value = value;
    }
    BSONSymbol2.prototype.valueOf = function() {
      return this.value;
    };
    BSONSymbol2.prototype.toString = function() {
      return this.value;
    };
    BSONSymbol2.prototype.inspect = function() {
      return 'new BSONSymbol("'.concat(this.value, '")');
    };
    BSONSymbol2.prototype.toJSON = function() {
      return this.value;
    };
    BSONSymbol2.prototype.toExtendedJSON = function() {
      return { $symbol: this.value };
    };
    BSONSymbol2.fromExtendedJSON = function(doc) {
      return new BSONSymbol2(doc.$symbol);
    };
    BSONSymbol2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    return BSONSymbol2;
  }()
);
Object.defineProperty(BSONSymbol.prototype, "_bsontype", { value: "Symbol" });
var LongWithoutOverridesClass = Long;
var Timestamp = (
  /** @class */
  function(_super) {
    __extends$2(Timestamp2, _super);
    function Timestamp2(low, high) {
      var _this = this;
      if (!(_this instanceof Timestamp2))
        return new Timestamp2(low, high);
      if (Long.isLong(low)) {
        _this = _super.call(this, low.low, low.high, true) || this;
      } else if (isObjectLike(low) && typeof low.t !== "undefined" && typeof low.i !== "undefined") {
        _this = _super.call(this, low.i, low.t, true) || this;
      } else {
        _this = _super.call(this, low, high, true) || this;
      }
      Object.defineProperty(_this, "_bsontype", {
        value: "Timestamp",
        writable: false,
        configurable: false,
        enumerable: false
      });
      return _this;
    }
    Timestamp2.prototype.toJSON = function() {
      return {
        $timestamp: this.toString()
      };
    };
    Timestamp2.fromInt = function(value) {
      return new Timestamp2(Long.fromInt(value, true));
    };
    Timestamp2.fromNumber = function(value) {
      return new Timestamp2(Long.fromNumber(value, true));
    };
    Timestamp2.fromBits = function(lowBits, highBits) {
      return new Timestamp2(lowBits, highBits);
    };
    Timestamp2.fromString = function(str, optRadix) {
      return new Timestamp2(Long.fromString(str, true, optRadix));
    };
    Timestamp2.prototype.toExtendedJSON = function() {
      return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };
    };
    Timestamp2.fromExtendedJSON = function(doc) {
      return new Timestamp2(doc.$timestamp);
    };
    Timestamp2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return this.inspect();
    };
    Timestamp2.prototype.inspect = function() {
      return "new Timestamp({ t: ".concat(this.getHighBits(), ", i: ").concat(this.getLowBits(), " })");
    };
    Timestamp2.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;
    return Timestamp2;
  }(LongWithoutOverridesClass)
);
function isBSONType(value) {
  return isObjectLike(value) && Reflect.has(value, "_bsontype") && typeof value._bsontype === "string";
}
var BSON_INT32_MAX = 2147483647;
var BSON_INT32_MIN = -2147483648;
var BSON_INT64_MAX = 9223372036854776e3;
var BSON_INT64_MIN = -9223372036854776e3;
var keysToCodecs = {
  $oid: ObjectId,
  $binary: Binary,
  $uuid: Binary,
  $symbol: BSONSymbol,
  $numberInt: Int32,
  $numberDecimal: Decimal128,
  $numberDouble: Double,
  $numberLong: Long,
  $minKey: MinKey,
  $maxKey: MaxKey,
  $regex: BSONRegExp,
  $regularExpression: BSONRegExp,
  $timestamp: Timestamp
};
function deserializeValue(value, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof value === "number") {
    if (options.relaxed || options.legacy) {
      return value;
    }
    if (Math.floor(value) === value) {
      if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX)
        return new Int32(value);
      if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX)
        return Long.fromNumber(value);
    }
    return new Double(value);
  }
  if (value == null || typeof value !== "object")
    return value;
  if (value.$undefined)
    return null;
  var keys = Object.keys(value).filter(function(k2) {
    return k2.startsWith("$") && value[k2] != null;
  });
  for (var i = 0; i < keys.length; i++) {
    var c2 = keysToCodecs[keys[i]];
    if (c2)
      return c2.fromExtendedJSON(value, options);
  }
  if (value.$date != null) {
    var d2 = value.$date;
    var date = /* @__PURE__ */ new Date();
    if (options.legacy) {
      if (typeof d2 === "number")
        date.setTime(d2);
      else if (typeof d2 === "string")
        date.setTime(Date.parse(d2));
    } else {
      if (typeof d2 === "string")
        date.setTime(Date.parse(d2));
      else if (Long.isLong(d2))
        date.setTime(d2.toNumber());
      else if (typeof d2 === "number" && options.relaxed)
        date.setTime(d2);
    }
    return date;
  }
  if (value.$code != null) {
    var copy = Object.assign({}, value);
    if (value.$scope) {
      copy.$scope = deserializeValue(value.$scope);
    }
    return Code.fromExtendedJSON(value);
  }
  if (isDBRefLike(value) || value.$dbPointer) {
    var v2 = value.$ref ? value : value.$dbPointer;
    if (v2 instanceof DBRef)
      return v2;
    var dollarKeys = Object.keys(v2).filter(function(k2) {
      return k2.startsWith("$");
    });
    var valid_1 = true;
    dollarKeys.forEach(function(k2) {
      if (["$ref", "$id", "$db"].indexOf(k2) === -1)
        valid_1 = false;
    });
    if (valid_1)
      return DBRef.fromExtendedJSON(v2);
  }
  return value;
}
function serializeArray(array, options) {
  return array.map(function(v2, index2) {
    options.seenObjects.push({ propertyName: "index ".concat(index2), obj: null });
    try {
      return serializeValue(v2, options);
    } finally {
      options.seenObjects.pop();
    }
  });
}
function getISOString(date) {
  var isoStr = date.toISOString();
  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
}
function serializeValue(value, options) {
  if ((typeof value === "object" || typeof value === "function") && value !== null) {
    var index2 = options.seenObjects.findIndex(function(entry) {
      return entry.obj === value;
    });
    if (index2 !== -1) {
      var props = options.seenObjects.map(function(entry) {
        return entry.propertyName;
      });
      var leadingPart = props.slice(0, index2).map(function(prop) {
        return "".concat(prop, " -> ");
      }).join("");
      var alreadySeen = props[index2];
      var circularPart = " -> " + props.slice(index2 + 1, props.length - 1).map(function(prop) {
        return "".concat(prop, " -> ");
      }).join("");
      var current = props[props.length - 1];
      var leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
      var dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
      throw new BSONTypeError("Converting circular structure to EJSON:\n" + "    ".concat(leadingPart).concat(alreadySeen).concat(circularPart).concat(current, "\n") + "    ".concat(leadingSpace, "\\").concat(dashes, "/"));
    }
    options.seenObjects[options.seenObjects.length - 1].obj = value;
  }
  if (Array.isArray(value))
    return serializeArray(value, options);
  if (value === void 0)
    return null;
  if (value instanceof Date || isDate(value)) {
    var dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 2534023188e5;
    if (options.legacy) {
      return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
    }
    return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
  }
  if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
    if (Math.floor(value) === value) {
      var int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX, int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX;
      if (int32Range)
        return { $numberInt: value.toString() };
      if (int64Range)
        return { $numberLong: value.toString() };
    }
    return { $numberDouble: value.toString() };
  }
  if (value instanceof RegExp || isRegExp(value)) {
    var flags = value.flags;
    if (flags === void 0) {
      var match = value.toString().match(/[gimuy]*$/);
      if (match) {
        flags = match[0];
      }
    }
    var rx = new BSONRegExp(value.source, flags);
    return rx.toExtendedJSON(options);
  }
  if (value != null && typeof value === "object")
    return serializeDocument(value, options);
  return value;
}
var BSON_TYPE_MAPPINGS = {
  Binary: function(o2) {
    return new Binary(o2.value(), o2.sub_type);
  },
  Code: function(o2) {
    return new Code(o2.code, o2.scope);
  },
  DBRef: function(o2) {
    return new DBRef(o2.collection || o2.namespace, o2.oid, o2.db, o2.fields);
  },
  Decimal128: function(o2) {
    return new Decimal128(o2.bytes);
  },
  Double: function(o2) {
    return new Double(o2.value);
  },
  Int32: function(o2) {
    return new Int32(o2.value);
  },
  Long: function(o2) {
    return Long.fromBits(
      // underscore variants for 1.x backwards compatibility
      o2.low != null ? o2.low : o2.low_,
      o2.low != null ? o2.high : o2.high_,
      o2.low != null ? o2.unsigned : o2.unsigned_
    );
  },
  MaxKey: function() {
    return new MaxKey();
  },
  MinKey: function() {
    return new MinKey();
  },
  ObjectID: function(o2) {
    return new ObjectId(o2);
  },
  ObjectId: function(o2) {
    return new ObjectId(o2);
  },
  BSONRegExp: function(o2) {
    return new BSONRegExp(o2.pattern, o2.options);
  },
  Symbol: function(o2) {
    return new BSONSymbol(o2.value);
  },
  Timestamp: function(o2) {
    return Timestamp.fromBits(o2.low, o2.high);
  }
};
function serializeDocument(doc, options) {
  if (doc == null || typeof doc !== "object")
    throw new BSONError("not an object instance");
  var bsontype = doc._bsontype;
  if (typeof bsontype === "undefined") {
    var _doc = {};
    for (var name2 in doc) {
      options.seenObjects.push({ propertyName: name2, obj: null });
      try {
        var value = serializeValue(doc[name2], options);
        if (name2 === "__proto__") {
          Object.defineProperty(_doc, name2, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          _doc[name2] = value;
        }
      } finally {
        options.seenObjects.pop();
      }
    }
    return _doc;
  } else if (isBSONType(doc)) {
    var outDoc = doc;
    if (typeof outDoc.toExtendedJSON !== "function") {
      var mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
      if (!mapper) {
        throw new BSONTypeError("Unrecognized or invalid _bsontype: " + doc._bsontype);
      }
      outDoc = mapper(outDoc);
    }
    if (bsontype === "Code" && outDoc.scope) {
      outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
    } else if (bsontype === "DBRef" && outDoc.oid) {
      outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
    }
    return outDoc.toExtendedJSON(options);
  } else {
    throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
  }
}
var EJSON;
(function(EJSON2) {
  function parse(text, options) {
    var finalOptions = Object.assign({}, { relaxed: true, legacy: false }, options);
    if (typeof finalOptions.relaxed === "boolean")
      finalOptions.strict = !finalOptions.relaxed;
    if (typeof finalOptions.strict === "boolean")
      finalOptions.relaxed = !finalOptions.strict;
    return JSON.parse(text, function(key, value) {
      if (key.indexOf("\0") !== -1) {
        throw new BSONError("BSON Document field names cannot contain null bytes, found: ".concat(JSON.stringify(key)));
      }
      return deserializeValue(value, finalOptions);
    });
  }
  EJSON2.parse = parse;
  function stringify2(value, replacer2, space, options) {
    if (space != null && typeof space === "object") {
      options = space;
      space = 0;
    }
    if (replacer2 != null && typeof replacer2 === "object" && !Array.isArray(replacer2)) {
      options = replacer2;
      replacer2 = void 0;
      space = 0;
    }
    var serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
      seenObjects: [{ propertyName: "(root)", obj: null }]
    });
    var doc = serializeValue(value, serializeOptions);
    return JSON.stringify(doc, replacer2, space);
  }
  EJSON2.stringify = stringify2;
  function serialize2(value, options) {
    options = options || {};
    return JSON.parse(stringify2(value, options));
  }
  EJSON2.serialize = serialize2;
  function deserialize(ejson, options) {
    options = options || {};
    return parse(JSON.stringify(ejson), options);
  }
  EJSON2.deserialize = deserialize;
})(EJSON || (EJSON = {}));
var bsonGlobal = getGlobal();
if (bsonGlobal.Map) {
  bsonGlobal.Map;
} else {
  (function() {
    function Map2(array) {
      if (array === void 0) {
        array = [];
      }
      this._keys = [];
      this._values = {};
      for (var i = 0; i < array.length; i++) {
        if (array[i] == null)
          continue;
        var entry = array[i];
        var key = entry[0];
        var value = entry[1];
        this._keys.push(key);
        this._values[key] = { v: value, i: this._keys.length - 1 };
      }
    }
    Map2.prototype.clear = function() {
      this._keys = [];
      this._values = {};
    };
    Map2.prototype.delete = function(key) {
      var value = this._values[key];
      if (value == null)
        return false;
      delete this._values[key];
      this._keys.splice(value.i, 1);
      return true;
    };
    Map2.prototype.entries = function() {
      var _this = this;
      var index2 = 0;
      return {
        next: function() {
          var key = _this._keys[index2++];
          return {
            value: key !== void 0 ? [key, _this._values[key].v] : void 0,
            done: key !== void 0 ? false : true
          };
        }
      };
    };
    Map2.prototype.forEach = function(callback, self2) {
      self2 = self2 || this;
      for (var i = 0; i < this._keys.length; i++) {
        var key = this._keys[i];
        callback.call(self2, this._values[key].v, key, self2);
      }
    };
    Map2.prototype.get = function(key) {
      return this._values[key] ? this._values[key].v : void 0;
    };
    Map2.prototype.has = function(key) {
      return this._values[key] != null;
    };
    Map2.prototype.keys = function() {
      var _this = this;
      var index2 = 0;
      return {
        next: function() {
          var key = _this._keys[index2++];
          return {
            value: key !== void 0 ? key : void 0,
            done: key !== void 0 ? false : true
          };
        }
      };
    };
    Map2.prototype.set = function(key, value) {
      if (this._values[key]) {
        this._values[key].v = value;
        return this;
      }
      this._keys.push(key);
      this._values[key] = { v: value, i: this._keys.length - 1 };
      return this;
    };
    Map2.prototype.values = function() {
      var _this = this;
      var index2 = 0;
      return {
        next: function() {
          var key = _this._keys[index2++];
          return {
            value: key !== void 0 ? _this._values[key].v : void 0,
            done: key !== void 0 ? false : true
          };
        }
      };
    };
    Object.defineProperty(Map2.prototype, "size", {
      get: function() {
        return this._keys.length;
      },
      enumerable: false,
      configurable: true
    });
    return Map2;
  })();
}
Long.fromNumber(JS_INT_MAX);
Long.fromNumber(JS_INT_MIN);
var SPACE_FOR_FLOAT64 = new Uint8Array(8);
new DataView(SPACE_FOR_FLOAT64.buffer, SPACE_FOR_FLOAT64.byteOffset, SPACE_FOR_FLOAT64.byteLength);
var MAXSIZE = 1024 * 1024 * 17;
buffer_1.alloc(MAXSIZE);
var __awaiter$2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$2 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var Aggregation = function() {
  function Aggregation2(db, collectionName) {
    this._stages = [];
    if (db && collectionName) {
      this._db = db;
      this._request = new Db.reqClass(this._db.config);
      this._collectionName = collectionName;
    }
  }
  Aggregation2.prototype.end = function() {
    return __awaiter$2(this, void 0, void 0, function() {
      var result;
      return __generator$2(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!this._collectionName || !this._db) {
              throw new Error("Aggregation pipeline cannot send request");
            }
            return [4, this._request.send("database.aggregate", {
              collectionName: this._collectionName,
              stages: this._stages
            })];
          case 1:
            result = _a2.sent();
            if (result && result.data && result.data.list) {
              return [2, {
                requestId: result.requestId,
                data: JSON.parse(result.data.list).map(EJSON.parse)
              }];
            }
            return [2, result];
        }
      });
    });
  };
  Aggregation2.prototype.unwrap = function() {
    return this._stages;
  };
  Aggregation2.prototype.done = function() {
    return this._stages.map(function(_a2) {
      var _b;
      var stageKey = _a2.stageKey, stageValue = _a2.stageValue;
      return _b = {}, _b[stageKey] = JSON.parse(stageValue), _b;
    });
  };
  Aggregation2.prototype._pipe = function(stage, param) {
    this._stages.push({
      stageKey: "$" + stage,
      stageValue: JSON.stringify(param)
    });
    return this;
  };
  Aggregation2.prototype.addFields = function(param) {
    return this._pipe("addFields", param);
  };
  Aggregation2.prototype.bucket = function(param) {
    return this._pipe("bucket", param);
  };
  Aggregation2.prototype.bucketAuto = function(param) {
    return this._pipe("bucketAuto", param);
  };
  Aggregation2.prototype.count = function(param) {
    return this._pipe("count", param);
  };
  Aggregation2.prototype.geoNear = function(param) {
    if (param.query) {
      param.query = QuerySerializer.encode(param.query);
    }
    if (param.distanceMultiplier && typeof param.distanceMultiplier === "number") {
      param.distanceMultiplier = param.distanceMultiplier;
    }
    if (param.near) {
      param.near = new Point(param.near.longitude, param.near.latitude).toJSON();
    }
    return this._pipe("geoNear", param);
  };
  Aggregation2.prototype.group = function(param) {
    return this._pipe("group", param);
  };
  Aggregation2.prototype.limit = function(param) {
    return this._pipe("limit", param);
  };
  Aggregation2.prototype.match = function(param) {
    return this._pipe("match", QuerySerializer.encode(param));
  };
  Aggregation2.prototype.project = function(param) {
    return this._pipe("project", param);
  };
  Aggregation2.prototype.lookup = function(param) {
    return this._pipe("lookup", param);
  };
  Aggregation2.prototype.replaceRoot = function(param) {
    return this._pipe("replaceRoot", param);
  };
  Aggregation2.prototype.sample = function(param) {
    return this._pipe("sample", param);
  };
  Aggregation2.prototype.skip = function(param) {
    return this._pipe("skip", param);
  };
  Aggregation2.prototype.sort = function(param) {
    return this._pipe("sort", param);
  };
  Aggregation2.prototype.sortByCount = function(param) {
    return this._pipe("sortByCount", param);
  };
  Aggregation2.prototype.unwind = function(param) {
    return this._pipe("unwind", param);
  };
  return Aggregation2;
}();
const Aggregation$1 = Aggregation;
var __extends$1 = /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CollectionReference$1 = function(_super) {
  __extends$1(CollectionReference2, _super);
  function CollectionReference2(db, coll) {
    return _super.call(this, db, coll) || this;
  }
  Object.defineProperty(CollectionReference2.prototype, "name", {
    get: function() {
      return this._coll;
    },
    enumerable: true,
    configurable: true
  });
  CollectionReference2.prototype.doc = function(docID) {
    if (typeof docID !== "string" && typeof docID !== "number") {
      throw new Error("docId必须为字符串或数字");
    }
    return new DocumentReference$1(this._db, this._coll, docID);
  };
  CollectionReference2.prototype.add = function(data, callback) {
    var docRef = new DocumentReference$1(this._db, this._coll, void 0);
    return docRef.create(data, callback);
  };
  CollectionReference2.prototype.aggregate = function() {
    return new Aggregation$1(this._db, this._coll);
  };
  return CollectionReference2;
}(Query$1);
var Command = {
  eq: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.EQ, [val]);
  },
  neq: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.NEQ, [val]);
  },
  lt: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.LT, [val]);
  },
  lte: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.LTE, [val]);
  },
  gt: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.GT, [val]);
  },
  gte: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.GTE, [val]);
  },
  in: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.IN, val);
  },
  nin: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.NIN, val);
  },
  all: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.ALL, val);
  },
  elemMatch: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.ELEM_MATCH, [val]);
  },
  exists: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.EXISTS, [val]);
  },
  size: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.SIZE, [val]);
  },
  mod: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.MOD, [val]);
  },
  geoNear: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_NEAR, [val]);
  },
  geoWithin: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_WITHIN, [val]);
  },
  geoIntersects: function(val) {
    return new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_INTERSECTS, [val]);
  },
  and: function() {
    var expressions = isArray(arguments[0]) ? arguments[0] : Array.from(arguments);
    return new LogicCommand(LOGIC_COMMANDS_LITERAL.AND, expressions);
  },
  nor: function() {
    var expressions = isArray(arguments[0]) ? arguments[0] : Array.from(arguments);
    return new LogicCommand(LOGIC_COMMANDS_LITERAL.NOR, expressions);
  },
  or: function() {
    var expressions = isArray(arguments[0]) ? arguments[0] : Array.from(arguments);
    return new LogicCommand(LOGIC_COMMANDS_LITERAL.OR, expressions);
  },
  not: function() {
    var expressions = isArray(arguments[0]) ? arguments[0] : Array.from(arguments);
    return new LogicCommand(LOGIC_COMMANDS_LITERAL.NOT, expressions);
  },
  set: function(val) {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.SET, [val]);
  },
  remove: function() {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.REMOVE, []);
  },
  inc: function(val) {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.INC, [val]);
  },
  mul: function(val) {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.MUL, [val]);
  },
  push: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var values;
    if (isObject(args[0]) && args[0].hasOwnProperty("each")) {
      var options = args[0];
      values = {
        $each: options.each,
        $position: options.position,
        $sort: options.sort,
        $slice: options.slice
      };
    } else if (isArray(args[0])) {
      values = args[0];
    } else {
      values = Array.from(args);
    }
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.PUSH, values);
  },
  pull: function(values) {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.PULL, values);
  },
  pullAll: function(values) {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.PULL_ALL, values);
  },
  pop: function() {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.POP, []);
  },
  shift: function() {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.SHIFT, []);
  },
  unshift: function() {
    var values = isArray(arguments[0]) ? arguments[0] : Array.from(arguments);
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.UNSHIFT, values);
  },
  addToSet: function(values) {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.ADD_TO_SET, values);
  },
  rename: function(values) {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.RENAME, [values]);
  },
  bit: function(values) {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.BIT, [values]);
  },
  max: function(values) {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.MAX, [values]);
  },
  min: function(values) {
    return new UpdateCommand(UPDATE_COMMANDS_LITERAL.MIN, [values]);
  },
  expr: function(values) {
    return {
      $expr: values
    };
  },
  jsonSchema: function(schema) {
    return {
      $jsonSchema: schema
    };
  },
  text: function(values) {
    if (isString(values)) {
      return {
        $search: values.search
      };
    } else {
      return {
        $search: values.search,
        $language: values.language,
        $caseSensitive: values.caseSensitive,
        $diacriticSensitive: values.diacriticSensitive
      };
    }
  },
  aggregate: {
    pipeline: function() {
      return new Aggregation$1();
    },
    abs: function(param) {
      return new AggregationOperator("abs", param);
    },
    add: function(param) {
      return new AggregationOperator("add", param);
    },
    ceil: function(param) {
      return new AggregationOperator("ceil", param);
    },
    divide: function(param) {
      return new AggregationOperator("divide", param);
    },
    exp: function(param) {
      return new AggregationOperator("exp", param);
    },
    floor: function(param) {
      return new AggregationOperator("floor", param);
    },
    ln: function(param) {
      return new AggregationOperator("ln", param);
    },
    log: function(param) {
      return new AggregationOperator("log", param);
    },
    log10: function(param) {
      return new AggregationOperator("log10", param);
    },
    mod: function(param) {
      return new AggregationOperator("mod", param);
    },
    multiply: function(param) {
      return new AggregationOperator("multiply", param);
    },
    pow: function(param) {
      return new AggregationOperator("pow", param);
    },
    sqrt: function(param) {
      return new AggregationOperator("sqrt", param);
    },
    subtract: function(param) {
      return new AggregationOperator("subtract", param);
    },
    trunc: function(param) {
      return new AggregationOperator("trunc", param);
    },
    arrayElemAt: function(param) {
      return new AggregationOperator("arrayElemAt", param);
    },
    arrayToObject: function(param) {
      return new AggregationOperator("arrayToObject", param);
    },
    concatArrays: function(param) {
      return new AggregationOperator("concatArrays", param);
    },
    filter: function(param) {
      return new AggregationOperator("filter", param);
    },
    in: function(param) {
      return new AggregationOperator("in", param);
    },
    indexOfArray: function(param) {
      return new AggregationOperator("indexOfArray", param);
    },
    isArray: function(param) {
      return new AggregationOperator("isArray", param);
    },
    map: function(param) {
      return new AggregationOperator("map", param);
    },
    range: function(param) {
      return new AggregationOperator("range", param);
    },
    reduce: function(param) {
      return new AggregationOperator("reduce", param);
    },
    reverseArray: function(param) {
      return new AggregationOperator("reverseArray", param);
    },
    size: function(param) {
      return new AggregationOperator("size", param);
    },
    slice: function(param) {
      return new AggregationOperator("slice", param);
    },
    zip: function(param) {
      return new AggregationOperator("zip", param);
    },
    and: function(param) {
      return new AggregationOperator("and", param);
    },
    not: function(param) {
      return new AggregationOperator("not", param);
    },
    or: function(param) {
      return new AggregationOperator("or", param);
    },
    cmp: function(param) {
      return new AggregationOperator("cmp", param);
    },
    eq: function(param) {
      return new AggregationOperator("eq", param);
    },
    gt: function(param) {
      return new AggregationOperator("gt", param);
    },
    gte: function(param) {
      return new AggregationOperator("gte", param);
    },
    lt: function(param) {
      return new AggregationOperator("lt", param);
    },
    lte: function(param) {
      return new AggregationOperator("lte", param);
    },
    neq: function(param) {
      return new AggregationOperator("ne", param);
    },
    cond: function(param) {
      return new AggregationOperator("cond", param);
    },
    ifNull: function(param) {
      return new AggregationOperator("ifNull", param);
    },
    switch: function(param) {
      return new AggregationOperator("switch", param);
    },
    dateFromParts: function(param) {
      return new AggregationOperator("dateFromParts", param);
    },
    dateFromString: function(param) {
      return new AggregationOperator("dateFromString", param);
    },
    dayOfMonth: function(param) {
      return new AggregationOperator("dayOfMonth", param);
    },
    dayOfWeek: function(param) {
      return new AggregationOperator("dayOfWeek", param);
    },
    dayOfYear: function(param) {
      return new AggregationOperator("dayOfYear", param);
    },
    isoDayOfWeek: function(param) {
      return new AggregationOperator("isoDayOfWeek", param);
    },
    isoWeek: function(param) {
      return new AggregationOperator("isoWeek", param);
    },
    isoWeekYear: function(param) {
      return new AggregationOperator("isoWeekYear", param);
    },
    millisecond: function(param) {
      return new AggregationOperator("millisecond", param);
    },
    minute: function(param) {
      return new AggregationOperator("minute", param);
    },
    month: function(param) {
      return new AggregationOperator("month", param);
    },
    second: function(param) {
      return new AggregationOperator("second", param);
    },
    hour: function(param) {
      return new AggregationOperator("hour", param);
    },
    week: function(param) {
      return new AggregationOperator("week", param);
    },
    year: function(param) {
      return new AggregationOperator("year", param);
    },
    literal: function(param) {
      return new AggregationOperator("literal", param);
    },
    mergeObjects: function(param) {
      return new AggregationOperator("mergeObjects", param);
    },
    objectToArray: function(param) {
      return new AggregationOperator("objectToArray", param);
    },
    allElementsTrue: function(param) {
      return new AggregationOperator("allElementsTrue", param);
    },
    anyElementTrue: function(param) {
      return new AggregationOperator("anyElementTrue", param);
    },
    setDifference: function(param) {
      return new AggregationOperator("setDifference", param);
    },
    setEquals: function(param) {
      return new AggregationOperator("setEquals", param);
    },
    setIntersection: function(param) {
      return new AggregationOperator("setIntersection", param);
    },
    setIsSubset: function(param) {
      return new AggregationOperator("setIsSubset", param);
    },
    setUnion: function(param) {
      return new AggregationOperator("setUnion", param);
    },
    concat: function(param) {
      return new AggregationOperator("concat", param);
    },
    dateToString: function(param) {
      return new AggregationOperator("dateToString", param);
    },
    indexOfBytes: function(param) {
      return new AggregationOperator("indexOfBytes", param);
    },
    indexOfCP: function(param) {
      return new AggregationOperator("indexOfCP", param);
    },
    split: function(param) {
      return new AggregationOperator("split", param);
    },
    strLenBytes: function(param) {
      return new AggregationOperator("strLenBytes", param);
    },
    strLenCP: function(param) {
      return new AggregationOperator("strLenCP", param);
    },
    strcasecmp: function(param) {
      return new AggregationOperator("strcasecmp", param);
    },
    substr: function(param) {
      return new AggregationOperator("substr", param);
    },
    substrBytes: function(param) {
      return new AggregationOperator("substrBytes", param);
    },
    substrCP: function(param) {
      return new AggregationOperator("substrCP", param);
    },
    toLower: function(param) {
      return new AggregationOperator("toLower", param);
    },
    toUpper: function(param) {
      return new AggregationOperator("toUpper", param);
    },
    meta: function(param) {
      return new AggregationOperator("meta", param);
    },
    addToSet: function(param) {
      return new AggregationOperator("addToSet", param);
    },
    avg: function(param) {
      return new AggregationOperator("avg", param);
    },
    first: function(param) {
      return new AggregationOperator("first", param);
    },
    last: function(param) {
      return new AggregationOperator("last", param);
    },
    max: function(param) {
      return new AggregationOperator("max", param);
    },
    min: function(param) {
      return new AggregationOperator("min", param);
    },
    push: function(param) {
      return new AggregationOperator("push", param);
    },
    stdDevPop: function(param) {
      return new AggregationOperator("stdDevPop", param);
    },
    stdDevSamp: function(param) {
      return new AggregationOperator("stdDevSamp", param);
    },
    sum: function(param) {
      return new AggregationOperator("sum", param);
    },
    let: function(param) {
      return new AggregationOperator("let", param);
    }
  },
  project: {
    slice: function(param) {
      return new ProjectionOperator("slice", param);
    },
    elemMatch: function(param) {
      return new ProjectionOperator("elemMatch", param);
    }
  }
};
var AggregationOperator = /* @__PURE__ */ function() {
  function AggregationOperator2(name2, param) {
    this["$" + name2] = param;
  }
  return AggregationOperator2;
}();
var ProjectionOperator = /* @__PURE__ */ function() {
  function ProjectionOperator2(name2, param) {
    this["$" + name2] = param;
  }
  return ProjectionOperator2;
}();
var RegExp$1 = function() {
  function RegExp2(_a2) {
    var regexp = _a2.regexp, options = _a2.options;
    if (!regexp) {
      throw new TypeError("regexp must be a string");
    }
    this.$regex = regexp;
    this.$options = options;
  }
  RegExp2.prototype.parse = function() {
    return {
      $regex: this.$regex,
      $options: this.$options
    };
  };
  Object.defineProperty(RegExp2.prototype, "_internalType", {
    get: function() {
      return SYMBOL_REGEXP;
    },
    enumerable: true,
    configurable: true
  });
  return RegExp2;
}();
function RegExpConstructor(param) {
  return new RegExp$1(param);
}
var ERRORS = {
  CREATE_WATCH_NET_ERROR: {
    code: "CREATE_WATCH_NET_ERROR",
    message: "create watch network error"
  },
  CREATE_WACTH_EXCEED_ERROR: {
    code: "CREATE_WACTH_EXCEED_ERROR",
    message: "maximum connections exceed"
  },
  CREATE_WATCH_SERVER_ERROR: {
    code: "CREATE_WATCH_SERVER_ERROR",
    message: "create watch server error"
  },
  CONN_ERROR: {
    code: "CONN_ERROR",
    message: "connection error"
  },
  INVALID_PARAM: {
    code: "INVALID_PARAM",
    message: "Invalid request param"
  },
  INSERT_DOC_FAIL: {
    code: "INSERT_DOC_FAIL",
    message: "insert document failed"
  },
  DATABASE_TRANSACTION_CONFLICT: {
    code: "DATABASE_TRANSACTION_CONFLICT",
    message: "database transaction conflict"
  }
};
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var GET_DOC = "database.getInTransaction";
var UPDATE_DOC = "database.updateDocInTransaction";
var DELETE_DOC = "database.deleteDocInTransaction";
var INSERT_DOC = "database.insertDocInTransaction";
var DocumentReference = function() {
  function DocumentReference2(transaction, coll, docID) {
    this._coll = coll;
    this.id = docID;
    this._transaction = transaction;
    this._request = this._transaction.getRequestMethod();
    this._transactionId = this._transaction.getTransactionId();
  }
  DocumentReference2.prototype.create = function(data) {
    return __awaiter$1(this, void 0, void 0, function() {
      var params, res, inserted, ok;
      return __generator$1(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            params = {
              collectionName: this._coll,
              transactionId: this._transactionId,
              data: EJSON.stringify(serialize(data), { relaxed: false })
            };
            if (this.id) {
              params["_id"] = this.id;
            }
            return [4, this._request.send(INSERT_DOC, params)];
          case 1:
            res = _a2.sent();
            if (res.code) {
              throw res;
            }
            inserted = EJSON.parse(res.inserted);
            ok = EJSON.parse(res.ok);
            if (ok == 1 && inserted == 1) {
              return [2, __assign$1(__assign$1({}, res), {
                ok,
                inserted
              })];
            } else {
              throw new Error(ERRORS.INSERT_DOC_FAIL.message);
            }
        }
      });
    });
  };
  DocumentReference2.prototype.get = function() {
    return __awaiter$1(this, void 0, void 0, function() {
      var param, res;
      return __generator$1(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            param = {
              collectionName: this._coll,
              transactionId: this._transactionId,
              query: {
                _id: { $eq: this.id }
              }
            };
            return [4, this._request.send(GET_DOC, param)];
          case 1:
            res = _a2.sent();
            if (res.code)
              throw res;
            return [2, {
              data: res.data !== "null" ? Util.formatField(EJSON.parse(res.data)) : EJSON.parse(res.data),
              requestId: res.requestId
            }];
        }
      });
    });
  };
  DocumentReference2.prototype.set = function(data) {
    return __awaiter$1(this, void 0, void 0, function() {
      var param, res;
      return __generator$1(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            param = {
              collectionName: this._coll,
              transactionId: this._transactionId,
              query: {
                _id: { $eq: this.id }
              },
              data: EJSON.stringify(serialize(data), { relaxed: false }),
              upsert: true
            };
            return [4, this._request.send(UPDATE_DOC, param)];
          case 1:
            res = _a2.sent();
            if (res.code)
              throw res;
            return [2, __assign$1(__assign$1({}, res), { updated: EJSON.parse(res.updated), upserted: res.upserted ? JSON.parse(res.upserted) : null })];
        }
      });
    });
  };
  DocumentReference2.prototype.update = function(data) {
    return __awaiter$1(this, void 0, void 0, function() {
      var param, res;
      return __generator$1(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            param = {
              collectionName: this._coll,
              transactionId: this._transactionId,
              query: {
                _id: { $eq: this.id }
              },
              data: EJSON.stringify(UpdateSerializer.encode(data), {
                relaxed: false
              })
            };
            return [4, this._request.send(UPDATE_DOC, param)];
          case 1:
            res = _a2.sent();
            if (res.code)
              throw res;
            return [2, __assign$1(__assign$1({}, res), { updated: EJSON.parse(res.updated) })];
        }
      });
    });
  };
  DocumentReference2.prototype.delete = function() {
    return __awaiter$1(this, void 0, void 0, function() {
      var param, res;
      return __generator$1(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            param = {
              collectionName: this._coll,
              transactionId: this._transactionId,
              query: {
                _id: { $eq: this.id }
              }
            };
            return [4, this._request.send(DELETE_DOC, param)];
          case 1:
            res = _a2.sent();
            if (res.code)
              throw res;
            return [2, __assign$1(__assign$1({}, res), { deleted: EJSON.parse(res.deleted) })];
        }
      });
    });
  };
  return DocumentReference2;
}();
var Query = /* @__PURE__ */ function() {
  function Query2(transaction, coll) {
    this._coll = coll;
    this._transaction = transaction;
  }
  return Query2;
}();
var __extends = /* @__PURE__ */ function() {
  var extendStatics3 = function(d2, b2) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    return extendStatics3(d2, b2);
  };
  return function(d2, b2) {
    extendStatics3(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CollectionReference = function(_super) {
  __extends(CollectionReference2, _super);
  function CollectionReference2(transaction, coll) {
    return _super.call(this, transaction, coll) || this;
  }
  Object.defineProperty(CollectionReference2.prototype, "name", {
    get: function() {
      return this._coll;
    },
    enumerable: true,
    configurable: true
  });
  CollectionReference2.prototype.doc = function(docID) {
    if (typeof docID !== "string" && typeof docID !== "number") {
      throw new Error("docId必须为字符串或数字");
    }
    return new DocumentReference(this._transaction, this._coll, docID);
  };
  CollectionReference2.prototype.add = function(data) {
    var docID;
    if (data._id !== void 0) {
      docID = data._id;
    }
    var docRef = new DocumentReference(this._transaction, this._coll, docID);
    return docRef.create(data);
  };
  return CollectionReference2;
}(Query);
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var START = "database.startTransaction";
var COMMIT = "database.commitTransaction";
var ABORT = "database.abortTransaction";
var Transaction = function() {
  function Transaction2(db) {
    this._db = db;
    this._request = new Db.reqClass(this._db.config);
    this.aborted = false;
    this.commited = false;
    this.inited = false;
  }
  Transaction2.prototype.init = function() {
    return __awaiter(this, void 0, void 0, function() {
      var res;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this._request.send(START)];
          case 1:
            res = _a2.sent();
            if (res.code) {
              throw res;
            }
            this.inited = true;
            this._id = res.transactionId;
            return [2];
        }
      });
    });
  };
  Transaction2.prototype.collection = function(collName) {
    if (!collName) {
      throw new Error("Collection name is required");
    }
    return new CollectionReference(this, collName);
  };
  Transaction2.prototype.getTransactionId = function() {
    return this._id;
  };
  Transaction2.prototype.getRequestMethod = function() {
    return this._request;
  };
  Transaction2.prototype.commit = function() {
    return __awaiter(this, void 0, void 0, function() {
      var param, res;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            param = {
              transactionId: this._id
            };
            return [4, this._request.send(COMMIT, param)];
          case 1:
            res = _a2.sent();
            if (res.code)
              throw res;
            this.commited = true;
            return [2, res];
        }
      });
    });
  };
  Transaction2.prototype.rollback = function(customRollbackRes) {
    return __awaiter(this, void 0, void 0, function() {
      var param, res;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            param = {
              transactionId: this._id
            };
            return [4, this._request.send(ABORT, param)];
          case 1:
            res = _a2.sent();
            if (res.code)
              throw res;
            this.aborted = true;
            this.abortReason = customRollbackRes;
            return [2, res];
        }
      });
    });
  };
  return Transaction2;
}();
function startTransaction() {
  return __awaiter(this, void 0, void 0, function() {
    var transaction;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          transaction = new Transaction(this);
          return [4, transaction.init()];
        case 1:
          _a2.sent();
          return [2, transaction];
      }
    });
  });
}
function runTransaction(callback, times) {
  if (times === void 0) {
    times = 3;
  }
  return __awaiter(this, void 0, void 0, function() {
    var transaction, callbackRes, error_1, throwWithRollback;
    var _this = this;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          _a2.trys.push([0, 4, , 10]);
          transaction = new Transaction(this);
          return [4, transaction.init()];
        case 1:
          _a2.sent();
          return [4, callback(transaction)];
        case 2:
          callbackRes = _a2.sent();
          if (transaction.aborted === true) {
            throw transaction.abortReason;
          }
          return [4, transaction.commit()];
        case 3:
          _a2.sent();
          return [2, callbackRes];
        case 4:
          error_1 = _a2.sent();
          if (transaction.inited === false) {
            throw error_1;
          }
          throwWithRollback = function(error) {
            return __awaiter(_this, void 0, void 0, function() {
              return __generator(this, function(_a3) {
                switch (_a3.label) {
                  case 0:
                    if (!(!transaction.aborted && !transaction.commited))
                      return [3, 5];
                    _a3.label = 1;
                  case 1:
                    _a3.trys.push([1, 3, , 4]);
                    return [4, transaction.rollback()];
                  case 2:
                    _a3.sent();
                    return [3, 4];
                  case 3:
                    _a3.sent();
                    return [3, 4];
                  case 4:
                    throw error;
                  case 5:
                    if (transaction.aborted === true) {
                      throw transaction.abortReason;
                    }
                    throw error;
                }
              });
            });
          };
          if (!(times <= 0))
            return [3, 6];
          return [4, throwWithRollback(error_1)];
        case 5:
          _a2.sent();
          _a2.label = 6;
        case 6:
          if (!(error_1 && error_1.code === ERRORS.DATABASE_TRANSACTION_CONFLICT.code))
            return [3, 8];
          return [4, runTransaction.bind(this)(callback, --times)];
        case 7:
          return [2, _a2.sent()];
        case 8:
          return [4, throwWithRollback(error_1)];
        case 9:
          _a2.sent();
          return [3, 10];
        case 10:
          return [2];
      }
    });
  });
}
var Db = function() {
  function Db2(config) {
    this.config = config;
    this.Geo = Geo;
    this.serverDate = ServerDateConstructor;
    this.command = Command;
    this.RegExp = RegExpConstructor;
    this.startTransaction = startTransaction;
    this.runTransaction = runTransaction;
    this.logicCommand = LogicCommand;
    this.updateCommand = UpdateCommand;
    this.queryCommand = QueryCommand;
  }
  Db2.prototype.collection = function(collName) {
    if (!collName) {
      throw new Error("Collection name is required");
    }
    return new CollectionReference$1(this, collName);
  };
  Db2.prototype.createCollection = function(collName) {
    var request = new Db2.reqClass(this.config);
    var params = {
      collectionName: collName
    };
    return request.send("database.addCollection", params);
  };
  return Db2;
}();
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var COMPONENT_NAME = "database";
function database(dbConfig) {
  var _a2 = this.platform, adapter2 = _a2.adapter, runtime2 = _a2.runtime;
  Db.reqClass = this.request.constructor;
  Db.getAccessToken = this.authInstance ? this.authInstance.getAccessToken.bind(this.authInstance) : function() {
    return "";
  };
  Db.runtime = runtime2;
  if (this.wsClientClass) {
    Db.wsClass = adapter2.wsClass;
    Db.wsClientClass = this.wsClientClass;
  }
  if (!Db.ws) {
    Db.ws = null;
  }
  return new Db(__assign(__assign(__assign({}, this.config), { _fromApp: this }), dbConfig));
}
var component = {
  name: COMPONENT_NAME,
  entity: {
    database
  }
};
try {
  cloudbase.registerComponent(component);
} catch (e2) {
}
function registerDatabase(app) {
  try {
    app.registerComponent(component);
  } catch (e2) {
    console.warn(e2);
  }
}
const name = "@cloudbase/js-sdk";
const version$1 = "2.9.1";
const description = "cloudbase javascript sdk";
const main = "dist/index.cjs.js";
const module$1 = "dist/index.esm.js";
const miniprogram = "miniprogram_dist";
const typings = "./index.d.ts";
const scripts = {
  lint: 'eslint --fix "./src/**/*.ts"',
  build: "rm -rf dist/ && gulp build",
  "build:cdn": "gulp cdn",
  "build:e2e": "rm -rf dist/ && NODE_ENV=e2e gulp e2e",
  precommit: "npm run lint"
};
const publishConfig = {
  access: "public"
};
const repository = {
  type: "git",
  url: "https://github.com/TencentCloudBase/cloudbase-js-sdk"
};
const keywords = [
  "tcb",
  "cloudbase",
  "Cloudbase",
  "serverless",
  "Serverless",
  "javascript",
  "JavaScript"
];
const files = [
  "miniprogram_dist",
  "**/dist/",
  "/index.d.ts",
  "**/package.json"
];
const components = [
  "app",
  "auth",
  "database",
  "functions",
  "storage"
];
const author = "";
const license = "Apache-2.0";
const dependencies = {
  "@cloudbase/adapter-interface": "^0.6.0",
  "@cloudbase/ai": "^2.9.1",
  "@cloudbase/analytics": "^2.9.1",
  "@cloudbase/app": "^2.9.1",
  "@cloudbase/auth": "^2.9.1",
  "@cloudbase/database": "0.9.21",
  "@cloudbase/functions": "^2.9.1",
  "@cloudbase/model": "^2.9.1",
  "@cloudbase/realtime": "^2.9.1",
  "@cloudbase/storage": "^2.9.1",
  "@cloudbase/types": "^2.9.1",
  "@cloudbase/utilities": "^2.9.1"
};
const browserslist = [
  "last 2 version",
  "> 1%",
  "chrome 53"
];
const gitHead = "911cb6e43f8474b1b6e20bf0ce6ab785cbb39210";
const pkg = {
  name,
  version: version$1,
  description,
  main,
  module: module$1,
  miniprogram,
  typings,
  scripts,
  publishConfig,
  repository,
  keywords,
  files,
  components,
  author,
  license,
  dependencies,
  browserslist,
  gitHead
};
var version = pkg.version;
cloudbase$1.registerVersion(version);
try {
  registerAuth(cloudbase$1);
  registerFunctions(cloudbase$1);
  registerStorage(cloudbase$1);
  registerDatabase(cloudbase$1);
  registerRealtime(cloudbase$1);
  registerAnalytics(cloudbase$1);
  registerModel(cloudbase$1);
  registerAi(cloudbase$1);
} catch (e2) {
}
try {
  window.cloudbase = cloudbase$1;
} catch (e2) {
}
const createHook = (lifecycle) => (hook2, target = getCurrentInstance()) => {
  !isInSSRComponentSetup && injectHook(lifecycle, hook2, target);
};
const onLoad = /* @__PURE__ */ createHook(ON_LOAD);
exports._export_sfc = _export_sfc;
exports.axios = axios;
exports.cloudbase = cloudbase$1;
exports.createSSRApp = createSSRApp;
exports.e = e$2;
exports.f = f$1;
exports.index = index;
exports.mpAdapter = mpAdapter;
exports.n = n$2;
exports.nextTick$1 = nextTick$1;
exports.o = o$1;
exports.onLoad = onLoad;
exports.onMounted = onMounted;
exports.p = p$1;
exports.ref = ref;
exports.resolveComponent = resolveComponent;
exports.s = s$1;
exports.t = t$1;
exports.watch = watch;
exports.wx$1 = wx$1;
