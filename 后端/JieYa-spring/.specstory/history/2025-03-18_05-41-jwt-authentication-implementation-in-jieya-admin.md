<!-- Generated by SpecStory -->

# JWT Authentication Implementation in Jieya Admin (2025-03-18 13:41:42)

_**User**_

在jieya-admin里面，增加一个jwt身份校验拦截，对除了登录接口进行校验，用当前生成token，给前端并存到redis里面，前端每次请求校验token

---

_**Assistant**_

我来帮你实现JWT身份校验拦截的功能。我们需要添加几个关键组件：

1. 首先创建JWT工具类：

```java:src/main/java/com/jieya/utils/JwtUtil.java
public class JwtUtil {
    private static final long EXPIRE_TIME = 24 * 60 * 60 * 1000; // 24小时
    private static final String SECRET = "jieya-secret-key";  // 密钥

    // 生成token
    public static String generateToken(String username) {
        Date now = new Date();
        Date expiration = new Date(now.getTime() + EXPIRE_TIME);
        
        return JWT.create()
                .withSubject(username)
                .withIssuedAt(now)
                .withExpiresAt(expiration)
                .sign(Algorithm.HMAC256(SECRET));
    }

    // 验证token
    public static boolean validateToken(String token) {
        try {
            JWT.require(Algorithm.HMAC256(SECRET)).build().verify(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    // 从token中获取用户名
    public static String getUsernameFromToken(String token) {
        return JWT.decode(token).getSubject();
    }
}
```

2. 创建拦截器：

```java:jieya-common/src/main/java/com/example/common/utils/JwtUtil.java
@Component
public class JwtInterceptor implements HandlerInterceptor {
    
    @Autowired
    private StringRedisTemplate redisTemplate;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 放行登录接口
        if (request.getRequestURI().contains("/login")) {
            return true;
        }

        // 获取token
        String token = request.getHeader("Authorization");
        if (StringUtils.isEmpty(token)) {
            throw new RuntimeException("未登录，请先登录");
        }

        // 验证token是否有效
        if (!JwtUtil.validateToken(token)) {
            throw new RuntimeException("token无效");
        }

        // 从redis中获取token
        String username = JwtUtil.getUsernameFromToken(token);
        String redisToken = redisTemplate.opsForValue().get("token:" + username);
        
        if (StringUtils.isEmpty(redisToken) || !token.equals(redisToken)) {
            throw new RuntimeException("token已过期，请重新登录");
        }

        return true;
    }
}
```

3. 配置拦截器：

```java:src/main/java/com/jieya/config/WebMvcConfig.java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Autowired
    private JwtInterceptor jwtInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(jwtInterceptor)
                .addPathPatterns("/**")  // 拦截所有请求
                .excludePathPatterns("/login"); // 排除登录接口
    }
}
```

4. 在登录接口中生成token并存储到Redis：

```java:src/main/java/com/jieya/controller/LoginController.java
// ... existing code ...
@PostMapping("/login")
public Result login(@RequestBody LoginDTO loginDTO) {
    // 验证用户名密码
    // ... existing code ...

    // 生成token
    String token = JwtUtil.generateToken(username);
    
    // 存储到Redis，设置24小时过期
    redisTemplate.opsForValue().set("token:" + username, token, 24, TimeUnit.HOURS);
    
    // 返回token给前端
    Map<String, Object> map = new HashMap<>();
    map.put("token", token);
    return Result.success(map);
}
// ... existing code ...
```

5. 在application.yml中添加Redis配置：

```yaml:src/main/resources/application.yml
spring:
  redis:
    host: localhost
    port: 6379
    database: 0
```

使用说明：
1. 前端在登录成功后需要保存返回的token
2. 之后的每次请求都需要在请求头中添加：`Authorization: ${token}`
3. 如果token无效或过期，会返回相应的错误信息
4. token有效期为24小时

需要添加的依赖：

```xml:pom.xml
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>4.3.0</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

这样就完成了JWT身份校验的实现。系统会对除登录接口外的所有请求进行token验证，确保接口的安全性。当用户登录时会生成新的token并存储在Redis中，每次请求都会验证token的有效性和是否与Redis中存储的一致。

---



---

